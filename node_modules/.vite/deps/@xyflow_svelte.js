import "./chunk-X7HCJ7ZS.js";
import "./chunk-SA3VOP2B.js";
import {
  derived,
  readable,
  writable
} from "./chunk-ZIJOD7DG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_iframe_resize_listener,
  add_location,
  add_render_callback,
  append_dev,
  append_styles,
  assign,
  attr_dev,
  binding_callbacks,
  bubble,
  check_outros,
  component_subscribe,
  compute_rest_props,
  compute_slots,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  globals,
  group_outros,
  hasContext,
  init,
  insert_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  not_equal,
  null_to_empty,
  onDestroy,
  onMount,
  outro_and_destroy_block,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  set_data_dev,
  set_store_value,
  set_style,
  space,
  subscribe,
  svg_element,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-5RNXQC66.js";
import "./chunk-EKIRE5YT.js";
import "./chunk-JVWSFFO4.js";

// node_modules/classcat/index.js
function cc(names) {
  if (typeof names === "string" || typeof names === "number") return "" + names;
  let out = "";
  if (Array.isArray(names)) {
    for (let i = 0, tmp; i < names.length; i++) {
      if ((tmp = cc(names[i])) !== "") {
        out += (out && " ") + tmp;
      }
    }
  } else {
    for (let k in names) {
      if (names[k]) out += (out && " ") + k;
    }
  }
  return out;
}

// node_modules/d3-dispatch/src/dispatch.js
var noop2 = { value: () => {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return { type: t, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};
function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}
function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop2, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({ name, value: callback });
  return type;
}
var dispatch_default = dispatch;

// node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces_default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/d3-selection/src/namespace.js
function namespace_default(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
}

// node_modules/d3-selection/src/creator.js
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name) {
  var fullname = namespace_default(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

// node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

// node_modules/d3-selection/src/selection/select.js
function select_default(select) {
  if (typeof select !== "function") select = selector_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/array.js
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}

// node_modules/d3-selection/src/selectorAll.js
function empty2() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty2 : function() {
    return this.querySelectorAll(selector);
  };
}

// node_modules/d3-selection/src/selection/selectAll.js
function arrayAll(select) {
  return function() {
    return array(select.apply(this, arguments));
  };
}
function selectAll_default(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = selectorAll_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}

// node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
  return function() {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}

// node_modules/d3-selection/src/selection/selectChild.js
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selectChild_default(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/selectChildren.js
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selectChildren_default(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/filter.js
function filter_default(match) {
  if (typeof match !== "function") match = matcher_default(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update) {
  return new Array(update.length);
}

// node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

// node_modules/d3-selection/src/constant.js
function constant_default(x) {
  return function() {
    return x;
  };
}

// node_modules/d3-selection/src/selection/data.js
function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0, node, groupLength = group.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data, key2) {
  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key2.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key2.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
      exit[i] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function data_default(value, key2) {
  if (!arguments.length) return Array.from(this, datum);
  var bind = key2 ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value !== "function") value = constant_default(value);
  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key2);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength) ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}

// node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}

// node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove();
  else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

// node_modules/d3-selection/src/selection/merge.js
function merge_default(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection(merges, this._parents);
}

// node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/sort.js
function sort_default(compare) {
  if (!compare) compare = ascending;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

// node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  return Array.from(this);
}

// node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }
  return null;
}

// node_modules/d3-selection/src/selection/size.js
function size_default() {
  let size = 0;
  for (const node of this) ++size;
  return size;
}

// node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}

// node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/attr.js
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}
function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function attr_default(name, value) {
  var fullname = namespace_default(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}

// node_modules/d3-selection/src/window.js
function window_default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}

// node_modules/d3-selection/src/selection/style.js
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}
function style_default(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
}

// node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}
function property_default(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}

// node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function classed_default(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}

// node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function text_default(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}

// node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function html_default(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}

// node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}

// node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower);
}

// node_modules/d3-selection/src/selection/append.js
function append_default(name) {
  var create2 = typeof name === "function" ? name : creator_default(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}

// node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name, before) {
  var create2 = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

// node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}
function remove_default() {
  return this.each(remove);
}

// node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

// node_modules/d3-selection/src/selection/datum.js
function datum_default(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}

// node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = { type: typename.type, name: typename.name, value, listener, options };
    if (!on) this.__on = [o];
    else on.push(o);
  };
}
function on_default(typename, value, options) {
  var typenames = parseTypenames2(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
}

// node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type, params) {
  var window2 = window_default(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}
function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}
function dispatch_default2(type, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
}

// node_modules/d3-selection/src/selection/iterator.js
function* iterator_default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
}

// node_modules/d3-selection/src/selection/index.js
var root = [null];
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: select_default,
  selectAll: selectAll_default,
  selectChild: selectChild_default,
  selectChildren: selectChildren_default,
  filter: filter_default,
  data: data_default,
  enter: enter_default,
  exit: exit_default,
  join: join_default,
  merge: merge_default,
  selection: selection_selection,
  order: order_default,
  sort: sort_default,
  call: call_default,
  nodes: nodes_default,
  node: node_default,
  size: size_default,
  empty: empty_default,
  each: each_default,
  attr: attr_default,
  style: style_default,
  property: property_default,
  classed: classed_default,
  text: text_default,
  html: html_default,
  raise: raise_default,
  lower: lower_default,
  append: append_default,
  insert: insert_default,
  remove: remove_default,
  clone: clone_default,
  datum: datum_default,
  on: on_default,
  dispatch: dispatch_default2,
  [Symbol.iterator]: iterator_default
};
var selection_default = selection;

// node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
}

// node_modules/d3-selection/src/local.js
var nextId = 0;
function local() {
  return new Local();
}
function Local() {
  this._ = "@" + (++nextId).toString(36);
}
Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id2 = this._;
    while (!(id2 in node)) if (!(node = node.parentNode)) return;
    return node[id2];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

// node_modules/d3-selection/src/sourceEvent.js
function sourceEvent_default(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
}

// node_modules/d3-selection/src/pointer.js
function pointer_default(event, node) {
  event = sourceEvent_default(event);
  if (node === void 0) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}

// node_modules/d3-drag/src/noevent.js
var nonpassive = { passive: false };
var nonpassivecapture = { capture: true, passive: false };
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function noevent_default(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/d3-drag/src/nodrag.js
function nodrag_default(view) {
  var root2 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", noevent_default, nonpassivecapture);
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", noevent_default, nonpassivecapture);
  } else {
    root2.__noselect = root2.style.MozUserSelect;
    root2.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root2 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent_default, nonpassivecapture);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", null);
  } else {
    root2.style.MozUserSelect = root2.__noselect;
    delete root2.__noselect;
  }
}

// node_modules/d3-drag/src/constant.js
var constant_default2 = (x) => () => x;

// node_modules/d3-drag/src/event.js
function DragEvent(type, {
  sourceEvent,
  subject,
  target,
  identifier,
  active,
  x,
  y,
  dx,
  dy,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    subject: { value: subject, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    identifier: { value: identifier, enumerable: true, configurable: true },
    active: { value: active, enumerable: true, configurable: true },
    x: { value: x, enumerable: true, configurable: true },
    y: { value: y, enumerable: true, configurable: true },
    dx: { value: dx, enumerable: true, configurable: true },
    dy: { value: dy, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

// node_modules/d3-drag/src/drag.js
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}
function defaultContainer() {
  return this.parentNode;
}
function defaultSubject(event, d) {
  return d == null ? { x: event.x, y: event.y } : d;
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function drag_default() {
  var filter2 = defaultFilter, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {}, listeners = dispatch_default("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
  function drag2(selection2) {
    selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function mousedowned(event, d) {
    if (touchending || !filter2.call(this, event, d)) return;
    var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
    if (!gesture) return;
    select_default2(event.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture);
    nodrag_default(event.view);
    nopropagation(event);
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start", event);
  }
  function mousemoved(event) {
    noevent_default(event);
    if (!mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }
  function mouseupped(event) {
    select_default2(event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(event.view, mousemoving);
    noevent_default(event);
    gestures.mouse("end", event);
  }
  function touchstarted(event, d) {
    if (!filter2.call(this, event, d)) return;
    var touches = event.changedTouches, c = container.call(this, event, d), n = touches.length, i, gesture;
    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
        nopropagation(event);
        gesture("start", event, touches[i]);
      }
    }
  }
  function touchmoved(event) {
    var touches = event.changedTouches, n = touches.length, i, gesture;
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        noevent_default(event);
        gesture("drag", event, touches[i]);
      }
    }
  }
  function touchended(event) {
    var touches = event.changedTouches, n = touches.length, i, gesture;
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, 500);
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        nopropagation(event);
        gesture("end", event, touches[i]);
      }
    }
  }
  function beforestart(that, container2, event, d, identifier, touch) {
    var dispatch2 = listeners.copy(), p = pointer_default(touch || event, container2), dx, dy, s;
    if ((s = subject.call(that, new DragEvent("beforestart", {
      sourceEvent: event,
      target: drag2,
      identifier,
      active,
      x: p[0],
      y: p[1],
      dx: 0,
      dy: 0,
      dispatch: dispatch2
    }), d)) == null) return;
    dx = s.x - p[0] || 0;
    dy = s.y - p[1] || 0;
    return function gesture(type, event2, touch2) {
      var p0 = p, n;
      switch (type) {
        case "start":
          gestures[identifier] = gesture, n = active++;
          break;
        case "end":
          delete gestures[identifier], --active;
        case "drag":
          p = pointer_default(touch2 || event2, container2), n = active;
          break;
      }
      dispatch2.call(
        type,
        that,
        new DragEvent(type, {
          sourceEvent: event2,
          subject: s,
          target: drag2,
          identifier,
          active: n,
          x: p[0] + dx,
          y: p[1] + dy,
          dx: p[0] - p0[0],
          dy: p[1] - p0[1],
          dispatch: dispatch2
        }),
        d
      );
    };
  }
  drag2.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant_default2(!!_), drag2) : filter2;
  };
  drag2.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : constant_default2(_), drag2) : container;
  };
  drag2.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : constant_default2(_), drag2) : subject;
  };
  drag2.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default2(!!_), drag2) : touchable;
  };
  drag2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag2 : value;
  };
  drag2.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag2) : Math.sqrt(clickDistance2);
  };
  return drag2;
}

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key2 in definition) prototype[key2] = definition[key2];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h = NaN, s = max - min, l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y;
  else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}
function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}
function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend(Color, {
  brighter(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb() {
    var y = (this.l + 16) / 116, x = isNaN(this.a) ? y : y + this.a / 500, z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.033454 * z),
      lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x) {
  return 255 * (x <= 31308e-7 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend(Color, {
  brighter(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k = (E * (g - l) - C * bl) / D, s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), h = s ? Math.atan2(k, bl) * degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}
function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh2 + B * sinh2)),
      255 * (l + a * (C * cosh2 + D * sinh2)),
      255 * (l + a * (E * cosh2)),
      this.opacity
    );
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t12, v0, v1, v2, v3) {
  var t22 = t12 * t12, t32 = t22 * t12;
  return ((1 - 3 * t12 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t12 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default3 = (x) => () => x;

// node_modules/d3-interpolate/src/color.js
function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default3(isNaN(a) ? b : a);
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant_default3(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant_default3(isNaN(a) ? b : a);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y) {
  var color2 = gamma(y);
  function rgb2(start2, end) {
    var r = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.r = r(t);
      start2.g = g(t);
      start2.b = b(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb(colors[i]);
      r[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/number.js
function number_default(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs;
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i]) s[i] += bm;
      else s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs;
    else s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2) s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity : decompose_default(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value) {
  if (value == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360;
      else if (b - a > 180) a += 360;
      q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s = [], q = [];
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon2 = 1e-12;
function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}
function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}
function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}
var zoom_default = function zoomRho(rho, rho2, rho4) {
  function zoom2(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b02 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b12 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b02 * b02 + 1) - b02), r1 = Math.log(Math.sqrt(b12 * b12 + 1) - b12);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom2.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom2;
}(Math.SQRT2, 2, 4);

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start2, end) {
    var h = hue2((start2 = hsl(start2)).h, (end = hsl(end)).h), s = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.h = h(t);
      start2.s = s(t);
      start2.l = l(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start2, end) {
    var h = hue2((start2 = hcl(start2)).h, (end = hcl(end)).h), c = nogamma(start2.c, end.c), l = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.h = h(t);
      start2.c = c(t);
      start2.l = l(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y) {
    y = +y;
    function cubehelix3(start2, end) {
      var h = hue2((start2 = cubehelix(start2)).h, (end = cubehelix(end)).h), s = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
      return function(t) {
        start2.h = h(t);
        start2.s = s(t);
        start2.l = l(Math.pow(t, y));
        start2.opacity = opacity(t);
        return start2 + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(void 0, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t02, t12 = taskHead, t22, time = Infinity;
  while (t12) {
    if (t12._call) {
      if (time > t12._time) time = t12._time;
      t02 = t12, t12 = t12._next;
    } else {
      t22 = t12._next, t12._next = null;
      t12 = t02 ? t02._next = t22 : taskHead = t22;
    }
  }
  taskTail = t02;
  sleep(time);
}
function sleep(time) {
  if (frame) return;
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-timer/src/timeout.js
function timeout_default(callback, delay, time) {
  var t = new Timer();
  delay = delay == null ? 0 : +delay;
  t.restart((elapsed) => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

// node_modules/d3-transition/src/transition/schedule.js
var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule_default(node, name, id2, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id2 in schedules) return;
  create(node, id2, {
    name,
    index,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init2(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}
function set2(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}
function get2(node, id2) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id2])) throw new Error("transition not found");
  return schedule;
}
function create(node, id2, self) {
  var schedules = node.__transition, tween;
  schedules[id2] = self;
  self.timer = timer(schedule, 0, self.time);
  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start2, self.delay, self.time);
    if (self.delay <= elapsed) start2(elapsed - self.delay);
  }
  function start2(elapsed) {
    var i, j, n, o;
    if (self.state !== SCHEDULED) return stop();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;
      if (o.state === STARTED) return timeout_default(start2);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      } else if (+i < id2) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }
    timeout_default(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return;
    self.state = STARTED;
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1), i = -1, n = tween.length;
    while (++i < n) {
      tween[i].call(node, t);
    }
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }
  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id2];
    for (var i in schedules) return;
    delete node.__transition;
  }
}

// node_modules/d3-transition/src/interrupt.js
function interrupt_default(node, name) {
  var schedules = node.__transition, schedule, active, empty3 = true, i;
  if (!schedules) return;
  name = name == null ? null : name + "";
  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) {
      empty3 = false;
      continue;
    }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }
  if (empty3) delete node.__transition;
}

// node_modules/d3-transition/src/selection/interrupt.js
function interrupt_default2(name) {
  return this.each(function() {
    interrupt_default(this, name);
  });
}

// node_modules/d3-transition/src/transition/tween.js
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error();
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = { name, value }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }
    schedule.tween = tween1;
  };
}
function tween_default(name, value) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get2(this.node(), id2).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition2, name, value) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule = set2(this, id2);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node) {
    return get2(node, id2).value[name];
  };
}

// node_modules/d3-transition/src/transition/interpolate.js
function interpolate_default(a, b) {
  var c;
  return (typeof b === "number" ? number_default : b instanceof color ? rgb_default : (c = color(b)) ? (b = c, rgb_default) : string_default)(a, b);
}

// node_modules/d3-transition/src/transition/attr.js
function attrRemove2(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS2(fullname, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS2(fullname, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attr_default2(name, value) {
  var fullname = namespace_default(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value));
}

// node_modules/d3-transition/src/transition/attrTween.js
function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS(fullname, value) {
  var t02, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t02 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t02;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t02, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t02 = (i0 = i) && attrInterpolate(name, i);
    return t02;
  }
  tween._value = value;
  return tween;
}
function attrTween_default(name, value) {
  var key2 = "attr." + name;
  if (arguments.length < 2) return (key2 = this.tween(key2)) && key2._value;
  if (value == null) return this.tween(key2, null);
  if (typeof value !== "function") throw new Error();
  var fullname = namespace_default(name);
  return this.tween(key2, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

// node_modules/d3-transition/src/transition/delay.js
function delayFunction(id2, value) {
  return function() {
    init2(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init2(this, id2).delay = value;
  };
}
function delay_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get2(this.node(), id2).delay;
}

// node_modules/d3-transition/src/transition/duration.js
function durationFunction(id2, value) {
  return function() {
    set2(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set2(this, id2).duration = value;
  };
}
function duration_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get2(this.node(), id2).duration;
}

// node_modules/d3-transition/src/transition/ease.js
function easeConstant(id2, value) {
  if (typeof value !== "function") throw new Error();
  return function() {
    set2(this, id2).ease = value;
  };
}
function ease_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get2(this.node(), id2).ease;
}

// node_modules/d3-transition/src/transition/easeVarying.js
function easeVarying(id2, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error();
    set2(this, id2).ease = v;
  };
}
function easeVarying_default(value) {
  if (typeof value !== "function") throw new Error();
  return this.each(easeVarying(this._id, value));
}

// node_modules/d3-transition/src/transition/filter.js
function filter_default2(match) {
  if (typeof match !== "function") match = matcher_default(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/merge.js
function merge_default2(transition2) {
  if (transition2._id !== this._id) throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/on.js
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init2 : set2;
  return function() {
    var schedule = sit(this, id2), on = schedule.on;
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
    schedule.on = on1;
  };
}
function on_default2(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get2(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}

// node_modules/d3-transition/src/transition/remove.js
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id2) return;
    if (parent) parent.removeChild(this);
  };
}
function remove_default2() {
  return this.on("end.remove", removeFunction(this._id));
}

// node_modules/d3-transition/src/transition/select.js
function select_default3(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function") select = selector_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule_default(subgroup[i], name, id2, i, subgroup, get2(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}

// node_modules/d3-transition/src/transition/selectAll.js
function selectAll_default3(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function") select = selectorAll_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children2 = select.call(node, node.__data__, i, group), child, inherit2 = get2(node, id2), k = 0, l = children2.length; k < l; ++k) {
          if (child = children2[k]) {
            schedule_default(child, name, id2, k, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}

// node_modules/d3-transition/src/transition/selection.js
var Selection2 = selection_default.prototype.constructor;
function selection_default2() {
  return new Selection2(this._groups, this._parents);
}

// node_modules/d3-transition/src/transition/style.js
function styleNull(name, interpolate) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove2(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key2 = "style." + name, event = "end." + key2, remove2;
  return function() {
    var schedule = set2(this, id2), on = schedule.on, listener = schedule.value[key2] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule.on = on1;
  };
}
function style_default2(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
  return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i, value), priority).on("end.style." + name, null);
}

// node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}
function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}
function styleTween_default(name, value, priority) {
  var key2 = "style." + (name += "");
  if (arguments.length < 2) return (key2 = this.tween(key2)) && key2._value;
  if (value == null) return this.tween(key2, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key2, styleTween(name, value, priority == null ? "" : priority));
}

// node_modules/d3-transition/src/transition/text.js
function textConstant2(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction2(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function text_default2(value) {
  return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
}

// node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}
function textTween(value) {
  var t02, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t02 = (i0 = i) && textInterpolate(i);
    return t02;
  }
  tween._value = value;
  return tween;
}
function textTween_default(value) {
  var key2 = "text";
  if (arguments.length < 1) return (key2 = this.tween(key2)) && key2._value;
  if (value == null) return this.tween(key2, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key2, textTween(value));
}

// node_modules/d3-transition/src/transition/transition.js
function transition_default() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit2 = get2(node, id0);
        schedule_default(node, name, id1, i, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name, id1);
}

// node_modules/d3-transition/src/transition/end.js
function end_default() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0) resolve();
    } };
    that.each(function() {
      var schedule = set2(this, id2), on = schedule.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule.on = on1;
    });
    if (size === 0) resolve();
  });
}

// node_modules/d3-transition/src/transition/index.js
var id = 0;
function Transition(groups, parents, name, id2) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function transition(name) {
  return selection_default().transition(name);
}
function newId() {
  return ++id;
}
var selection_prototype = selection_default.prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: select_default3,
  selectAll: selectAll_default3,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: filter_default2,
  merge: merge_default2,
  selection: selection_default2,
  transition: transition_default,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: on_default2,
  attr: attr_default2,
  attrTween: attrTween_default,
  style: style_default2,
  styleTween: styleTween_default,
  text: text_default2,
  textTween: textTween_default,
  remove: remove_default2,
  tween: tween_default,
  delay: delay_default,
  duration: duration_default,
  ease: ease_default,
  easeVarying: easeVarying_default,
  end: end_default,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

// node_modules/d3-ease/src/cubic.js
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

// node_modules/d3-ease/src/poly.js
var exponent = 3;
var polyIn = function custom(e) {
  e = +e;
  function polyIn2(t) {
    return Math.pow(t, e);
  }
  polyIn2.exponent = custom;
  return polyIn2;
}(exponent);
var polyOut = function custom2(e) {
  e = +e;
  function polyOut2(t) {
    return 1 - Math.pow(1 - t, e);
  }
  polyOut2.exponent = custom2;
  return polyOut2;
}(exponent);
var polyInOut = function custom3(e) {
  e = +e;
  function polyInOut2(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }
  polyInOut2.exponent = custom3;
  return polyInOut2;
}(exponent);

// node_modules/d3-ease/src/sin.js
var pi = Math.PI;
var halfPi = pi / 2;

// node_modules/d3-ease/src/math.js
function tpmt(x) {
  return (Math.pow(2, -10 * x) - 9765625e-10) * 1.0009775171065494;
}

// node_modules/d3-ease/src/bounce.js
var b1 = 4 / 11;
var b2 = 6 / 11;
var b3 = 8 / 11;
var b4 = 3 / 4;
var b5 = 9 / 11;
var b6 = 10 / 11;
var b7 = 15 / 16;
var b8 = 21 / 22;
var b9 = 63 / 64;
var b0 = 1 / b1 / b1;

// node_modules/d3-ease/src/back.js
var overshoot = 1.70158;
var backIn = function custom4(s) {
  s = +s;
  function backIn2(t) {
    return (t = +t) * t * (s * (t - 1) + t);
  }
  backIn2.overshoot = custom4;
  return backIn2;
}(overshoot);
var backOut = function custom5(s) {
  s = +s;
  function backOut2(t) {
    return --t * t * ((t + 1) * s + t) + 1;
  }
  backOut2.overshoot = custom5;
  return backOut2;
}(overshoot);
var backInOut = function custom6(s) {
  s = +s;
  function backInOut2(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }
  backInOut2.overshoot = custom6;
  return backInOut2;
}(overshoot);

// node_modules/d3-ease/src/elastic.js
var tau = 2 * Math.PI;
var amplitude = 1;
var period = 0.3;
var elasticIn = function custom7(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticIn2(t) {
    return a * tpmt(- --t) * Math.sin((s - t) / p);
  }
  elasticIn2.amplitude = function(a2) {
    return custom7(a2, p * tau);
  };
  elasticIn2.period = function(p2) {
    return custom7(a, p2);
  };
  return elasticIn2;
}(amplitude, period);
var elasticOut = function custom8(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticOut2(t) {
    return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
  }
  elasticOut2.amplitude = function(a2) {
    return custom8(a2, p * tau);
  };
  elasticOut2.period = function(p2) {
    return custom8(a, p2);
  };
  return elasticOut2;
}(amplitude, period);
var elasticInOut = function custom9(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticInOut2(t) {
    return ((t = t * 2 - 1) < 0 ? a * tpmt(-t) * Math.sin((s - t) / p) : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
  }
  elasticInOut2.amplitude = function(a2) {
    return custom9(a2, p * tau);
  };
  elasticInOut2.period = function(p2) {
    return custom9(a, p2);
  };
  return elasticInOut2;
}(amplitude, period);

// node_modules/d3-transition/src/selection/transition.js
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function transition_default2(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule_default(node, name, id2, i, group, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups, this._parents, name, id2);
}

// node_modules/d3-transition/src/selection/index.js
selection_default.prototype.interrupt = interrupt_default2;
selection_default.prototype.transition = transition_default2;

// node_modules/d3-zoom/src/constant.js
var constant_default4 = (x) => () => x;

// node_modules/d3-zoom/src/event.js
function ZoomEvent(type, {
  sourceEvent,
  target,
  transform: transform2,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    transform: { value: transform2, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}

// node_modules/d3-zoom/src/transform.js
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity2 = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity2;
  return node.__zoom;
}

// node_modules/d3-zoom/src/noevent.js
function nopropagation2(event) {
  event.stopImmediatePropagation();
}
function noevent_default2(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/d3-zoom/src/zoom.js
function defaultFilter2(event) {
  return (!event.ctrlKey || event.type === "wheel") && !event.button;
}
function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity2;
}
function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable2() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform2, extent, translateExtent) {
  var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
  return transform2.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}
function zoom_default2() {
  var filter2 = defaultFilter2, extent = defaultExtent, constrain = defaultConstrain, wheelDelta2 = defaultWheelDelta, touchable = defaultTouchable2, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = zoom_default, listeners = dispatch_default("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
  function zoom2(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom2.transform = function(collection, transform2, point, event) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform);
    if (collection !== selection2) {
      schedule(collection, transform2, point, event);
    } else {
      selection2.interrupt().each(function() {
        gesture(this, arguments).event(event).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
      });
    }
  };
  zoom2.scaleBy = function(selection2, k, p, event) {
    zoom2.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };
  zoom2.scaleTo = function(selection2, k, p, event) {
    zoom2.transform(selection2, function() {
      var e = extent.apply(this, arguments), t02 = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t02.invert(p0), k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t02, k1), p0, p1), e, translateExtent);
    }, p, event);
  };
  zoom2.translateBy = function(selection2, x, y, event) {
    zoom2.transform(selection2, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };
  zoom2.translateTo = function(selection2, x, y, p, event) {
    zoom2.transform(selection2, function() {
      var e = extent.apply(this, arguments), t = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(identity2.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p, event);
  };
  function scale(transform2, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform2.k ? transform2 : new Transform(k, transform2.x, transform2.y);
  }
  function translate(transform2, p0, p1) {
    var x = p0[0] - p1[0] * transform2.k, y = p0[1] - p1[1] * transform2.k;
    return x === transform2.x && y === transform2.y ? transform2 : new Transform(transform2.k, x, y);
  }
  function centroid(extent2) {
    return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
  }
  function schedule(transition2, transform2, point, event) {
    transition2.on("start.zoom", function() {
      gesture(this, arguments).event(event).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).event(event).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g = gesture(that, args).event(event), e = extent.apply(that, args), p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point, w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a = that.__zoom, b = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
      return function(t) {
        if (t === 1) t = b;
        else {
          var l = i(t), k = w / l[2];
          t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
        }
        g.zoom(null, t);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    event: function(event) {
      if (event) this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key2, transform2) {
      if (this.mouse && key2 !== "mouse") this.mouse[1] = transform2.invert(this.mouse[0]);
      if (this.touch0 && key2 !== "touch") this.touch0[1] = transform2.invert(this.touch0[0]);
      if (this.touch1 && key2 !== "touch") this.touch1[1] = transform2.invert(this.touch1[0]);
      this.that.__zoom = transform2;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = select_default2(this.that).datum();
      listeners.call(
        type,
        this.that,
        new ZoomEvent(type, {
          sourceEvent: this.sourceEvent,
          target: zoom2,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };
  function wheeled(event, ...args) {
    if (!filter2.apply(this, arguments)) return;
    var g = gesture(this, args).event(event), t = this.__zoom, k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta2.apply(this, arguments)))), p = pointer_default(event);
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    } else if (t.k === k) return;
    else {
      g.mouse = [p, t.invert(p)];
      interrupt_default(this);
      g.start();
    }
    noevent_default2(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }
  function mousedowned(event, ...args) {
    if (touchending || !filter2.apply(this, arguments)) return;
    var currentTarget = event.currentTarget, g = gesture(this, args, true).event(event), v = select_default2(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = pointer_default(event, currentTarget), x0 = event.clientX, y0 = event.clientY;
    nodrag_default(event.view);
    nopropagation2(event);
    g.mouse = [p, this.__zoom.invert(p)];
    interrupt_default(this);
    g.start();
    function mousemoved(event2) {
      noevent_default2(event2);
      if (!g.moved) {
        var dx = event2.clientX - x0, dy = event2.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event2).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer_default(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }
    function mouseupped(event2) {
      v.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(event2.view, g.moved);
      noevent_default2(event2);
      g.event(event2).end();
    }
  }
  function dblclicked(event, ...args) {
    if (!filter2.apply(this, arguments)) return;
    var t02 = this.__zoom, p0 = pointer_default(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t02.invert(p0), k1 = t02.k * (event.shiftKey ? 0.5 : 2), t12 = constrain(translate(scale(t02, k1), p0, p1), extent.apply(this, args), translateExtent);
    noevent_default2(event);
    if (duration > 0) select_default2(this).transition().duration(duration).call(schedule, t12, p0, event);
    else select_default2(this).call(zoom2.transform, t12, p0, event);
  }
  function touchstarted(event, ...args) {
    if (!filter2.apply(this, arguments)) return;
    var touches = event.touches, n = touches.length, g = gesture(this, args, event.changedTouches.length === n).event(event), started, i, t, p;
    nopropagation2(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer_default(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() {
        touchstarting = null;
      }, touchDelay);
      interrupt_default(this);
      g.start();
    }
  }
  function touchmoved(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t, p, l;
    noevent_default2(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer_default(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }
  function touchended(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t;
    nopropagation2(event);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      if (g.taps === 2) {
        t = pointer_default(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = select_default2(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
        }
      }
    }
  }
  zoom2.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta2 = typeof _ === "function" ? _ : constant_default4(+_), zoom2) : wheelDelta2;
  };
  zoom2.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant_default4(!!_), zoom2) : filter2;
  };
  zoom2.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default4(!!_), zoom2) : touchable;
  };
  zoom2.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant_default4([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom2) : extent;
  };
  zoom2.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom2) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom2.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom2) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom2.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom2) : constrain;
  };
  zoom2.duration = function(_) {
    return arguments.length ? (duration = +_, zoom2) : duration;
  };
  zoom2.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom2) : interpolate;
  };
  zoom2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom2 : value;
  };
  zoom2.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom2) : Math.sqrt(clickDistance2);
  };
  zoom2.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom2) : tapDistance;
  };
  return zoom2;
}

// node_modules/@xyflow/system/dist/esm/index.mjs
var errorMessages = {
  error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
  error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
  error003: (nodeType) => `Node type "${nodeType}" not found. Using fallback type "default".`,
  error004: () => "The React Flow parent container needs a width and a height to render the graph.",
  error005: () => "Only child nodes can use a parent extent.",
  error006: () => "Can't create edge. An edge needs a source and a target.",
  error007: (id2) => `The old edge with id=${id2} does not exist.`,
  error009: (type) => `Marker type "${type}" doesn't exist.`,
  error008: (handleType, { id: id2, sourceHandle, targetHandle }) => `Couldn't create edge for ${handleType} handle id: "${!sourceHandle ? sourceHandle : targetHandle}", edge id: ${id2}.`,
  error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
  error011: (edgeType) => `Edge type "${edgeType}" not found. Using fallback type "default".`,
  error012: (id2) => `Node with id "${id2}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
  error013: (lib = "react") => `It seems that you haven't loaded the styles. Please import '@xyflow/${lib}/dist/style.css' or base.css to make sure everything is working properly.`
};
var infiniteExtent = [
  [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
  [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
];
var ConnectionMode;
(function(ConnectionMode2) {
  ConnectionMode2["Strict"] = "strict";
  ConnectionMode2["Loose"] = "loose";
})(ConnectionMode || (ConnectionMode = {}));
var PanOnScrollMode;
(function(PanOnScrollMode2) {
  PanOnScrollMode2["Free"] = "free";
  PanOnScrollMode2["Vertical"] = "vertical";
  PanOnScrollMode2["Horizontal"] = "horizontal";
})(PanOnScrollMode || (PanOnScrollMode = {}));
var SelectionMode;
(function(SelectionMode2) {
  SelectionMode2["Partial"] = "partial";
  SelectionMode2["Full"] = "full";
})(SelectionMode || (SelectionMode = {}));
var initialConnection = {
  inProgress: false,
  isValid: null,
  from: null,
  fromHandle: null,
  fromPosition: null,
  fromNode: null,
  to: null,
  toHandle: null,
  toPosition: null,
  toNode: null
};
var ConnectionLineType;
(function(ConnectionLineType2) {
  ConnectionLineType2["Bezier"] = "default";
  ConnectionLineType2["Straight"] = "straight";
  ConnectionLineType2["Step"] = "step";
  ConnectionLineType2["SmoothStep"] = "smoothstep";
  ConnectionLineType2["SimpleBezier"] = "simplebezier";
})(ConnectionLineType || (ConnectionLineType = {}));
var MarkerType;
(function(MarkerType2) {
  MarkerType2["Arrow"] = "arrow";
  MarkerType2["ArrowClosed"] = "arrowclosed";
})(MarkerType || (MarkerType = {}));
var Position;
(function(Position2) {
  Position2["Left"] = "left";
  Position2["Top"] = "top";
  Position2["Right"] = "right";
  Position2["Bottom"] = "bottom";
})(Position || (Position = {}));
var oppositePosition = {
  [Position.Left]: Position.Right,
  [Position.Right]: Position.Left,
  [Position.Top]: Position.Bottom,
  [Position.Bottom]: Position.Top
};
function areConnectionMapsEqual(a, b) {
  if (!a && !b) {
    return true;
  }
  if (!a || !b || a.size !== b.size) {
    return false;
  }
  if (!a.size && !b.size) {
    return true;
  }
  for (const key2 of a.keys()) {
    if (!b.has(key2)) {
      return false;
    }
  }
  return true;
}
function handleConnectionChange(a, b, cb) {
  if (!cb) {
    return;
  }
  const diff = [];
  a.forEach((connection, key2) => {
    if (!(b == null ? void 0 : b.has(key2))) {
      diff.push(connection);
    }
  });
  if (diff.length) {
    cb(diff);
  }
}
function getConnectionStatus(isValid) {
  return isValid === null ? null : isValid ? "valid" : "invalid";
}
var isEdgeBase = (element2) => "id" in element2 && "source" in element2 && "target" in element2;
var isNodeBase = (element2) => "id" in element2 && "position" in element2 && !("source" in element2) && !("target" in element2);
var isInternalNodeBase = (element2) => "id" in element2 && "internals" in element2 && !("source" in element2) && !("target" in element2);
var getOutgoers = (node, nodes, edges) => {
  if (!node.id) {
    return [];
  }
  const outgoerIds = /* @__PURE__ */ new Set();
  edges.forEach((edge) => {
    if (edge.source === node.id) {
      outgoerIds.add(edge.target);
    }
  });
  return nodes.filter((n) => outgoerIds.has(n.id));
};
var getIncomers = (node, nodes, edges) => {
  if (!node.id) {
    return [];
  }
  const incomersIds = /* @__PURE__ */ new Set();
  edges.forEach((edge) => {
    if (edge.target === node.id) {
      incomersIds.add(edge.source);
    }
  });
  return nodes.filter((n) => incomersIds.has(n.id));
};
var getNodePositionWithOrigin = (node, nodeOrigin = [0, 0]) => {
  const { width, height } = getNodeDimensions(node);
  const origin = node.origin ?? nodeOrigin;
  const offsetX = width * origin[0];
  const offsetY = height * origin[1];
  return {
    x: node.position.x - offsetX,
    y: node.position.y - offsetY
  };
};
var getNodesBounds = (nodes, params = { nodeOrigin: [0, 0] }) => {
  if (nodes.length === 0) {
    return { x: 0, y: 0, width: 0, height: 0 };
  }
  const box = nodes.reduce((currBox, node) => {
    const nodeBox = nodeToBox(node, params.nodeOrigin);
    return getBoundsOfBoxes(currBox, nodeBox);
  }, { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity });
  return boxToRect(box);
};
var getInternalNodesBounds = (nodeLookup, params = {}) => {
  if (nodeLookup.size === 0) {
    return { x: 0, y: 0, width: 0, height: 0 };
  }
  let box = { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity };
  nodeLookup.forEach((node) => {
    if (params.filter === void 0 || params.filter(node)) {
      const nodeBox = nodeToBox(node);
      box = getBoundsOfBoxes(box, nodeBox);
    }
  });
  return boxToRect(box);
};
var getNodesInside = (nodes, rect, [tx, ty, tScale] = [0, 0, 1], partially = false, excludeNonSelectableNodes = false) => {
  const paneRect = {
    ...pointToRendererPoint(rect, [tx, ty, tScale]),
    width: rect.width / tScale,
    height: rect.height / tScale
  };
  const visibleNodes = [];
  for (const [, node] of nodes) {
    const { measured, selectable = true, hidden = false } = node;
    const width = measured.width ?? node.width ?? node.initialWidth ?? null;
    const height = measured.height ?? node.height ?? node.initialHeight ?? null;
    if (excludeNonSelectableNodes && !selectable || hidden) {
      continue;
    }
    const overlappingArea = getOverlappingArea(paneRect, nodeToRect(node));
    const notInitialized = width === null || height === null;
    const partiallyVisible = partially && overlappingArea > 0;
    const area = (width ?? 0) * (height ?? 0);
    const isVisible = notInitialized || partiallyVisible || overlappingArea >= area;
    if (isVisible || node.dragging) {
      visibleNodes.push(node);
    }
  }
  return visibleNodes;
};
var getConnectedEdges = (nodes, edges) => {
  const nodeIds = /* @__PURE__ */ new Set();
  nodes.forEach((node) => {
    nodeIds.add(node.id);
  });
  return edges.filter((edge) => nodeIds.has(edge.source) || nodeIds.has(edge.target));
};
function getFitViewNodes(nodeLookup, options) {
  const fitViewNodes = /* @__PURE__ */ new Map();
  const optionNodeIds = (options == null ? void 0 : options.nodes) ? new Set(options.nodes.map((node) => node.id)) : null;
  nodeLookup.forEach((n) => {
    const isVisible = n.measured.width && n.measured.height && ((options == null ? void 0 : options.includeHiddenNodes) || !n.hidden);
    if (isVisible && (!optionNodeIds || optionNodeIds.has(n.id))) {
      fitViewNodes.set(n.id, n);
    }
  });
  return fitViewNodes;
}
async function fitView({ nodes, width, height, panZoom, minZoom, maxZoom }, options) {
  if (nodes.size === 0) {
    return Promise.resolve(false);
  }
  const bounds = getInternalNodesBounds(nodes);
  const viewport = getViewportForBounds(bounds, width, height, (options == null ? void 0 : options.minZoom) ?? minZoom, (options == null ? void 0 : options.maxZoom) ?? maxZoom, (options == null ? void 0 : options.padding) ?? 0.1);
  await panZoom.setViewport(viewport, { duration: options == null ? void 0 : options.duration });
  return Promise.resolve(true);
}
function clampNodeExtent(node, extent) {
  var _a, _b;
  if (!extent || extent === "parent") {
    return extent;
  }
  return [extent[0], [extent[1][0] - (((_a = node.measured) == null ? void 0 : _a.width) ?? 0), extent[1][1] - (((_b = node.measured) == null ? void 0 : _b.height) ?? 0)]];
}
function calculateNodePosition({ nodeId, nextPosition, nodeLookup, nodeOrigin = [0, 0], nodeExtent, onError }) {
  const node = nodeLookup.get(nodeId);
  const parentNode = node.parentId ? nodeLookup.get(node.parentId) : void 0;
  const { x: parentX, y: parentY } = parentNode ? parentNode.internals.positionAbsolute : { x: 0, y: 0 };
  const origin = node.origin ?? nodeOrigin;
  let currentExtent = clampNodeExtent(node, node.extent || nodeExtent);
  if (node.extent === "parent" && !node.expandParent) {
    if (!parentNode) {
      onError == null ? void 0 : onError("005", errorMessages["error005"]());
    } else {
      const nodeWidth = node.measured.width;
      const nodeHeight = node.measured.height;
      const parentWidth = parentNode.measured.width;
      const parentHeight = parentNode.measured.height;
      if (nodeWidth && nodeHeight && parentWidth && parentHeight) {
        currentExtent = [
          [parentX, parentY],
          [parentX + parentWidth - nodeWidth, parentY + parentHeight - nodeHeight]
        ];
      }
    }
  } else if (parentNode && isCoordinateExtent(node.extent)) {
    currentExtent = [
      [node.extent[0][0] + parentX, node.extent[0][1] + parentY],
      [node.extent[1][0] + parentX, node.extent[1][1] + parentY]
    ];
  }
  const positionAbsolute = isCoordinateExtent(currentExtent) ? clampPosition(nextPosition, currentExtent) : nextPosition;
  return {
    position: {
      // TODO: is there a better way to do this?
      x: positionAbsolute.x - parentX + node.measured.width * origin[0],
      y: positionAbsolute.y - parentY + node.measured.height * origin[1]
    },
    positionAbsolute
  };
}
async function getElementsToRemove({ nodesToRemove = [], edgesToRemove = [], nodes, edges, onBeforeDelete }) {
  const nodeIds = new Set(nodesToRemove.map((node) => node.id));
  const matchingNodes = [];
  for (const node of nodes) {
    if (node.deletable === false) {
      continue;
    }
    const isIncluded = nodeIds.has(node.id);
    const parentHit = !isIncluded && node.parentId && matchingNodes.find((n) => n.id === node.parentId);
    if (isIncluded || parentHit) {
      matchingNodes.push(node);
    }
  }
  const edgeIds = new Set(edgesToRemove.map((edge) => edge.id));
  const deletableEdges = edges.filter((edge) => edge.deletable !== false);
  const connectedEdges = getConnectedEdges(matchingNodes, deletableEdges);
  const matchingEdges = connectedEdges;
  for (const edge of deletableEdges) {
    const isIncluded = edgeIds.has(edge.id);
    if (isIncluded && !matchingEdges.find((e) => e.id === edge.id)) {
      matchingEdges.push(edge);
    }
  }
  if (!onBeforeDelete) {
    return {
      edges: matchingEdges,
      nodes: matchingNodes
    };
  }
  const onBeforeDeleteResult = await onBeforeDelete({
    nodes: matchingNodes,
    edges: matchingEdges
  });
  if (typeof onBeforeDeleteResult === "boolean") {
    return onBeforeDeleteResult ? { edges: matchingEdges, nodes: matchingNodes } : { edges: [], nodes: [] };
  }
  return onBeforeDeleteResult;
}
var clamp = (val, min = 0, max = 1) => Math.min(Math.max(val, min), max);
var clampPosition = (position = { x: 0, y: 0 }, extent) => ({
  x: clamp(position.x, extent[0][0], extent[1][0]),
  y: clamp(position.y, extent[0][1], extent[1][1])
});
var calcAutoPanVelocity = (value, min, max) => {
  if (value < min) {
    return clamp(Math.abs(value - min), 1, min) / min;
  } else if (value > max) {
    return -clamp(Math.abs(value - max), 1, min) / min;
  }
  return 0;
};
var calcAutoPan = (pos, bounds, speed = 15, distance2 = 40) => {
  const xMovement = calcAutoPanVelocity(pos.x, distance2, bounds.width - distance2) * speed;
  const yMovement = calcAutoPanVelocity(pos.y, distance2, bounds.height - distance2) * speed;
  return [xMovement, yMovement];
};
var getBoundsOfBoxes = (box1, box2) => ({
  x: Math.min(box1.x, box2.x),
  y: Math.min(box1.y, box2.y),
  x2: Math.max(box1.x2, box2.x2),
  y2: Math.max(box1.y2, box2.y2)
});
var rectToBox = ({ x, y, width, height }) => ({
  x,
  y,
  x2: x + width,
  y2: y + height
});
var boxToRect = ({ x, y, x2, y2 }) => ({
  x,
  y,
  width: x2 - x,
  height: y2 - y
});
var nodeToRect = (node, nodeOrigin = [0, 0]) => {
  var _a, _b;
  const { x, y } = isInternalNodeBase(node) ? node.internals.positionAbsolute : getNodePositionWithOrigin(node, nodeOrigin);
  return {
    x,
    y,
    width: ((_a = node.measured) == null ? void 0 : _a.width) ?? node.width ?? node.initialWidth ?? 0,
    height: ((_b = node.measured) == null ? void 0 : _b.height) ?? node.height ?? node.initialHeight ?? 0
  };
};
var nodeToBox = (node, nodeOrigin = [0, 0]) => {
  var _a, _b;
  const { x, y } = isInternalNodeBase(node) ? node.internals.positionAbsolute : getNodePositionWithOrigin(node, nodeOrigin);
  return {
    x,
    y,
    x2: x + (((_a = node.measured) == null ? void 0 : _a.width) ?? node.width ?? node.initialWidth ?? 0),
    y2: y + (((_b = node.measured) == null ? void 0 : _b.height) ?? node.height ?? node.initialHeight ?? 0)
  };
};
var getBoundsOfRects = (rect1, rect2) => boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));
var getOverlappingArea = (rectA, rectB) => {
  const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));
  const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));
  return Math.ceil(xOverlap * yOverlap);
};
var isRectObject = (obj) => isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);
var isNumeric = (n) => !isNaN(n) && isFinite(n);
var devWarn = (id2, message) => {
  if (true) {
    console.warn(`[React Flow]: ${message} Help: https://reactflow.dev/error#${id2}`);
  }
};
var snapPosition = (position, snapGrid = [1, 1]) => {
  return {
    x: snapGrid[0] * Math.round(position.x / snapGrid[0]),
    y: snapGrid[1] * Math.round(position.y / snapGrid[1])
  };
};
var pointToRendererPoint = ({ x, y }, [tx, ty, tScale], snapToGrid = false, snapGrid = [1, 1]) => {
  const position = {
    x: (x - tx) / tScale,
    y: (y - ty) / tScale
  };
  return snapToGrid ? snapPosition(position, snapGrid) : position;
};
var rendererPointToPoint = ({ x, y }, [tx, ty, tScale]) => {
  return {
    x: x * tScale + tx,
    y: y * tScale + ty
  };
};
var getViewportForBounds = (bounds, width, height, minZoom, maxZoom, padding) => {
  const xZoom = width / (bounds.width * (1 + padding));
  const yZoom = height / (bounds.height * (1 + padding));
  const zoom2 = Math.min(xZoom, yZoom);
  const clampedZoom = clamp(zoom2, minZoom, maxZoom);
  const boundsCenterX = bounds.x + bounds.width / 2;
  const boundsCenterY = bounds.y + bounds.height / 2;
  const x = width / 2 - boundsCenterX * clampedZoom;
  const y = height / 2 - boundsCenterY * clampedZoom;
  return { x, y, zoom: clampedZoom };
};
var isMacOs = () => {
  var _a;
  return typeof navigator !== "undefined" && ((_a = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : _a.indexOf("Mac")) >= 0;
};
function isCoordinateExtent(extent) {
  return extent !== void 0 && extent !== "parent";
}
function getNodeDimensions(node) {
  var _a, _b;
  return {
    width: ((_a = node.measured) == null ? void 0 : _a.width) ?? node.width ?? node.initialWidth ?? 0,
    height: ((_b = node.measured) == null ? void 0 : _b.height) ?? node.height ?? node.initialHeight ?? 0
  };
}
function nodeHasDimensions(node) {
  var _a, _b;
  return (((_a = node.measured) == null ? void 0 : _a.width) ?? node.width ?? node.initialWidth) !== void 0 && (((_b = node.measured) == null ? void 0 : _b.height) ?? node.height ?? node.initialHeight) !== void 0;
}
function getPointerPosition(event, { snapGrid = [0, 0], snapToGrid = false, transform: transform2 }) {
  const { x, y } = getEventPosition(event);
  const pointerPos = pointToRendererPoint({ x, y }, transform2);
  const { x: xSnapped, y: ySnapped } = snapToGrid ? snapPosition(pointerPos, snapGrid) : pointerPos;
  return {
    xSnapped,
    ySnapped,
    ...pointerPos
  };
}
var getDimensions = (node) => ({
  width: node.offsetWidth,
  height: node.offsetHeight
});
var getHostForElement = (element2) => {
  var _a;
  return ((_a = element2.getRootNode) == null ? void 0 : _a.call(element2)) || (window == null ? void 0 : window.document);
};
var inputTags = ["INPUT", "SELECT", "TEXTAREA"];
function isInputDOMNode(event) {
  var _a, _b;
  const target = ((_b = (_a = event.composedPath) == null ? void 0 : _a.call(event)) == null ? void 0 : _b[0]) || event.target;
  const isInput = inputTags.includes(target == null ? void 0 : target.nodeName) || (target == null ? void 0 : target.hasAttribute("contenteditable"));
  return isInput || !!(target == null ? void 0 : target.closest(".nokey"));
}
var isMouseEvent = (event) => "clientX" in event;
var getEventPosition = (event, bounds) => {
  var _a, _b;
  const isMouse = isMouseEvent(event);
  const evtX = isMouse ? event.clientX : (_a = event.touches) == null ? void 0 : _a[0].clientX;
  const evtY = isMouse ? event.clientY : (_b = event.touches) == null ? void 0 : _b[0].clientY;
  return {
    x: evtX - ((bounds == null ? void 0 : bounds.left) ?? 0),
    y: evtY - ((bounds == null ? void 0 : bounds.top) ?? 0)
  };
};
var getHandleBounds = (type, nodeElement, nodeBounds, zoom2, nodeId) => {
  const handles = nodeElement.querySelectorAll(`.${type}`);
  if (!handles || !handles.length) {
    return null;
  }
  return Array.from(handles).map((handle) => {
    const handleBounds = handle.getBoundingClientRect();
    return {
      id: handle.getAttribute("data-handleid"),
      type,
      nodeId,
      position: handle.getAttribute("data-handlepos"),
      x: (handleBounds.left - nodeBounds.left) / zoom2,
      y: (handleBounds.top - nodeBounds.top) / zoom2,
      ...getDimensions(handle)
    };
  });
};
function getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY }) {
  const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;
  const centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;
  const offsetX = Math.abs(centerX - sourceX);
  const offsetY = Math.abs(centerY - sourceY);
  return [centerX, centerY, offsetX, offsetY];
}
function calculateControlOffset(distance2, curvature) {
  if (distance2 >= 0) {
    return 0.5 * distance2;
  }
  return curvature * 25 * Math.sqrt(-distance2);
}
function getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {
  switch (pos) {
    case Position.Left:
      return [x1 - calculateControlOffset(x1 - x2, c), y1];
    case Position.Right:
      return [x1 + calculateControlOffset(x2 - x1, c), y1];
    case Position.Top:
      return [x1, y1 - calculateControlOffset(y1 - y2, c)];
    case Position.Bottom:
      return [x1, y1 + calculateControlOffset(y2 - y1, c)];
  }
}
function getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25 }) {
  const [sourceControlX, sourceControlY] = getControlWithCurvature({
    pos: sourcePosition,
    x1: sourceX,
    y1: sourceY,
    x2: targetX,
    y2: targetY,
    c: curvature
  });
  const [targetControlX, targetControlY] = getControlWithCurvature({
    pos: targetPosition,
    x1: targetX,
    y1: targetY,
    x2: sourceX,
    y2: sourceY,
    c: curvature
  });
  const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourceControlX,
    sourceControlY,
    targetControlX,
    targetControlY
  });
  return [
    `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,
    labelX,
    labelY,
    offsetX,
    offsetY
  ];
}
function getEdgeCenter({ sourceX, sourceY, targetX, targetY }) {
  const xOffset = Math.abs(targetX - sourceX) / 2;
  const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;
  const yOffset = Math.abs(targetY - sourceY) / 2;
  const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;
  return [centerX, centerY, xOffset, yOffset];
}
function getElevatedEdgeZIndex({ sourceNode, targetNode, selected = false, zIndex = 0, elevateOnSelect = false }) {
  if (!elevateOnSelect) {
    return zIndex;
  }
  const edgeOrConnectedNodeSelected = selected || targetNode.selected || sourceNode.selected;
  const selectedZIndex = Math.max(sourceNode.internals.z || 0, targetNode.internals.z || 0, 1e3);
  return zIndex + (edgeOrConnectedNodeSelected ? selectedZIndex : 0);
}
function isEdgeVisible({ sourceNode, targetNode, width, height, transform: transform2 }) {
  const edgeBox = getBoundsOfBoxes(nodeToBox(sourceNode), nodeToBox(targetNode));
  if (edgeBox.x === edgeBox.x2) {
    edgeBox.x2 += 1;
  }
  if (edgeBox.y === edgeBox.y2) {
    edgeBox.y2 += 1;
  }
  const viewRect = {
    x: -transform2[0] / transform2[2],
    y: -transform2[1] / transform2[2],
    width: width / transform2[2],
    height: height / transform2[2]
  };
  return getOverlappingArea(viewRect, boxToRect(edgeBox)) > 0;
}
var getEdgeId = ({ source, sourceHandle, target, targetHandle }) => `xy-edge__${source}${sourceHandle || ""}-${target}${targetHandle || ""}`;
var connectionExists = (edge, edges) => {
  return edges.some((el) => el.source === edge.source && el.target === edge.target && (el.sourceHandle === edge.sourceHandle || !el.sourceHandle && !edge.sourceHandle) && (el.targetHandle === edge.targetHandle || !el.targetHandle && !edge.targetHandle));
};
var addEdge = (edgeParams, edges) => {
  if (!edgeParams.source || !edgeParams.target) {
    devWarn("006", errorMessages["error006"]());
    return edges;
  }
  let edge;
  if (isEdgeBase(edgeParams)) {
    edge = { ...edgeParams };
  } else {
    edge = {
      ...edgeParams,
      id: getEdgeId(edgeParams)
    };
  }
  if (connectionExists(edge, edges)) {
    return edges;
  }
  if (edge.sourceHandle === null) {
    delete edge.sourceHandle;
  }
  if (edge.targetHandle === null) {
    delete edge.targetHandle;
  }
  return edges.concat(edge);
};
function getStraightPath({ sourceX, sourceY, targetX, targetY }) {
  const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY
  });
  return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];
}
var handleDirections = {
  [Position.Left]: { x: -1, y: 0 },
  [Position.Right]: { x: 1, y: 0 },
  [Position.Top]: { x: 0, y: -1 },
  [Position.Bottom]: { x: 0, y: 1 }
};
var getDirection = ({ source, sourcePosition = Position.Bottom, target }) => {
  if (sourcePosition === Position.Left || sourcePosition === Position.Right) {
    return source.x < target.x ? { x: 1, y: 0 } : { x: -1, y: 0 };
  }
  return source.y < target.y ? { x: 0, y: 1 } : { x: 0, y: -1 };
};
var distance = (a, b) => Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
function getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset }) {
  const sourceDir = handleDirections[sourcePosition];
  const targetDir = handleDirections[targetPosition];
  const sourceGapped = { x: source.x + sourceDir.x * offset, y: source.y + sourceDir.y * offset };
  const targetGapped = { x: target.x + targetDir.x * offset, y: target.y + targetDir.y * offset };
  const dir = getDirection({
    source: sourceGapped,
    sourcePosition,
    target: targetGapped
  });
  const dirAccessor = dir.x !== 0 ? "x" : "y";
  const currDir = dir[dirAccessor];
  let points = [];
  let centerX, centerY;
  const sourceGapOffset = { x: 0, y: 0 };
  const targetGapOffset = { x: 0, y: 0 };
  const [defaultCenterX, defaultCenterY, defaultOffsetX, defaultOffsetY] = getEdgeCenter({
    sourceX: source.x,
    sourceY: source.y,
    targetX: target.x,
    targetY: target.y
  });
  if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {
    centerX = center.x ?? defaultCenterX;
    centerY = center.y ?? defaultCenterY;
    const verticalSplit = [
      { x: centerX, y: sourceGapped.y },
      { x: centerX, y: targetGapped.y }
    ];
    const horizontalSplit = [
      { x: sourceGapped.x, y: centerY },
      { x: targetGapped.x, y: centerY }
    ];
    if (sourceDir[dirAccessor] === currDir) {
      points = dirAccessor === "x" ? verticalSplit : horizontalSplit;
    } else {
      points = dirAccessor === "x" ? horizontalSplit : verticalSplit;
    }
  } else {
    const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }];
    const targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];
    if (dirAccessor === "x") {
      points = sourceDir.x === currDir ? targetSource : sourceTarget;
    } else {
      points = sourceDir.y === currDir ? sourceTarget : targetSource;
    }
    if (sourcePosition === targetPosition) {
      const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);
      if (diff <= offset) {
        const gapOffset = Math.min(offset - 1, offset - diff);
        if (sourceDir[dirAccessor] === currDir) {
          sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset;
        } else {
          targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;
        }
      }
    }
    if (sourcePosition !== targetPosition) {
      const dirAccessorOpposite = dirAccessor === "x" ? "y" : "x";
      const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];
      const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];
      const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];
      const flipSourceTarget = sourceDir[dirAccessor] === 1 && (!isSameDir && sourceGtTargetOppo || isSameDir && sourceLtTargetOppo) || sourceDir[dirAccessor] !== 1 && (!isSameDir && sourceLtTargetOppo || isSameDir && sourceGtTargetOppo);
      if (flipSourceTarget) {
        points = dirAccessor === "x" ? sourceTarget : targetSource;
      }
    }
    const sourceGapPoint = { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y };
    const targetGapPoint = { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y };
    const maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));
    const maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));
    if (maxXDistance >= maxYDistance) {
      centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;
      centerY = points[0].y;
    } else {
      centerX = points[0].x;
      centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;
    }
  }
  const pathPoints = [
    source,
    { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y },
    ...points,
    { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y },
    target
  ];
  return [pathPoints, centerX, centerY, defaultOffsetX, defaultOffsetY];
}
function getBend(a, b, c, size) {
  const bendSize = Math.min(distance(a, b) / 2, distance(b, c) / 2, size);
  const { x, y } = b;
  if (a.x === x && x === c.x || a.y === y && y === c.y) {
    return `L${x} ${y}`;
  }
  if (a.y === y) {
    const xDir2 = a.x < c.x ? -1 : 1;
    const yDir2 = a.y < c.y ? 1 : -1;
    return `L ${x + bendSize * xDir2},${y}Q ${x},${y} ${x},${y + bendSize * yDir2}`;
  }
  const xDir = a.x < c.x ? 1 : -1;
  const yDir = a.y < c.y ? -1 : 1;
  return `L ${x},${y + bendSize * yDir}Q ${x},${y} ${x + bendSize * xDir},${y}`;
}
function getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY, offset = 20 }) {
  const [points, labelX, labelY, offsetX, offsetY] = getPoints({
    source: { x: sourceX, y: sourceY },
    sourcePosition,
    target: { x: targetX, y: targetY },
    targetPosition,
    center: { x: centerX, y: centerY },
    offset
  });
  const path = points.reduce((res, p, i) => {
    let segment = "";
    if (i > 0 && i < points.length - 1) {
      segment = getBend(points[i - 1], p, points[i + 1], borderRadius);
    } else {
      segment = `${i === 0 ? "M" : "L"}${p.x} ${p.y}`;
    }
    res += segment;
    return res;
  }, "");
  return [path, labelX, labelY, offsetX, offsetY];
}
function isNodeInitialized(node) {
  var _a;
  return node && !!(node.internals.handleBounds || ((_a = node.handles) == null ? void 0 : _a.length)) && !!(node.measured.width || node.width || node.initialWidth);
}
function getEdgePosition(params) {
  var _a;
  const { sourceNode, targetNode } = params;
  if (!isNodeInitialized(sourceNode) || !isNodeInitialized(targetNode)) {
    return null;
  }
  const sourceHandleBounds = sourceNode.internals.handleBounds || toHandleBounds(sourceNode.handles);
  const targetHandleBounds = targetNode.internals.handleBounds || toHandleBounds(targetNode.handles);
  const sourceHandle = getHandle((sourceHandleBounds == null ? void 0 : sourceHandleBounds.source) ?? [], params.sourceHandle);
  const targetHandle = getHandle(
    // when connection type is loose we can define all handles as sources and connect source -> source
    params.connectionMode === ConnectionMode.Strict ? (targetHandleBounds == null ? void 0 : targetHandleBounds.target) ?? [] : ((targetHandleBounds == null ? void 0 : targetHandleBounds.target) ?? []).concat((targetHandleBounds == null ? void 0 : targetHandleBounds.source) ?? []),
    params.targetHandle
  );
  if (!sourceHandle || !targetHandle) {
    (_a = params.onError) == null ? void 0 : _a.call(params, "008", errorMessages["error008"](!sourceHandle ? "source" : "target", {
      id: params.id,
      sourceHandle: params.sourceHandle,
      targetHandle: params.targetHandle
    }));
    return null;
  }
  const sourcePosition = (sourceHandle == null ? void 0 : sourceHandle.position) || Position.Bottom;
  const targetPosition = (targetHandle == null ? void 0 : targetHandle.position) || Position.Top;
  const source = getHandlePosition(sourceNode, sourceHandle, sourcePosition);
  const target = getHandlePosition(targetNode, targetHandle, targetPosition);
  return {
    sourceX: source.x,
    sourceY: source.y,
    targetX: target.x,
    targetY: target.y,
    sourcePosition,
    targetPosition
  };
}
function toHandleBounds(handles) {
  if (!handles) {
    return null;
  }
  const source = [];
  const target = [];
  for (const handle of handles) {
    handle.width = handle.width ?? 1;
    handle.height = handle.height ?? 1;
    if (handle.type === "source") {
      source.push(handle);
    } else if (handle.type === "target") {
      target.push(handle);
    }
  }
  return {
    source,
    target
  };
}
function getHandlePosition(node, handle, fallbackPosition = Position.Left, center = false) {
  const x = ((handle == null ? void 0 : handle.x) ?? 0) + node.internals.positionAbsolute.x;
  const y = ((handle == null ? void 0 : handle.y) ?? 0) + node.internals.positionAbsolute.y;
  const { width, height } = handle ?? getNodeDimensions(node);
  if (center) {
    return { x: x + width / 2, y: y + height / 2 };
  }
  const position = (handle == null ? void 0 : handle.position) ?? fallbackPosition;
  switch (position) {
    case Position.Top:
      return { x: x + width / 2, y };
    case Position.Right:
      return { x: x + width, y: y + height / 2 };
    case Position.Bottom:
      return { x: x + width / 2, y: y + height };
    case Position.Left:
      return { x, y: y + height / 2 };
  }
}
function getHandle(bounds, handleId) {
  if (!bounds) {
    return null;
  }
  return (!handleId ? bounds[0] : bounds.find((d) => d.id === handleId)) || null;
}
function getMarkerId(marker, id2) {
  if (!marker) {
    return "";
  }
  if (typeof marker === "string") {
    return marker;
  }
  const idPrefix = id2 ? `${id2}__` : "";
  return `${idPrefix}${Object.keys(marker).sort().map((key2) => `${key2}=${marker[key2]}`).join("&")}`;
}
function createMarkerIds(edges, { id: id2, defaultColor, defaultMarkerStart, defaultMarkerEnd }) {
  const ids = /* @__PURE__ */ new Set();
  return edges.reduce((markers, edge) => {
    [edge.markerStart || defaultMarkerStart, edge.markerEnd || defaultMarkerEnd].forEach((marker) => {
      if (marker && typeof marker === "object") {
        const markerId = getMarkerId(marker, id2);
        if (!ids.has(markerId)) {
          markers.push({ id: markerId, color: marker.color || defaultColor, ...marker });
          ids.add(markerId);
        }
      }
    });
    return markers;
  }, []).sort((a, b) => a.id.localeCompare(b.id));
}
function getNodeToolbarTransform(nodeRect, viewport, position, offset, align) {
  let alignmentOffset = 0.5;
  if (align === "start") {
    alignmentOffset = 0;
  } else if (align === "end") {
    alignmentOffset = 1;
  }
  let pos = [
    (nodeRect.x + nodeRect.width * alignmentOffset) * viewport.zoom + viewport.x,
    nodeRect.y * viewport.zoom + viewport.y - offset
  ];
  let shift = [-100 * alignmentOffset, -100];
  switch (position) {
    case Position.Right:
      pos = [
        (nodeRect.x + nodeRect.width) * viewport.zoom + viewport.x + offset,
        (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y
      ];
      shift = [0, -100 * alignmentOffset];
      break;
    case Position.Bottom:
      pos[1] = (nodeRect.y + nodeRect.height) * viewport.zoom + viewport.y + offset;
      shift[1] = 0;
      break;
    case Position.Left:
      pos = [
        nodeRect.x * viewport.zoom + viewport.x - offset,
        (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y
      ];
      shift = [-100, -100 * alignmentOffset];
      break;
  }
  return `translate(${pos[0]}px, ${pos[1]}px) translate(${shift[0]}%, ${shift[1]}%)`;
}
var defaultOptions = {
  nodeOrigin: [0, 0],
  elevateNodesOnSelect: true,
  defaults: {}
};
var adoptUserNodesDefaultOptions = {
  ...defaultOptions,
  checkEquality: true
};
function adoptUserNodes(nodes, nodeLookup, parentLookup, options) {
  var _a, _b;
  const _options = { ...adoptUserNodesDefaultOptions, ...options };
  const tmpLookup = new Map(nodeLookup);
  nodeLookup.clear();
  parentLookup.clear();
  const selectedNodeZ = (options == null ? void 0 : options.elevateNodesOnSelect) ? 1e3 : 0;
  for (const userNode of nodes) {
    let internalNode = tmpLookup.get(userNode.id);
    if (_options.checkEquality && userNode === (internalNode == null ? void 0 : internalNode.internals.userNode)) {
      nodeLookup.set(userNode.id, internalNode);
    } else {
      internalNode = {
        ..._options.defaults,
        ...userNode,
        measured: {
          width: (_a = userNode.measured) == null ? void 0 : _a.width,
          height: (_b = userNode.measured) == null ? void 0 : _b.height
        },
        internals: {
          positionAbsolute: getNodePositionWithOrigin(userNode, _options.nodeOrigin),
          handleBounds: internalNode == null ? void 0 : internalNode.internals.handleBounds,
          z: calculateZ(userNode, selectedNodeZ),
          userNode
        }
      };
      nodeLookup.set(userNode.id, internalNode);
    }
    if (userNode.parentId) {
      updateChildPosition(internalNode, nodeLookup, parentLookup, options);
    }
  }
}
function updateChildPosition(node, nodeLookup, parentLookup, options) {
  const _options = { ...defaultOptions, ...options };
  const parentId = node.parentId;
  const parentNode = nodeLookup.get(parentId);
  if (!parentNode) {
    throw new Error(`Parent node ${parentId} not found`);
  }
  const childNodes = parentLookup.get(parentId);
  if (childNodes) {
    childNodes.set(node.id, node);
  } else {
    parentLookup.set(parentId, /* @__PURE__ */ new Map([[node.id, node]]));
  }
  const selectedNodeZ = (options == null ? void 0 : options.elevateNodesOnSelect) ? 1e3 : 0;
  const { x, y, z } = calculateChildXYZ(node, parentNode, _options.nodeOrigin, selectedNodeZ);
  const currPosition = node.internals.positionAbsolute;
  const positionChanged = x !== currPosition.x || y !== currPosition.y;
  if (positionChanged || z !== node.internals.z) {
    node.internals = {
      ...node.internals,
      positionAbsolute: positionChanged ? { x, y } : currPosition,
      z
    };
  }
}
function calculateZ(node, selectedNodeZ) {
  return (isNumeric(node.zIndex) ? node.zIndex : 0) + (node.selected ? selectedNodeZ : 0);
}
function calculateChildXYZ(childNode, parentNode, nodeOrigin, selectedNodeZ) {
  const position = getNodePositionWithOrigin(childNode, nodeOrigin);
  const childZ = calculateZ(childNode, selectedNodeZ);
  const parentZ = parentNode.internals.z ?? 0;
  return {
    x: parentNode.internals.positionAbsolute.x + position.x,
    y: parentNode.internals.positionAbsolute.y + position.y,
    z: parentZ > childZ ? parentZ : childZ
  };
}
function handleExpandParent(children2, nodeLookup, parentLookup, nodeOrigin = [0, 0]) {
  var _a;
  const changes = [];
  const parentExpansions = /* @__PURE__ */ new Map();
  for (const child of children2) {
    const parent = nodeLookup.get(child.parentId);
    if (!parent) {
      continue;
    }
    const parentRect = ((_a = parentExpansions.get(child.parentId)) == null ? void 0 : _a.expandedRect) ?? nodeToRect(parent);
    const expandedRect = getBoundsOfRects(parentRect, child.rect);
    parentExpansions.set(child.parentId, { expandedRect, parent });
  }
  if (parentExpansions.size > 0) {
    parentExpansions.forEach(({ expandedRect, parent }, parentId) => {
      var _a2;
      const positionAbsolute = parent.internals.positionAbsolute;
      const dimensions = getNodeDimensions(parent);
      const origin = parent.origin ?? nodeOrigin;
      const xChange = expandedRect.x < positionAbsolute.x ? Math.round(Math.abs(positionAbsolute.x - expandedRect.x)) : 0;
      const yChange = expandedRect.y < positionAbsolute.y ? Math.round(Math.abs(positionAbsolute.y - expandedRect.y)) : 0;
      const newWidth = Math.max(dimensions.width, Math.round(expandedRect.width));
      const newHeight = Math.max(dimensions.height, Math.round(expandedRect.height));
      const widthChange = (newWidth - dimensions.width) * origin[0];
      const heightChange = (newHeight - dimensions.height) * origin[1];
      if (xChange > 0 || yChange > 0 || widthChange || heightChange) {
        changes.push({
          id: parentId,
          type: "position",
          position: {
            x: parent.position.x - xChange + widthChange,
            y: parent.position.y - yChange + heightChange
          }
        });
        (_a2 = parentLookup.get(parentId)) == null ? void 0 : _a2.forEach((childNode) => {
          if (!children2.some((child) => child.id === childNode.id)) {
            changes.push({
              id: childNode.id,
              type: "position",
              position: {
                x: childNode.position.x + xChange,
                y: childNode.position.y + yChange
              }
            });
          }
        });
      }
      if (dimensions.width < expandedRect.width || dimensions.height < expandedRect.height || xChange || yChange) {
        changes.push({
          id: parentId,
          type: "dimensions",
          setAttributes: true,
          dimensions: {
            width: newWidth + (xChange ? origin[0] * xChange - widthChange : 0),
            height: newHeight + (yChange ? origin[1] * yChange - heightChange : 0)
          }
        });
      }
    });
  }
  return changes;
}
function updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin) {
  const viewportNode = domNode == null ? void 0 : domNode.querySelector(".xyflow__viewport");
  let updatedInternals = false;
  if (!viewportNode) {
    return { changes: [], updatedInternals };
  }
  const changes = [];
  const style = window.getComputedStyle(viewportNode);
  const { m22: zoom2 } = new window.DOMMatrixReadOnly(style.transform);
  const parentExpandChildren = [];
  for (const update of updates.values()) {
    const node = nodeLookup.get(update.id);
    if (!node) {
      continue;
    }
    if (node.hidden) {
      node.internals = {
        ...node.internals,
        handleBounds: void 0
      };
      updatedInternals = true;
    } else {
      const dimensions = getDimensions(update.nodeElement);
      const dimensionChanged = node.measured.width !== dimensions.width || node.measured.height !== dimensions.height;
      const doUpdate = !!(dimensions.width && dimensions.height && (dimensionChanged || !node.internals.handleBounds || update.force));
      if (doUpdate) {
        const nodeBounds = update.nodeElement.getBoundingClientRect();
        node.measured = dimensions;
        node.internals = {
          ...node.internals,
          positionAbsolute: getNodePositionWithOrigin(node, nodeOrigin),
          handleBounds: {
            source: getHandleBounds("source", update.nodeElement, nodeBounds, zoom2, node.id),
            target: getHandleBounds("target", update.nodeElement, nodeBounds, zoom2, node.id)
          }
        };
        if (node.parentId) {
          updateChildPosition(node, nodeLookup, parentLookup, { nodeOrigin });
        }
        updatedInternals = true;
        if (dimensionChanged) {
          changes.push({
            id: node.id,
            type: "dimensions",
            dimensions
          });
          if (node.expandParent && node.parentId) {
            parentExpandChildren.push({
              id: node.id,
              parentId: node.parentId,
              rect: nodeToRect(node, nodeOrigin)
            });
          }
        }
      }
    }
  }
  if (parentExpandChildren.length > 0) {
    const parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);
    changes.push(...parentExpandChanges);
  }
  return { changes, updatedInternals };
}
async function panBy({ delta, panZoom, transform: transform2, translateExtent, width, height }) {
  if (!panZoom || !delta.x && !delta.y) {
    return Promise.resolve(false);
  }
  const nextViewport = await panZoom.setViewportConstrained({
    x: transform2[0] + delta.x,
    y: transform2[1] + delta.y,
    zoom: transform2[2]
  }, [
    [0, 0],
    [width, height]
  ], translateExtent);
  const transformChanged = !!nextViewport && (nextViewport.x !== transform2[0] || nextViewport.y !== transform2[1] || nextViewport.k !== transform2[2]);
  return Promise.resolve(transformChanged);
}
function updateConnectionLookup(connectionLookup, edgeLookup, edges) {
  connectionLookup.clear();
  edgeLookup.clear();
  for (const edge of edges) {
    const { source, target, sourceHandle = null, targetHandle = null } = edge;
    const sourceKey = `${source}-source-${sourceHandle}`;
    const targetKey = `${target}-target-${targetHandle}`;
    const prevSource = connectionLookup.get(sourceKey) || /* @__PURE__ */ new Map();
    const prevTarget = connectionLookup.get(targetKey) || /* @__PURE__ */ new Map();
    const connection = { edgeId: edge.id, source, target, sourceHandle, targetHandle };
    edgeLookup.set(edge.id, edge);
    connectionLookup.set(sourceKey, prevSource.set(`${target}-${targetHandle}`, connection));
    connectionLookup.set(targetKey, prevTarget.set(`${source}-${sourceHandle}`, connection));
  }
}
function shallowNodeData(a, b) {
  if (a === null || b === null) {
    return false;
  }
  const _a = Array.isArray(a) ? a : [a];
  const _b = Array.isArray(b) ? b : [b];
  if (_a.length !== _b.length) {
    return false;
  }
  for (let i = 0; i < _a.length; i++) {
    if (_a[i].id !== _b[i].id || _a[i].type !== _b[i].type || !Object.is(_a[i].data, _b[i].data)) {
      return false;
    }
  }
  return true;
}
function isParentSelected(node, nodeLookup) {
  if (!node.parentId) {
    return false;
  }
  const parentNode = nodeLookup.get(node.parentId);
  if (!parentNode) {
    return false;
  }
  if (parentNode.selected) {
    return true;
  }
  return isParentSelected(parentNode, nodeLookup);
}
function hasSelector(target, selector, domNode) {
  let current = target;
  do {
    if (current == null ? void 0 : current.matches(selector))
      return true;
    if (current === domNode)
      return false;
    current = current.parentElement;
  } while (current);
  return false;
}
function getDragItems(nodeLookup, nodesDraggable, mousePos, nodeId) {
  const dragItems = /* @__PURE__ */ new Map();
  for (const [id2, node] of nodeLookup) {
    if ((node.selected || node.id === nodeId) && (!node.parentId || !isParentSelected(node, nodeLookup)) && (node.draggable || nodesDraggable && typeof node.draggable === "undefined")) {
      const internalNode = nodeLookup.get(id2);
      if (internalNode) {
        dragItems.set(id2, {
          id: id2,
          position: internalNode.position || { x: 0, y: 0 },
          distance: {
            x: mousePos.x - internalNode.internals.positionAbsolute.x,
            y: mousePos.y - internalNode.internals.positionAbsolute.y
          },
          extent: internalNode.extent,
          parentId: internalNode.parentId,
          origin: internalNode.origin,
          expandParent: internalNode.expandParent,
          internals: {
            positionAbsolute: internalNode.internals.positionAbsolute || { x: 0, y: 0 }
          },
          measured: {
            width: internalNode.measured.width ?? 0,
            height: internalNode.measured.height ?? 0
          }
        });
      }
    }
  }
  return dragItems;
}
function getEventHandlerParams({ nodeId, dragItems, nodeLookup, dragging = true }) {
  var _a, _b;
  const nodesFromDragItems = [];
  for (const [id2, dragItem] of dragItems) {
    const node2 = (_a = nodeLookup.get(id2)) == null ? void 0 : _a.internals.userNode;
    if (node2) {
      nodesFromDragItems.push({
        ...node2,
        position: dragItem.position,
        dragging
      });
    }
  }
  if (!nodeId) {
    return [nodesFromDragItems[0], nodesFromDragItems];
  }
  const node = nodeLookup.get(nodeId).internals.userNode;
  return [
    {
      ...node,
      position: ((_b = dragItems.get(nodeId)) == null ? void 0 : _b.position) || node.position,
      dragging
    },
    nodesFromDragItems
  ];
}
function XYDrag({ onNodeMouseDown, getStoreItems, onDragStart, onDrag, onDragStop }) {
  let lastPos = { x: null, y: null };
  let autoPanId = 0;
  let dragItems = /* @__PURE__ */ new Map();
  let autoPanStarted = false;
  let mousePosition = { x: 0, y: 0 };
  let containerBounds = null;
  let dragStarted = false;
  let d3Selection = null;
  let abortDrag = false;
  function update({ noDragClassName, handleSelector, domNode, isSelectable, nodeId, nodeClickDistance = 0 }) {
    d3Selection = select_default2(domNode);
    function updateNodes({ x, y }, dragEvent) {
      const { nodeLookup, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onNodeDrag, onSelectionDrag, onError, updateNodePositions } = getStoreItems();
      lastPos = { x, y };
      let hasChange = false;
      let nodesBox = { x: 0, y: 0, x2: 0, y2: 0 };
      if (dragItems.size > 1 && nodeExtent) {
        const rect = getInternalNodesBounds(dragItems);
        nodesBox = rectToBox(rect);
      }
      for (const [id2, dragItem] of dragItems) {
        let nextPosition = { x: x - dragItem.distance.x, y: y - dragItem.distance.y };
        if (snapToGrid) {
          nextPosition = snapPosition(nextPosition, snapGrid);
        }
        let adjustedNodeExtent = [
          [nodeExtent[0][0], nodeExtent[0][1]],
          [nodeExtent[1][0], nodeExtent[1][1]]
        ];
        if (dragItems.size > 1 && nodeExtent && !dragItem.extent) {
          const { positionAbsolute: positionAbsolute2 } = dragItem.internals;
          const x1 = positionAbsolute2.x - nodesBox.x + nodeExtent[0][0];
          const x2 = positionAbsolute2.x + dragItem.measured.width - nodesBox.x2 + nodeExtent[1][0];
          const y1 = positionAbsolute2.y - nodesBox.y + nodeExtent[0][1];
          const y2 = positionAbsolute2.y + dragItem.measured.height - nodesBox.y2 + nodeExtent[1][1];
          adjustedNodeExtent = [
            [x1, y1],
            [x2, y2]
          ];
        }
        const { position, positionAbsolute } = calculateNodePosition({
          nodeId: id2,
          nextPosition,
          nodeLookup,
          nodeExtent: adjustedNodeExtent,
          nodeOrigin,
          onError
        });
        hasChange = hasChange || dragItem.position.x !== position.x || dragItem.position.y !== position.y;
        dragItem.position = position;
        dragItem.internals.positionAbsolute = positionAbsolute;
      }
      if (!hasChange) {
        return;
      }
      updateNodePositions(dragItems, true);
      if (dragEvent && (onDrag || onNodeDrag || !nodeId && onSelectionDrag)) {
        const [currentNode, currentNodes] = getEventHandlerParams({
          nodeId,
          dragItems,
          nodeLookup
        });
        onDrag == null ? void 0 : onDrag(dragEvent, dragItems, currentNode, currentNodes);
        onNodeDrag == null ? void 0 : onNodeDrag(dragEvent, currentNode, currentNodes);
        if (!nodeId) {
          onSelectionDrag == null ? void 0 : onSelectionDrag(dragEvent, currentNodes);
        }
      }
    }
    async function autoPan() {
      if (!containerBounds) {
        return;
      }
      const { transform: transform2, panBy: panBy2, autoPanSpeed } = getStoreItems();
      const [xMovement, yMovement] = calcAutoPan(mousePosition, containerBounds, autoPanSpeed);
      if (xMovement !== 0 || yMovement !== 0) {
        lastPos.x = (lastPos.x ?? 0) - xMovement / transform2[2];
        lastPos.y = (lastPos.y ?? 0) - yMovement / transform2[2];
        if (await panBy2({ x: xMovement, y: yMovement })) {
          updateNodes(lastPos, null);
        }
      }
      autoPanId = requestAnimationFrame(autoPan);
    }
    function startDrag(event) {
      var _a;
      const { nodeLookup, multiSelectionActive, nodesDraggable, transform: transform2, snapGrid, snapToGrid, selectNodesOnDrag, onNodeDragStart, onSelectionDragStart, unselectNodesAndEdges } = getStoreItems();
      dragStarted = true;
      if ((!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId) {
        if (!((_a = nodeLookup.get(nodeId)) == null ? void 0 : _a.selected)) {
          unselectNodesAndEdges();
        }
      }
      if (isSelectable && selectNodesOnDrag && nodeId) {
        onNodeMouseDown == null ? void 0 : onNodeMouseDown(nodeId);
      }
      const pointerPos = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid });
      lastPos = pointerPos;
      dragItems = getDragItems(nodeLookup, nodesDraggable, pointerPos, nodeId);
      if (dragItems.size > 0 && (onDragStart || onNodeDragStart || !nodeId && onSelectionDragStart)) {
        const [currentNode, currentNodes] = getEventHandlerParams({
          nodeId,
          dragItems,
          nodeLookup
        });
        onDragStart == null ? void 0 : onDragStart(event.sourceEvent, dragItems, currentNode, currentNodes);
        onNodeDragStart == null ? void 0 : onNodeDragStart(event.sourceEvent, currentNode, currentNodes);
        if (!nodeId) {
          onSelectionDragStart == null ? void 0 : onSelectionDragStart(event.sourceEvent, currentNodes);
        }
      }
    }
    const d3DragInstance = drag_default().clickDistance(nodeClickDistance).on("start", (event) => {
      const { domNode: domNode2, nodeDragThreshold, transform: transform2, snapGrid, snapToGrid } = getStoreItems();
      abortDrag = false;
      if (nodeDragThreshold === 0) {
        startDrag(event);
      }
      const pointerPos = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid });
      lastPos = pointerPos;
      containerBounds = (domNode2 == null ? void 0 : domNode2.getBoundingClientRect()) || null;
      mousePosition = getEventPosition(event.sourceEvent, containerBounds);
    }).on("drag", (event) => {
      const { autoPanOnNodeDrag, transform: transform2, snapGrid, snapToGrid, nodeDragThreshold } = getStoreItems();
      const pointerPos = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid });
      if (event.sourceEvent.type === "touchmove" && event.sourceEvent.touches.length > 1) {
        abortDrag = true;
      }
      if (abortDrag) {
        return;
      }
      if (!autoPanStarted && autoPanOnNodeDrag && dragStarted) {
        autoPanStarted = true;
        autoPan();
      }
      if (!dragStarted) {
        const x = pointerPos.xSnapped - (lastPos.x ?? 0);
        const y = pointerPos.ySnapped - (lastPos.y ?? 0);
        const distance2 = Math.sqrt(x * x + y * y);
        if (distance2 > nodeDragThreshold) {
          startDrag(event);
        }
      }
      if ((lastPos.x !== pointerPos.xSnapped || lastPos.y !== pointerPos.ySnapped) && dragItems && dragStarted) {
        mousePosition = getEventPosition(event.sourceEvent, containerBounds);
        updateNodes(pointerPos, event.sourceEvent);
      }
    }).on("end", (event) => {
      if (!dragStarted || abortDrag) {
        return;
      }
      autoPanStarted = false;
      dragStarted = false;
      cancelAnimationFrame(autoPanId);
      if (dragItems.size > 0) {
        const { nodeLookup, updateNodePositions, onNodeDragStop, onSelectionDragStop } = getStoreItems();
        updateNodePositions(dragItems, false);
        if (onDragStop || onNodeDragStop || !nodeId && onSelectionDragStop) {
          const [currentNode, currentNodes] = getEventHandlerParams({
            nodeId,
            dragItems,
            nodeLookup,
            dragging: false
          });
          onDragStop == null ? void 0 : onDragStop(event.sourceEvent, dragItems, currentNode, currentNodes);
          onNodeDragStop == null ? void 0 : onNodeDragStop(event.sourceEvent, currentNode, currentNodes);
          if (!nodeId) {
            onSelectionDragStop == null ? void 0 : onSelectionDragStop(event.sourceEvent, currentNodes);
          }
        }
      }
    }).filter((event) => {
      const target = event.target;
      const isDraggable = !event.button && (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, domNode)) && (!handleSelector || hasSelector(target, handleSelector, domNode));
      return isDraggable;
    });
    d3Selection.call(d3DragInstance);
  }
  function destroy() {
    d3Selection == null ? void 0 : d3Selection.on(".drag", null);
  }
  return {
    update,
    destroy
  };
}
function getHandles(node, handleBounds, type, currentHandle) {
  let excludedHandle = null;
  const handles = (handleBounds[type] || []).reduce((res, handle) => {
    if (node.id === currentHandle.nodeId && type === currentHandle.handleType && handle.id === currentHandle.handleId) {
      excludedHandle = handle;
    } else {
      const handleXY = getHandlePosition(node, handle, handle.position, true);
      res.push({ ...handle, ...handleXY });
    }
    return res;
  }, []);
  return [handles, excludedHandle];
}
function getClosestHandle(pos, connectionRadius, handles) {
  let closestHandles = [];
  let minDistance = Infinity;
  for (const handle of handles) {
    const distance2 = Math.sqrt(Math.pow(handle.x - pos.x, 2) + Math.pow(handle.y - pos.y, 2));
    if (distance2 <= connectionRadius) {
      if (distance2 < minDistance) {
        closestHandles = [handle];
      } else if (distance2 === minDistance) {
        closestHandles.push(handle);
      }
      minDistance = distance2;
    }
  }
  if (!closestHandles.length) {
    return null;
  }
  return closestHandles.length === 1 ? closestHandles[0] : (
    // if multiple handles are layouted on top of each other we take the one with type = target because it's more likely that the user wants to connect to this one
    closestHandles.find((handle) => handle.type === "target") || closestHandles[0]
  );
}
function getHandleLookup({ nodeLookup, nodeId, handleId, handleType }) {
  const connectionHandles = [];
  const currentHandle = { nodeId, handleId, handleType };
  let excludedHandle = null;
  for (const node of nodeLookup.values()) {
    if (node.internals.handleBounds) {
      const [sourceHandles, excludedSource] = getHandles(node, node.internals.handleBounds, "source", currentHandle);
      const [targetHandles, excludedTarget] = getHandles(node, node.internals.handleBounds, "target", currentHandle);
      excludedHandle = excludedHandle ? excludedHandle : excludedSource ?? excludedTarget;
      connectionHandles.push(...sourceHandles, ...targetHandles);
    }
  }
  return [connectionHandles, excludedHandle];
}
function getHandleType(edgeUpdaterType, handleDomNode) {
  if (edgeUpdaterType) {
    return edgeUpdaterType;
  } else if (handleDomNode == null ? void 0 : handleDomNode.classList.contains("target")) {
    return "target";
  } else if (handleDomNode == null ? void 0 : handleDomNode.classList.contains("source")) {
    return "source";
  }
  return null;
}
function isConnectionValid(isInsideConnectionRadius, isHandleValid) {
  let isValid = null;
  if (isHandleValid) {
    isValid = true;
  } else if (isInsideConnectionRadius && !isHandleValid) {
    isValid = false;
  }
  return isValid;
}
var alwaysValid = () => true;
function onPointerDown(event, { connectionMode, connectionRadius, handleId, nodeId, edgeUpdaterType, isTarget, domNode, nodeLookup, lib, autoPanOnConnect, flowId, panBy: panBy2, cancelConnection, onConnectStart, onConnect, onConnectEnd, isValidConnection = alwaysValid, onReconnectEnd, updateConnection, getTransform, getFromHandle, autoPanSpeed }) {
  const doc = getHostForElement(event.target);
  let autoPanId = 0;
  let closestHandle;
  const { x, y } = getEventPosition(event);
  const clickedHandle = doc == null ? void 0 : doc.elementFromPoint(x, y);
  const handleType = getHandleType(edgeUpdaterType, clickedHandle);
  const containerBounds = domNode == null ? void 0 : domNode.getBoundingClientRect();
  if (!containerBounds || !handleType) {
    return;
  }
  let position = getEventPosition(event, containerBounds);
  let autoPanStarted = false;
  let connection = null;
  let isValid = false;
  let handleDomNode = null;
  const [handleLookup, fromHandleInternal] = getHandleLookup({
    nodeLookup,
    nodeId,
    handleId,
    handleType
  });
  function autoPan() {
    if (!autoPanOnConnect || !containerBounds) {
      return;
    }
    const [x2, y2] = calcAutoPan(position, containerBounds, autoPanSpeed);
    panBy2({ x: x2, y: y2 });
    autoPanId = requestAnimationFrame(autoPan);
  }
  const fromHandle = {
    ...fromHandleInternal,
    nodeId,
    type: handleType,
    position: fromHandleInternal.position
  };
  const fromNodeInternal = nodeLookup.get(nodeId);
  const from = getHandlePosition(fromNodeInternal, fromHandle, Position.Left, true);
  const newConnection = {
    inProgress: true,
    isValid: null,
    from,
    fromHandle,
    fromPosition: fromHandle.position,
    fromNode: fromNodeInternal,
    to: position,
    toHandle: null,
    toPosition: oppositePosition[fromHandle.position],
    toNode: null
  };
  updateConnection(newConnection);
  let previousConnection = newConnection;
  onConnectStart == null ? void 0 : onConnectStart(event, { nodeId, handleId, handleType });
  function onPointerMove(event2) {
    if (!getFromHandle() || !fromHandle) {
      onPointerUp(event2);
      return;
    }
    const transform2 = getTransform();
    position = getEventPosition(event2, containerBounds);
    closestHandle = getClosestHandle(pointToRendererPoint(position, transform2, false, [1, 1]), connectionRadius, handleLookup);
    if (!autoPanStarted) {
      autoPan();
      autoPanStarted = true;
    }
    const result = isValidHandle(event2, {
      handle: closestHandle,
      connectionMode,
      fromNodeId: nodeId,
      fromHandleId: handleId,
      fromType: isTarget ? "target" : "source",
      isValidConnection,
      doc,
      lib,
      flowId,
      handleLookup
    });
    handleDomNode = result.handleDomNode;
    connection = result.connection;
    isValid = isConnectionValid(!!closestHandle, result.isValid);
    const newConnection2 = {
      // from stays the same
      ...previousConnection,
      isValid,
      to: closestHandle && isValid ? rendererPointToPoint({ x: closestHandle.x, y: closestHandle.y }, transform2) : position,
      toHandle: result.toHandle,
      toPosition: isValid && result.toHandle ? result.toHandle.position : oppositePosition[fromHandle.position],
      toNode: result.toHandle ? nodeLookup.get(result.toHandle.nodeId) : null
    };
    if (isValid && closestHandle && previousConnection.toHandle && newConnection2.toHandle && previousConnection.toHandle.type === newConnection2.toHandle.type && previousConnection.toHandle.nodeId === newConnection2.toHandle.nodeId && previousConnection.toHandle.id === newConnection2.toHandle.id) {
      return;
    }
    updateConnection(newConnection2);
    previousConnection = newConnection2;
  }
  function onPointerUp(event2) {
    if ((closestHandle || handleDomNode) && connection && isValid) {
      onConnect == null ? void 0 : onConnect(connection);
    }
    onConnectEnd == null ? void 0 : onConnectEnd(event2);
    if (edgeUpdaterType) {
      onReconnectEnd == null ? void 0 : onReconnectEnd(event2);
    }
    cancelConnection();
    cancelAnimationFrame(autoPanId);
    autoPanStarted = false;
    isValid = false;
    connection = null;
    handleDomNode = null;
    doc.removeEventListener("mousemove", onPointerMove);
    doc.removeEventListener("mouseup", onPointerUp);
    doc.removeEventListener("touchmove", onPointerMove);
    doc.removeEventListener("touchend", onPointerUp);
  }
  doc.addEventListener("mousemove", onPointerMove);
  doc.addEventListener("mouseup", onPointerUp);
  doc.addEventListener("touchmove", onPointerMove);
  doc.addEventListener("touchend", onPointerUp);
}
function isValidHandle(event, { handle, connectionMode, fromNodeId, fromHandleId, fromType, doc, lib, flowId, isValidConnection = alwaysValid, handleLookup }) {
  const isTarget = fromType === "target";
  const handleDomNode = handle ? doc.querySelector(`.${lib}-flow__handle[data-id="${flowId}-${handle == null ? void 0 : handle.nodeId}-${handle == null ? void 0 : handle.id}-${handle == null ? void 0 : handle.type}"]`) : null;
  const { x, y } = getEventPosition(event);
  const handleBelow = doc.elementFromPoint(x, y);
  const handleToCheck = (handleBelow == null ? void 0 : handleBelow.classList.contains(`${lib}-flow__handle`)) ? handleBelow : handleDomNode;
  const result = {
    handleDomNode: handleToCheck,
    isValid: false,
    connection: null,
    toHandle: null
  };
  if (handleToCheck) {
    const handleType = getHandleType(void 0, handleToCheck);
    const handleNodeId = handleToCheck.getAttribute("data-nodeid");
    const handleId = handleToCheck.getAttribute("data-handleid");
    const connectable = handleToCheck.classList.contains("connectable");
    const connectableEnd = handleToCheck.classList.contains("connectableend");
    if (!handleNodeId) {
      return result;
    }
    const connection = {
      source: isTarget ? handleNodeId : fromNodeId,
      sourceHandle: isTarget ? handleId : fromHandleId,
      target: isTarget ? fromNodeId : handleNodeId,
      targetHandle: isTarget ? fromHandleId : handleId
    };
    result.connection = connection;
    const isConnectable = connectable && connectableEnd;
    const isValid = isConnectable && (connectionMode === ConnectionMode.Strict ? isTarget && handleType === "source" || !isTarget && handleType === "target" : handleNodeId !== fromNodeId || handleId !== fromHandleId);
    result.isValid = isValid && isValidConnection(connection);
    if (handleLookup) {
      const toHandle = handleLookup.find((h) => h.id === handleId && h.nodeId === handleNodeId && h.type === handleType);
      if (toHandle) {
        result.toHandle = {
          ...toHandle
        };
      }
    }
  }
  return result;
}
var XYHandle = {
  onPointerDown,
  isValid: isValidHandle
};
function XYMinimap({ domNode, panZoom, getTransform, getViewScale }) {
  const selection2 = select_default2(domNode);
  function update({ translateExtent, width, height, zoomStep = 10, pannable = true, zoomable = true, inversePan = false }) {
    const zoomHandler = (event) => {
      const transform2 = getTransform();
      if (event.sourceEvent.type !== "wheel" || !panZoom) {
        return;
      }
      const pinchDelta = -event.sourceEvent.deltaY * (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 2e-3) * zoomStep;
      const nextZoom = transform2[2] * Math.pow(2, pinchDelta);
      panZoom.scaleTo(nextZoom);
    };
    let panStart = [0, 0];
    const panStartHandler = (event) => {
      if (event.sourceEvent.type === "mousedown" || event.sourceEvent.type === "touchstart") {
        panStart = [
          event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,
          event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY
        ];
      }
    };
    const panHandler = (event) => {
      const transform2 = getTransform();
      if (event.sourceEvent.type !== "mousemove" && event.sourceEvent.type !== "touchmove" || !panZoom) {
        return;
      }
      const panCurrent = [
        event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,
        event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY
      ];
      const panDelta = [panCurrent[0] - panStart[0], panCurrent[1] - panStart[1]];
      panStart = panCurrent;
      const moveScale = getViewScale() * Math.max(transform2[2], Math.log(transform2[2])) * (inversePan ? -1 : 1);
      const position = {
        x: transform2[0] - panDelta[0] * moveScale,
        y: transform2[1] - panDelta[1] * moveScale
      };
      const extent = [
        [0, 0],
        [width, height]
      ];
      panZoom.setViewportConstrained({
        x: position.x,
        y: position.y,
        zoom: transform2[2]
      }, extent, translateExtent);
    };
    const zoomAndPanHandler = zoom_default2().on("start", panStartHandler).on("zoom", pannable ? panHandler : null).on("zoom.wheel", zoomable ? zoomHandler : null);
    selection2.call(zoomAndPanHandler, {});
  }
  function destroy() {
    selection2.on("zoom", null);
  }
  return {
    update,
    destroy,
    pointer: pointer_default
  };
}
var viewChanged = (prevViewport, eventViewport) => prevViewport.x !== eventViewport.x || prevViewport.y !== eventViewport.y || prevViewport.zoom !== eventViewport.k;
var transformToViewport = (transform2) => ({
  x: transform2.x,
  y: transform2.y,
  zoom: transform2.k
});
var viewportToTransform = ({ x, y, zoom: zoom2 }) => identity2.translate(x, y).scale(zoom2);
var isWrappedWithClass = (event, className) => event.target.closest(`.${className}`);
var isRightClickPan = (panOnDrag, usedButton) => usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2);
var getD3Transition = (selection2, duration = 0, onEnd = () => {
}) => {
  const hasDuration = typeof duration === "number" && duration > 0;
  if (!hasDuration) {
    onEnd();
  }
  return hasDuration ? selection2.transition().duration(duration).on("end", onEnd) : selection2;
};
var wheelDelta = (event) => {
  const factor = event.ctrlKey && isMacOs() ? 10 : 1;
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * factor;
};
function createPanOnScrollHandler({ zoomPanValues, noWheelClassName, d3Selection, d3Zoom, panOnScrollMode, panOnScrollSpeed, zoomOnPinch, onPanZoomStart, onPanZoom, onPanZoomEnd }) {
  return (event) => {
    if (isWrappedWithClass(event, noWheelClassName)) {
      return false;
    }
    event.preventDefault();
    event.stopImmediatePropagation();
    const currentZoom = d3Selection.property("__zoom").k || 1;
    if (event.ctrlKey && zoomOnPinch) {
      const point = pointer_default(event);
      const pinchDelta = wheelDelta(event);
      const zoom2 = currentZoom * Math.pow(2, pinchDelta);
      d3Zoom.scaleTo(d3Selection, zoom2, point, event);
      return;
    }
    const deltaNormalize = event.deltaMode === 1 ? 20 : 1;
    let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize;
    let deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;
    if (!isMacOs() && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical) {
      deltaX = event.deltaY * deltaNormalize;
      deltaY = 0;
    }
    d3Zoom.translateBy(
      d3Selection,
      -(deltaX / currentZoom) * panOnScrollSpeed,
      -(deltaY / currentZoom) * panOnScrollSpeed,
      // @ts-ignore
      { internal: true }
    );
    const nextViewport = transformToViewport(d3Selection.property("__zoom"));
    clearTimeout(zoomPanValues.panScrollTimeout);
    if (!zoomPanValues.isPanScrolling) {
      zoomPanValues.isPanScrolling = true;
      onPanZoomStart == null ? void 0 : onPanZoomStart(event, nextViewport);
    }
    if (zoomPanValues.isPanScrolling) {
      onPanZoom == null ? void 0 : onPanZoom(event, nextViewport);
      zoomPanValues.panScrollTimeout = setTimeout(() => {
        onPanZoomEnd == null ? void 0 : onPanZoomEnd(event, nextViewport);
        zoomPanValues.isPanScrolling = false;
      }, 150);
    }
  };
}
function createZoomOnScrollHandler({ noWheelClassName, preventScrolling, d3ZoomHandler }) {
  return function(event, d) {
    const preventZoom = !preventScrolling && event.type === "wheel" && !event.ctrlKey;
    if (preventZoom || isWrappedWithClass(event, noWheelClassName)) {
      return null;
    }
    event.preventDefault();
    d3ZoomHandler.call(this, event, d);
  };
}
function createPanZoomStartHandler({ zoomPanValues, onDraggingChange, onPanZoomStart }) {
  return (event) => {
    var _a, _b, _c;
    if ((_a = event.sourceEvent) == null ? void 0 : _a.internal) {
      return;
    }
    const viewport = transformToViewport(event.transform);
    zoomPanValues.mouseButton = ((_b = event.sourceEvent) == null ? void 0 : _b.button) || 0;
    zoomPanValues.isZoomingOrPanning = true;
    zoomPanValues.prevViewport = viewport;
    if (((_c = event.sourceEvent) == null ? void 0 : _c.type) === "mousedown") {
      onDraggingChange(true);
    }
    if (onPanZoomStart) {
      onPanZoomStart == null ? void 0 : onPanZoomStart(event.sourceEvent, viewport);
    }
  };
}
function createPanZoomHandler({ zoomPanValues, panOnDrag, onPaneContextMenu, onTransformChange, onPanZoom }) {
  return (event) => {
    var _a, _b;
    zoomPanValues.usedRightMouseButton = !!(onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0));
    if (!((_a = event.sourceEvent) == null ? void 0 : _a.sync)) {
      onTransformChange([event.transform.x, event.transform.y, event.transform.k]);
    }
    if (onPanZoom && !((_b = event.sourceEvent) == null ? void 0 : _b.internal)) {
      onPanZoom == null ? void 0 : onPanZoom(event.sourceEvent, transformToViewport(event.transform));
    }
  };
}
function createPanZoomEndHandler({ zoomPanValues, panOnDrag, panOnScroll, onDraggingChange, onPanZoomEnd, onPaneContextMenu }) {
  return (event) => {
    var _a;
    if ((_a = event.sourceEvent) == null ? void 0 : _a.internal) {
      return;
    }
    zoomPanValues.isZoomingOrPanning = false;
    if (onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0) && !zoomPanValues.usedRightMouseButton && event.sourceEvent) {
      onPaneContextMenu(event.sourceEvent);
    }
    zoomPanValues.usedRightMouseButton = false;
    onDraggingChange(false);
    if (onPanZoomEnd && viewChanged(zoomPanValues.prevViewport, event.transform)) {
      const viewport = transformToViewport(event.transform);
      zoomPanValues.prevViewport = viewport;
      clearTimeout(zoomPanValues.timerId);
      zoomPanValues.timerId = setTimeout(
        () => {
          onPanZoomEnd == null ? void 0 : onPanZoomEnd(event.sourceEvent, viewport);
        },
        // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll
        panOnScroll ? 150 : 0
      );
    }
  };
}
function createFilter({ zoomActivationKeyPressed, zoomOnScroll, zoomOnPinch, panOnDrag, panOnScroll, zoomOnDoubleClick, userSelectionActive, noWheelClassName, noPanClassName, lib }) {
  return (event) => {
    var _a;
    const zoomScroll = zoomActivationKeyPressed || zoomOnScroll;
    const pinchZoom = zoomOnPinch && event.ctrlKey;
    if (event.button === 1 && event.type === "mousedown" && (isWrappedWithClass(event, `${lib}-flow__node`) || isWrappedWithClass(event, `${lib}-flow__edge`))) {
      return true;
    }
    if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {
      return false;
    }
    if (userSelectionActive) {
      return false;
    }
    if (isWrappedWithClass(event, noWheelClassName) && event.type === "wheel") {
      return false;
    }
    if (isWrappedWithClass(event, noPanClassName) && (event.type !== "wheel" || panOnScroll && event.type === "wheel" && !zoomActivationKeyPressed)) {
      return false;
    }
    if (!zoomOnPinch && event.ctrlKey && event.type === "wheel") {
      return false;
    }
    if (!zoomOnPinch && event.type === "touchstart" && ((_a = event.touches) == null ? void 0 : _a.length) > 1) {
      event.preventDefault();
      return false;
    }
    if (!zoomScroll && !panOnScroll && !pinchZoom && event.type === "wheel") {
      return false;
    }
    if (!panOnDrag && (event.type === "mousedown" || event.type === "touchstart")) {
      return false;
    }
    if (Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && event.type === "mousedown") {
      return false;
    }
    const buttonAllowed = Array.isArray(panOnDrag) && panOnDrag.includes(event.button) || !event.button || event.button <= 1;
    return (!event.ctrlKey || event.type === "wheel") && buttonAllowed;
  };
}
function XYPanZoom({ domNode, minZoom, maxZoom, paneClickDistance, translateExtent, viewport, onPanZoom, onPanZoomStart, onPanZoomEnd, onTransformChange, onDraggingChange }) {
  const zoomPanValues = {
    isZoomingOrPanning: false,
    usedRightMouseButton: false,
    prevViewport: { x: 0, y: 0, zoom: 0 },
    mouseButton: 0,
    timerId: void 0,
    panScrollTimeout: void 0,
    isPanScrolling: false
  };
  const bbox = domNode.getBoundingClientRect();
  const d3ZoomInstance = zoom_default2().clickDistance(!isNumeric(paneClickDistance) || paneClickDistance < 0 ? 0 : paneClickDistance).scaleExtent([minZoom, maxZoom]).translateExtent(translateExtent);
  const d3Selection = select_default2(domNode).call(d3ZoomInstance);
  setViewportConstrained({
    x: viewport.x,
    y: viewport.y,
    zoom: clamp(viewport.zoom, minZoom, maxZoom)
  }, [
    [0, 0],
    [bbox.width, bbox.height]
  ], translateExtent);
  const d3ZoomHandler = d3Selection.on("wheel.zoom");
  const d3DblClickZoomHandler = d3Selection.on("dblclick.zoom");
  d3ZoomInstance.wheelDelta(wheelDelta);
  function setTransform(transform2, options) {
    if (d3Selection) {
      return new Promise((resolve) => {
        d3ZoomInstance == null ? void 0 : d3ZoomInstance.transform(getD3Transition(d3Selection, options == null ? void 0 : options.duration, () => resolve(true)), transform2);
      });
    }
    return Promise.resolve(false);
  }
  function update({ noWheelClassName, noPanClassName, onPaneContextMenu, userSelectionActive, panOnScroll, panOnDrag, panOnScrollMode, panOnScrollSpeed, preventScrolling, zoomOnPinch, zoomOnScroll, zoomOnDoubleClick, zoomActivationKeyPressed, lib }) {
    if (userSelectionActive && !zoomPanValues.isZoomingOrPanning) {
      destroy();
    }
    const isPanOnScroll = panOnScroll && !zoomActivationKeyPressed && !userSelectionActive;
    const wheelHandler = isPanOnScroll ? createPanOnScrollHandler({
      zoomPanValues,
      noWheelClassName,
      d3Selection,
      d3Zoom: d3ZoomInstance,
      panOnScrollMode,
      panOnScrollSpeed,
      zoomOnPinch,
      onPanZoomStart,
      onPanZoom,
      onPanZoomEnd
    }) : createZoomOnScrollHandler({
      noWheelClassName,
      preventScrolling,
      d3ZoomHandler
    });
    d3Selection.on("wheel.zoom", wheelHandler, { passive: false });
    if (!userSelectionActive) {
      const startHandler = createPanZoomStartHandler({
        zoomPanValues,
        onDraggingChange,
        onPanZoomStart
      });
      d3ZoomInstance.on("start", startHandler);
      const panZoomHandler = createPanZoomHandler({
        zoomPanValues,
        panOnDrag,
        onPaneContextMenu: !!onPaneContextMenu,
        onPanZoom,
        onTransformChange
      });
      d3ZoomInstance.on("zoom", panZoomHandler);
      const panZoomEndHandler = createPanZoomEndHandler({
        zoomPanValues,
        panOnDrag,
        panOnScroll,
        onPaneContextMenu,
        onPanZoomEnd,
        onDraggingChange
      });
      d3ZoomInstance.on("end", panZoomEndHandler);
    }
    const filter2 = createFilter({
      zoomActivationKeyPressed,
      panOnDrag,
      zoomOnScroll,
      panOnScroll,
      zoomOnDoubleClick,
      zoomOnPinch,
      userSelectionActive,
      noPanClassName,
      noWheelClassName,
      lib
    });
    d3ZoomInstance.filter(filter2);
    if (zoomOnDoubleClick) {
      d3Selection.on("dblclick.zoom", d3DblClickZoomHandler);
    } else {
      d3Selection.on("dblclick.zoom", null);
    }
  }
  function destroy() {
    d3ZoomInstance.on("zoom", null);
  }
  async function setViewportConstrained(viewport2, extent, translateExtent2) {
    const nextTransform = viewportToTransform(viewport2);
    const contrainedTransform = d3ZoomInstance == null ? void 0 : d3ZoomInstance.constrain()(nextTransform, extent, translateExtent2);
    if (contrainedTransform) {
      await setTransform(contrainedTransform);
    }
    return new Promise((resolve) => resolve(contrainedTransform));
  }
  async function setViewport(viewport2, options) {
    const nextTransform = viewportToTransform(viewport2);
    await setTransform(nextTransform, options);
    return new Promise((resolve) => resolve(nextTransform));
  }
  function syncViewport(viewport2) {
    if (d3Selection) {
      const nextTransform = viewportToTransform(viewport2);
      const currentTransform = d3Selection.property("__zoom");
      if (currentTransform.k !== viewport2.zoom || currentTransform.x !== viewport2.x || currentTransform.y !== viewport2.y) {
        d3ZoomInstance == null ? void 0 : d3ZoomInstance.transform(d3Selection, nextTransform, null, { sync: true });
      }
    }
  }
  function getViewport() {
    const transform2 = d3Selection ? transform(d3Selection.node()) : { x: 0, y: 0, k: 1 };
    return { x: transform2.x, y: transform2.y, zoom: transform2.k };
  }
  function scaleTo(zoom2, options) {
    if (d3Selection) {
      return new Promise((resolve) => {
        d3ZoomInstance == null ? void 0 : d3ZoomInstance.scaleTo(getD3Transition(d3Selection, options == null ? void 0 : options.duration, () => resolve(true)), zoom2);
      });
    }
    return Promise.resolve(false);
  }
  function scaleBy(factor, options) {
    if (d3Selection) {
      return new Promise((resolve) => {
        d3ZoomInstance == null ? void 0 : d3ZoomInstance.scaleBy(getD3Transition(d3Selection, options == null ? void 0 : options.duration, () => resolve(true)), factor);
      });
    }
    return Promise.resolve(false);
  }
  function setScaleExtent(scaleExtent) {
    d3ZoomInstance == null ? void 0 : d3ZoomInstance.scaleExtent(scaleExtent);
  }
  function setTranslateExtent(translateExtent2) {
    d3ZoomInstance == null ? void 0 : d3ZoomInstance.translateExtent(translateExtent2);
  }
  function setClickDistance(distance2) {
    const validDistance = !isNumeric(distance2) || distance2 < 0 ? 0 : distance2;
    d3ZoomInstance == null ? void 0 : d3ZoomInstance.clickDistance(validDistance);
  }
  return {
    update,
    destroy,
    setViewport,
    setViewportConstrained,
    getViewport,
    scaleTo,
    scaleBy,
    setScaleExtent,
    setTranslateExtent,
    syncViewport,
    setClickDistance
  };
}
var ResizeControlVariant;
(function(ResizeControlVariant2) {
  ResizeControlVariant2["Line"] = "line";
  ResizeControlVariant2["Handle"] = "handle";
})(ResizeControlVariant || (ResizeControlVariant = {}));
var XY_RESIZER_HANDLE_POSITIONS = ["top-left", "top-right", "bottom-left", "bottom-right"];
var XY_RESIZER_LINE_POSITIONS = ["top", "right", "bottom", "left"];
function getResizeDirection({ width, prevWidth, height, prevHeight, affectsX, affectsY }) {
  const deltaWidth = width - prevWidth;
  const deltaHeight = height - prevHeight;
  const direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];
  if (deltaWidth && affectsX) {
    direction[0] = direction[0] * -1;
  }
  if (deltaHeight && affectsY) {
    direction[1] = direction[1] * -1;
  }
  return direction;
}
function getControlDirection(controlPosition) {
  const isHorizontal = controlPosition.includes("right") || controlPosition.includes("left");
  const isVertical = controlPosition.includes("bottom") || controlPosition.includes("top");
  const affectsX = controlPosition.includes("left");
  const affectsY = controlPosition.includes("top");
  return {
    isHorizontal,
    isVertical,
    affectsX,
    affectsY
  };
}
function getLowerExtentClamp(lowerExtent, lowerBound) {
  return Math.max(0, lowerBound - lowerExtent);
}
function getUpperExtentClamp(upperExtent, upperBound) {
  return Math.max(0, upperExtent - upperBound);
}
function getSizeClamp(size, minSize, maxSize) {
  return Math.max(0, minSize - size, size - maxSize);
}
function xor(a, b) {
  return a ? !b : b;
}
function getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, extent, childExtent) {
  let { affectsX, affectsY } = controlDirection;
  const { isHorizontal, isVertical } = controlDirection;
  const isDiagonal = isHorizontal && isVertical;
  const { xSnapped, ySnapped } = pointerPosition;
  const { minWidth, maxWidth, minHeight, maxHeight } = boundaries;
  const { x: startX, y: startY, width: startWidth, height: startHeight, aspectRatio } = startValues;
  let distX = Math.floor(isHorizontal ? xSnapped - startValues.pointerX : 0);
  let distY = Math.floor(isVertical ? ySnapped - startValues.pointerY : 0);
  const newWidth = startWidth + (affectsX ? -distX : distX);
  const newHeight = startHeight + (affectsY ? -distY : distY);
  const originOffsetX = -nodeOrigin[0] * startWidth;
  const originOffsetY = -nodeOrigin[1] * startHeight;
  let clampX = getSizeClamp(newWidth, minWidth, maxWidth);
  let clampY = getSizeClamp(newHeight, minHeight, maxHeight);
  if (extent) {
    let xExtentClamp = 0;
    let yExtentClamp = 0;
    if (affectsX && distX < 0) {
      xExtentClamp = getLowerExtentClamp(startX + distX + originOffsetX, extent[0][0]);
    } else if (!affectsX && distX > 0) {
      xExtentClamp = getUpperExtentClamp(startX + newWidth + originOffsetX, extent[1][0]);
    }
    if (affectsY && distY < 0) {
      yExtentClamp = getLowerExtentClamp(startY + distY + originOffsetY, extent[0][1]);
    } else if (!affectsY && distY > 0) {
      yExtentClamp = getUpperExtentClamp(startY + newHeight + originOffsetY, extent[1][1]);
    }
    clampX = Math.max(clampX, xExtentClamp);
    clampY = Math.max(clampY, yExtentClamp);
  }
  if (childExtent) {
    let xExtentClamp = 0;
    let yExtentClamp = 0;
    if (affectsX && distX > 0) {
      xExtentClamp = getUpperExtentClamp(startX + distX, childExtent[0][0]);
    } else if (!affectsX && distX < 0) {
      xExtentClamp = getLowerExtentClamp(startX + newWidth, childExtent[1][0]);
    }
    if (affectsY && distY > 0) {
      yExtentClamp = getUpperExtentClamp(startY + distY, childExtent[0][1]);
    } else if (!affectsY && distY < 0) {
      yExtentClamp = getLowerExtentClamp(startY + newHeight, childExtent[1][1]);
    }
    clampX = Math.max(clampX, xExtentClamp);
    clampY = Math.max(clampY, yExtentClamp);
  }
  if (keepAspectRatio) {
    if (isHorizontal) {
      const aspectHeightClamp = getSizeClamp(newWidth / aspectRatio, minHeight, maxHeight) * aspectRatio;
      clampX = Math.max(clampX, aspectHeightClamp);
      if (extent) {
        let aspectExtentClamp = 0;
        if (!affectsX && !affectsY || affectsX && !affectsY && isDiagonal) {
          aspectExtentClamp = getUpperExtentClamp(startY + originOffsetY + newWidth / aspectRatio, extent[1][1]) * aspectRatio;
        } else {
          aspectExtentClamp = getLowerExtentClamp(startY + originOffsetY + (affectsX ? distX : -distX) / aspectRatio, extent[0][1]) * aspectRatio;
        }
        clampX = Math.max(clampX, aspectExtentClamp);
      }
      if (childExtent) {
        let aspectExtentClamp = 0;
        if (!affectsX && !affectsY || affectsX && !affectsY && isDiagonal) {
          aspectExtentClamp = getLowerExtentClamp(startY + newWidth / aspectRatio, childExtent[1][1]) * aspectRatio;
        } else {
          aspectExtentClamp = getUpperExtentClamp(startY + (affectsX ? distX : -distX) / aspectRatio, childExtent[0][1]) * aspectRatio;
        }
        clampX = Math.max(clampX, aspectExtentClamp);
      }
    }
    if (isVertical) {
      const aspectWidthClamp = getSizeClamp(newHeight * aspectRatio, minWidth, maxWidth) / aspectRatio;
      clampY = Math.max(clampY, aspectWidthClamp);
      if (extent) {
        let aspectExtentClamp = 0;
        if (!affectsX && !affectsY || affectsY && !affectsX && isDiagonal) {
          aspectExtentClamp = getUpperExtentClamp(startX + newHeight * aspectRatio + originOffsetX, extent[1][0]) / aspectRatio;
        } else {
          aspectExtentClamp = getLowerExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio + originOffsetX, extent[0][0]) / aspectRatio;
        }
        clampY = Math.max(clampY, aspectExtentClamp);
      }
      if (childExtent) {
        let aspectExtentClamp = 0;
        if (!affectsX && !affectsY || affectsY && !affectsX && isDiagonal) {
          aspectExtentClamp = getLowerExtentClamp(startX + newHeight * aspectRatio, childExtent[1][0]) / aspectRatio;
        } else {
          aspectExtentClamp = getUpperExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio, childExtent[0][0]) / aspectRatio;
        }
        clampY = Math.max(clampY, aspectExtentClamp);
      }
    }
  }
  distY = distY + (distY < 0 ? clampY : -clampY);
  distX = distX + (distX < 0 ? clampX : -clampX);
  if (keepAspectRatio) {
    if (isDiagonal) {
      if (newWidth > newHeight * aspectRatio) {
        distY = (xor(affectsX, affectsY) ? -distX : distX) / aspectRatio;
      } else {
        distX = (xor(affectsX, affectsY) ? -distY : distY) * aspectRatio;
      }
    } else {
      if (isHorizontal) {
        distY = distX / aspectRatio;
        affectsY = affectsX;
      } else {
        distX = distY * aspectRatio;
        affectsX = affectsY;
      }
    }
  }
  const x = affectsX ? startX + distX : startX;
  const y = affectsY ? startY + distY : startY;
  return {
    width: startWidth + (affectsX ? -distX : distX),
    height: startHeight + (affectsY ? -distY : distY),
    x: nodeOrigin[0] * distX * (!affectsX ? 1 : -1) + x,
    y: nodeOrigin[1] * distY * (!affectsY ? 1 : -1) + y
  };
}
var initPrevValues = { width: 0, height: 0, x: 0, y: 0 };
var initStartValues = {
  ...initPrevValues,
  pointerX: 0,
  pointerY: 0,
  aspectRatio: 1
};
function nodeToParentExtent(node) {
  return [
    [0, 0],
    [node.measured.width, node.measured.height]
  ];
}
function nodeToChildExtent(child, parent, nodeOrigin) {
  const x = parent.position.x + child.position.x;
  const y = parent.position.y + child.position.y;
  const width = child.measured.width ?? 0;
  const height = child.measured.height ?? 0;
  const originOffsetX = nodeOrigin[0] * width;
  const originOffsetY = nodeOrigin[1] * height;
  return [
    [x - originOffsetX, y - originOffsetY],
    [x + width - originOffsetX, y + height - originOffsetY]
  ];
}
function XYResizer({ domNode, nodeId, getStoreItems, onChange, onEnd }) {
  const selection2 = select_default2(domNode);
  function update({ controlPosition, boundaries, keepAspectRatio, onResizeStart, onResize, onResizeEnd, shouldResize }) {
    let prevValues = { ...initPrevValues };
    let startValues = { ...initStartValues };
    const controlDirection = getControlDirection(controlPosition);
    let node = void 0;
    let childNodes = [];
    let parentNode = void 0;
    let parentExtent = void 0;
    let childExtent = void 0;
    const dragHandler = drag_default().on("start", (event) => {
      const { nodeLookup, transform: transform2, snapGrid, snapToGrid, nodeOrigin } = getStoreItems();
      node = nodeLookup.get(nodeId);
      if (!node) {
        return;
      }
      const { xSnapped, ySnapped } = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid });
      prevValues = {
        width: node.measured.width ?? 0,
        height: node.measured.height ?? 0,
        x: node.position.x ?? 0,
        y: node.position.y ?? 0
      };
      startValues = {
        ...prevValues,
        pointerX: xSnapped,
        pointerY: ySnapped,
        aspectRatio: prevValues.width / prevValues.height
      };
      parentNode = void 0;
      if (node.parentId && (node.extent === "parent" || node.expandParent)) {
        parentNode = nodeLookup.get(node.parentId);
        parentExtent = parentNode && node.extent === "parent" ? nodeToParentExtent(parentNode) : void 0;
      }
      childNodes = [];
      childExtent = void 0;
      for (const [childId, child] of nodeLookup) {
        if (child.parentId === nodeId) {
          childNodes.push({
            id: childId,
            position: { ...child.position },
            extent: child.extent
          });
          if (child.extent === "parent" || child.expandParent) {
            const extent = nodeToChildExtent(child, node, child.origin ?? nodeOrigin);
            if (childExtent) {
              childExtent = [
                [Math.min(extent[0][0], childExtent[0][0]), Math.min(extent[0][1], childExtent[0][1])],
                [Math.max(extent[1][0], childExtent[1][0]), Math.max(extent[1][1], childExtent[1][1])]
              ];
            } else {
              childExtent = extent;
            }
          }
        }
      }
      onResizeStart == null ? void 0 : onResizeStart(event, { ...prevValues });
    }).on("drag", (event) => {
      const { transform: transform2, snapGrid, snapToGrid, nodeOrigin: storeNodeOrigin } = getStoreItems();
      const pointerPosition = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid });
      const childChanges = [];
      if (!node) {
        return;
      }
      const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues;
      const change = {};
      const nodeOrigin = node.origin ?? storeNodeOrigin;
      const { width, height, x, y } = getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, parentExtent, childExtent);
      const isWidthChange = width !== prevWidth;
      const isHeightChange = height !== prevHeight;
      const isXPosChange = x !== prevX && isWidthChange;
      const isYPosChange = y !== prevY && isHeightChange;
      if (!isXPosChange && !isYPosChange && !isWidthChange && !isHeightChange) {
        return;
      }
      if (isXPosChange || isYPosChange || nodeOrigin[0] === 1 || nodeOrigin[1] === 1) {
        change.x = isXPosChange ? x : prevValues.x;
        change.y = isYPosChange ? y : prevValues.y;
        prevValues.x = change.x;
        prevValues.y = change.y;
        if (childNodes.length > 0) {
          const xChange = x - prevX;
          const yChange = y - prevY;
          for (const childNode of childNodes) {
            childNode.position = {
              x: childNode.position.x - xChange + nodeOrigin[0] * (width - prevWidth),
              y: childNode.position.y - yChange + nodeOrigin[1] * (height - prevHeight)
            };
            childChanges.push(childNode);
          }
        }
      }
      if (isWidthChange || isHeightChange) {
        change.width = isWidthChange ? width : prevValues.width;
        change.height = isHeightChange ? height : prevValues.height;
        prevValues.width = change.width;
        prevValues.height = change.height;
      }
      if (parentNode && node.expandParent) {
        const xLimit = nodeOrigin[0] * (change.width ?? 0);
        if (change.x && change.x < xLimit) {
          prevValues.x = xLimit;
          startValues.x = startValues.x - (change.x - xLimit);
        }
        const yLimit = nodeOrigin[1] * (change.height ?? 0);
        if (change.y && change.y < yLimit) {
          prevValues.y = yLimit;
          startValues.y = startValues.y - (change.y - yLimit);
        }
      }
      const direction = getResizeDirection({
        width: prevValues.width,
        prevWidth,
        height: prevValues.height,
        prevHeight,
        affectsX: controlDirection.affectsX,
        affectsY: controlDirection.affectsY
      });
      const nextValues = { ...prevValues, direction };
      const callResize = shouldResize == null ? void 0 : shouldResize(event, nextValues);
      if (callResize === false) {
        return;
      }
      onResize == null ? void 0 : onResize(event, nextValues);
      onChange(change, childChanges);
    }).on("end", (event) => {
      onResizeEnd == null ? void 0 : onResizeEnd(event, { ...prevValues });
      onEnd == null ? void 0 : onEnd();
    });
    selection2.call(dragHandler);
  }
  function destroy() {
    selection2.on(".drag", null);
  }
  return {
    update,
    destroy
  };
}

// node_modules/@xyflow/svelte/dist/lib/components/Handle/Handle.svelte
var file = "node_modules/@xyflow/svelte/dist/lib/components/Handle/Handle.svelte";
function create_fragment(ctx) {
  let div;
  let div_data_id_value;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[44].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    null
  );
  const block = {
    c: function create2() {
      div = element("div");
      if (default_slot) default_slot.c();
      attr_dev(
        div,
        "data-handleid",
        /*handleId*/
        ctx[7]
      );
      attr_dev(
        div,
        "data-nodeid",
        /*nodeId*/
        ctx[14]
      );
      attr_dev(
        div,
        "data-handlepos",
        /*position*/
        ctx[3]
      );
      attr_dev(div, "data-id", div_data_id_value = /*$flowId*/
      ctx[13] + "-" + /*nodeId*/
      ctx[14] + "-" + /*id*/
      (ctx[1] || null) + "-" + /*type*/
      ctx[2]);
      attr_dev(div, "class", div_class_value = cc([
        "svelte-flow__handle",
        `svelte-flow__handle-${/*position*/
        ctx[3]}`,
        "nodrag",
        "nopan",
        /*position*/
        ctx[3],
        /*className*/
        ctx[5]
      ]));
      attr_dev(
        div,
        "style",
        /*style*/
        ctx[4]
      );
      attr_dev(div, "role", "button");
      attr_dev(div, "tabindex", "-1");
      toggle_class(
        div,
        "valid",
        /*valid*/
        ctx[8]
      );
      toggle_class(
        div,
        "connectingto",
        /*connectingTo*/
        ctx[6]
      );
      toggle_class(
        div,
        "connectingfrom",
        /*connectingFrom*/
        ctx[10]
      );
      toggle_class(div, "source", !/*isTarget*/
      ctx[12]);
      toggle_class(
        div,
        "target",
        /*isTarget*/
        ctx[12]
      );
      toggle_class(
        div,
        "connectablestart",
        /*isConnectable*/
        ctx[0]
      );
      toggle_class(
        div,
        "connectableend",
        /*isConnectable*/
        ctx[0]
      );
      toggle_class(
        div,
        "connectable",
        /*isConnectable*/
        ctx[0]
      );
      toggle_class(
        div,
        "connectionindicator",
        /*isConnectable*/
        ctx[0] && (!/*connectionInProcess*/
        ctx[11] || /*isPossibleEndHandle*/
        ctx[9])
      );
      add_location(div, file, 100, 0, 4289);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "mousedown",
            /*onPointerDown*/
            ctx[32],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "touchstart",
            /*onPointerDown*/
            ctx[32],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*handleId*/
      128) {
        attr_dev(
          div,
          "data-handleid",
          /*handleId*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*position*/
      8) {
        attr_dev(
          div,
          "data-handlepos",
          /*position*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*$flowId, id, type*/
      8198 && div_data_id_value !== (div_data_id_value = /*$flowId*/
      ctx2[13] + "-" + /*nodeId*/
      ctx2[14] + "-" + /*id*/
      (ctx2[1] || null) + "-" + /*type*/
      ctx2[2])) {
        attr_dev(div, "data-id", div_data_id_value);
      }
      if (!current || dirty[0] & /*position, className*/
      40 && div_class_value !== (div_class_value = cc([
        "svelte-flow__handle",
        `svelte-flow__handle-${/*position*/
        ctx2[3]}`,
        "nodrag",
        "nopan",
        /*position*/
        ctx2[3],
        /*className*/
        ctx2[5]
      ]))) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*style*/
      16) {
        attr_dev(
          div,
          "style",
          /*style*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*position, className, valid*/
      296) {
        toggle_class(
          div,
          "valid",
          /*valid*/
          ctx2[8]
        );
      }
      if (!current || dirty[0] & /*position, className, connectingTo*/
      104) {
        toggle_class(
          div,
          "connectingto",
          /*connectingTo*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*position, className, connectingFrom*/
      1064) {
        toggle_class(
          div,
          "connectingfrom",
          /*connectingFrom*/
          ctx2[10]
        );
      }
      if (!current || dirty[0] & /*position, className, isTarget*/
      4136) {
        toggle_class(div, "source", !/*isTarget*/
        ctx2[12]);
      }
      if (!current || dirty[0] & /*position, className, isTarget*/
      4136) {
        toggle_class(
          div,
          "target",
          /*isTarget*/
          ctx2[12]
        );
      }
      if (!current || dirty[0] & /*position, className, isConnectable*/
      41) {
        toggle_class(
          div,
          "connectablestart",
          /*isConnectable*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*position, className, isConnectable*/
      41) {
        toggle_class(
          div,
          "connectableend",
          /*isConnectable*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*position, className, isConnectable*/
      41) {
        toggle_class(
          div,
          "connectable",
          /*isConnectable*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*position, className, isConnectable, connectionInProcess, isPossibleEndHandle*/
      2601) {
        toggle_class(
          div,
          "connectionindicator",
          /*isConnectable*/
          ctx2[0] && (!/*connectionInProcess*/
          ctx2[11] || /*isPossibleEndHandle*/
          ctx2[9])
        );
      }
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(default_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(default_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let isTarget;
  let handleId;
  let connectionInProcess;
  let connectingFrom;
  let connectingTo;
  let isPossibleEndHandle;
  let valid;
  let $connection;
  let $connectionMode;
  let $connectionLookup;
  let $edges;
  let $viewport;
  let $onConnectEndAction;
  let $onConnectStartAction;
  let $onConnectAction;
  let $onedgecreate;
  let $isValidConnectionStore;
  let $flowId;
  let $autoPanOnConnect;
  let $lib;
  let $nodeLookup;
  let $domNode;
  let $connectionRadius;
  let $connectable;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Handle", slots, ["default"]);
  let { id: id2 = void 0 } = $$props;
  let { type = "source" } = $$props;
  let { position = Position.Top } = $$props;
  let { style = void 0 } = $$props;
  let { isConnectable = void 0 } = $$props;
  let { isValidConnection = void 0 } = $$props;
  let { onconnect = void 0 } = $$props;
  let { ondisconnect = void 0 } = $$props;
  let { class: className = void 0 } = $$props;
  const nodeId = getContext("svelteflow__node_id");
  const connectable = getContext("svelteflow__node_connectable");
  validate_store(connectable, "connectable");
  component_subscribe($$self, connectable, (value) => $$invalidate(42, $connectable = value));
  const store = useStore();
  const { connectionMode, domNode, nodeLookup, connectionRadius, viewport, isValidConnection: isValidConnectionStore, lib, addEdge: addEdge2, onedgecreate, panBy: panBy2, cancelConnection, updateConnection, autoPanOnConnect, edges, connectionLookup, onconnect: onConnectAction, onconnectstart: onConnectStartAction, onconnectend: onConnectEndAction, flowId, connection } = store;
  validate_store(connectionMode, "connectionMode");
  component_subscribe($$self, connectionMode, (value) => $$invalidate(39, $connectionMode = value));
  validate_store(domNode, "domNode");
  component_subscribe($$self, domNode, (value) => $$invalidate(54, $domNode = value));
  validate_store(nodeLookup, "nodeLookup");
  component_subscribe($$self, nodeLookup, (value) => $$invalidate(53, $nodeLookup = value));
  validate_store(connectionRadius, "connectionRadius");
  component_subscribe($$self, connectionRadius, (value) => $$invalidate(55, $connectionRadius = value));
  validate_store(viewport, "viewport");
  component_subscribe($$self, viewport, (value) => $$invalidate(45, $viewport = value));
  validate_store(isValidConnectionStore, "isValidConnectionStore");
  component_subscribe($$self, isValidConnectionStore, (value) => $$invalidate(50, $isValidConnectionStore = value));
  validate_store(lib, "lib");
  component_subscribe($$self, lib, (value) => $$invalidate(52, $lib = value));
  validate_store(onedgecreate, "onedgecreate");
  component_subscribe($$self, onedgecreate, (value) => $$invalidate(49, $onedgecreate = value));
  validate_store(autoPanOnConnect, "autoPanOnConnect");
  component_subscribe($$self, autoPanOnConnect, (value) => $$invalidate(51, $autoPanOnConnect = value));
  validate_store(edges, "edges");
  component_subscribe($$self, edges, (value) => $$invalidate(41, $edges = value));
  validate_store(connectionLookup, "connectionLookup");
  component_subscribe($$self, connectionLookup, (value) => $$invalidate(40, $connectionLookup = value));
  validate_store(onConnectAction, "onConnectAction");
  component_subscribe($$self, onConnectAction, (value) => $$invalidate(48, $onConnectAction = value));
  validate_store(onConnectStartAction, "onConnectStartAction");
  component_subscribe($$self, onConnectStartAction, (value) => $$invalidate(47, $onConnectStartAction = value));
  validate_store(onConnectEndAction, "onConnectEndAction");
  component_subscribe($$self, onConnectEndAction, (value) => $$invalidate(46, $onConnectEndAction = value));
  validate_store(flowId, "flowId");
  component_subscribe($$self, flowId, (value) => $$invalidate(13, $flowId = value));
  validate_store(connection, "connection");
  component_subscribe($$self, connection, (value) => $$invalidate(38, $connection = value));
  function onPointerDown2(event) {
    const isMouseTriggered = isMouseEvent(event);
    if (isMouseTriggered && event.button === 0 || !isMouseTriggered) {
      XYHandle.onPointerDown(event, {
        handleId,
        nodeId,
        isTarget,
        connectionRadius: $connectionRadius,
        domNode: $domNode,
        nodeLookup: $nodeLookup,
        connectionMode: $connectionMode,
        lib: $lib,
        autoPanOnConnect: $autoPanOnConnect,
        flowId: $flowId,
        isValidConnection: isValidConnection ?? $isValidConnectionStore,
        updateConnection,
        cancelConnection,
        panBy: panBy2,
        onConnect: (connection2) => {
          const edge = $onedgecreate ? $onedgecreate(connection2) : connection2;
          if (!edge) {
            return;
          }
          addEdge2(edge);
          $onConnectAction == null ? void 0 : $onConnectAction(connection2);
        },
        onConnectStart: (event2, startParams) => {
          $onConnectStartAction == null ? void 0 : $onConnectStartAction(event2, {
            nodeId: startParams.nodeId,
            handleId: startParams.handleId,
            handleType: startParams.handleType
          });
        },
        onConnectEnd: (event2) => {
          $onConnectEndAction == null ? void 0 : $onConnectEndAction(event2);
        },
        getTransform: () => [$viewport.x, $viewport.y, $viewport.zoom],
        getFromHandle: () => $connection.fromHandle
      });
    }
  }
  let prevConnections = null;
  let connections;
  const writable_props = [
    "id",
    "type",
    "position",
    "style",
    "isConnectable",
    "isValidConnection",
    "onconnect",
    "ondisconnect",
    "class"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Handle> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2) $$invalidate(1, id2 = $$props2.id);
    if ("type" in $$props2) $$invalidate(2, type = $$props2.type);
    if ("position" in $$props2) $$invalidate(3, position = $$props2.position);
    if ("style" in $$props2) $$invalidate(4, style = $$props2.style);
    if ("isConnectable" in $$props2) $$invalidate(0, isConnectable = $$props2.isConnectable);
    if ("isValidConnection" in $$props2) $$invalidate(33, isValidConnection = $$props2.isValidConnection);
    if ("onconnect" in $$props2) $$invalidate(34, onconnect = $$props2.onconnect);
    if ("ondisconnect" in $$props2) $$invalidate(35, ondisconnect = $$props2.ondisconnect);
    if ("class" in $$props2) $$invalidate(5, className = $$props2.class);
    if ("$$scope" in $$props2) $$invalidate(43, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    cc,
    Position,
    XYHandle,
    isMouseEvent,
    areConnectionMapsEqual,
    handleConnectionChange,
    ConnectionMode,
    useStore,
    id: id2,
    type,
    position,
    style,
    isConnectable,
    isValidConnection,
    onconnect,
    ondisconnect,
    className,
    nodeId,
    connectable,
    store,
    connectionMode,
    domNode,
    nodeLookup,
    connectionRadius,
    viewport,
    isValidConnectionStore,
    lib,
    addEdge: addEdge2,
    onedgecreate,
    panBy: panBy2,
    cancelConnection,
    updateConnection,
    autoPanOnConnect,
    edges,
    connectionLookup,
    onConnectAction,
    onConnectStartAction,
    onConnectEndAction,
    flowId,
    connection,
    onPointerDown: onPointerDown2,
    prevConnections,
    connections,
    connectingTo,
    valid,
    handleId,
    isPossibleEndHandle,
    connectingFrom,
    connectionInProcess,
    isTarget,
    $connection,
    $connectionMode,
    $connectionLookup,
    $edges,
    $viewport,
    $onConnectEndAction,
    $onConnectStartAction,
    $onConnectAction,
    $onedgecreate,
    $isValidConnectionStore,
    $flowId,
    $autoPanOnConnect,
    $lib,
    $nodeLookup,
    $domNode,
    $connectionRadius,
    $connectable
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2) $$invalidate(1, id2 = $$props2.id);
    if ("type" in $$props2) $$invalidate(2, type = $$props2.type);
    if ("position" in $$props2) $$invalidate(3, position = $$props2.position);
    if ("style" in $$props2) $$invalidate(4, style = $$props2.style);
    if ("isConnectable" in $$props2) $$invalidate(0, isConnectable = $$props2.isConnectable);
    if ("isValidConnection" in $$props2) $$invalidate(33, isValidConnection = $$props2.isValidConnection);
    if ("onconnect" in $$props2) $$invalidate(34, onconnect = $$props2.onconnect);
    if ("ondisconnect" in $$props2) $$invalidate(35, ondisconnect = $$props2.ondisconnect);
    if ("className" in $$props2) $$invalidate(5, className = $$props2.className);
    if ("prevConnections" in $$props2) $$invalidate(36, prevConnections = $$props2.prevConnections);
    if ("connections" in $$props2) $$invalidate(37, connections = $$props2.connections);
    if ("connectingTo" in $$props2) $$invalidate(6, connectingTo = $$props2.connectingTo);
    if ("valid" in $$props2) $$invalidate(8, valid = $$props2.valid);
    if ("handleId" in $$props2) $$invalidate(7, handleId = $$props2.handleId);
    if ("isPossibleEndHandle" in $$props2) $$invalidate(9, isPossibleEndHandle = $$props2.isPossibleEndHandle);
    if ("connectingFrom" in $$props2) $$invalidate(10, connectingFrom = $$props2.connectingFrom);
    if ("connectionInProcess" in $$props2) $$invalidate(11, connectionInProcess = $$props2.connectionInProcess);
    if ("isTarget" in $$props2) $$invalidate(12, isTarget = $$props2.isTarget);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    if ($$self.$$.dirty[0] & /*type*/
    4) {
      $: $$invalidate(12, isTarget = type === "target");
    }
    if ($$self.$$.dirty[0] & /*isConnectable*/
    1 | $$self.$$.dirty[1] & /*$connectable*/
    2048) {
      $: $$invalidate(0, isConnectable = isConnectable !== void 0 ? isConnectable : $connectable);
    }
    if ($$self.$$.dirty[0] & /*id*/
    2) {
      $: $$invalidate(7, handleId = id2 || null);
    }
    if ($$self.$$.dirty[0] & /*type, id*/
    6 | $$self.$$.dirty[1] & /*onconnect, ondisconnect, $edges, $connectionLookup*/
    1560) {
      $: if (onconnect || ondisconnect) {
        $edges;
        $$invalidate(37, connections = $connectionLookup.get(`${nodeId}-${type}-${id2 || null}`));
      }
    }
    if ($$self.$$.dirty[1] & /*prevConnections, connections, ondisconnect, onconnect*/
    120) {
      $: {
        if (prevConnections && !areConnectionMapsEqual(connections, prevConnections)) {
          const _connections = connections ?? /* @__PURE__ */ new Map();
          handleConnectionChange(prevConnections, _connections, ondisconnect);
          handleConnectionChange(_connections, prevConnections, onconnect);
        }
        $$invalidate(36, prevConnections = connections ?? /* @__PURE__ */ new Map());
      }
    }
    if ($$self.$$.dirty[1] & /*$connection*/
    128) {
      $: $$invalidate(11, connectionInProcess = !!$connection.fromHandle);
    }
    if ($$self.$$.dirty[0] & /*type, handleId*/
    132 | $$self.$$.dirty[1] & /*$connection*/
    128) {
      $: $$invalidate(10, connectingFrom = ((_a = $connection.fromHandle) == null ? void 0 : _a.nodeId) === nodeId && ((_b = $connection.fromHandle) == null ? void 0 : _b.type) === type && ((_c = $connection.fromHandle) == null ? void 0 : _c.id) === handleId);
    }
    if ($$self.$$.dirty[0] & /*type, handleId*/
    132 | $$self.$$.dirty[1] & /*$connection*/
    128) {
      $: $$invalidate(6, connectingTo = ((_d = $connection.toHandle) == null ? void 0 : _d.nodeId) === nodeId && ((_e = $connection.toHandle) == null ? void 0 : _e.type) === type && ((_f = $connection.toHandle) == null ? void 0 : _f.id) === handleId);
    }
    if ($$self.$$.dirty[0] & /*type, handleId*/
    132 | $$self.$$.dirty[1] & /*$connectionMode, $connection*/
    384) {
      $: $$invalidate(9, isPossibleEndHandle = $connectionMode === ConnectionMode.Strict ? ((_g = $connection.fromHandle) == null ? void 0 : _g.type) !== type : nodeId !== ((_h = $connection.fromHandle) == null ? void 0 : _h.nodeId) || handleId !== ((_i = $connection.fromHandle) == null ? void 0 : _i.id));
    }
    if ($$self.$$.dirty[0] & /*connectingTo*/
    64 | $$self.$$.dirty[1] & /*$connection*/
    128) {
      $: $$invalidate(8, valid = connectingTo && $connection.isValid);
    }
  };
  return [
    isConnectable,
    id2,
    type,
    position,
    style,
    className,
    connectingTo,
    handleId,
    valid,
    isPossibleEndHandle,
    connectingFrom,
    connectionInProcess,
    isTarget,
    $flowId,
    nodeId,
    connectable,
    connectionMode,
    domNode,
    nodeLookup,
    connectionRadius,
    viewport,
    isValidConnectionStore,
    lib,
    onedgecreate,
    autoPanOnConnect,
    edges,
    connectionLookup,
    onConnectAction,
    onConnectStartAction,
    onConnectEndAction,
    flowId,
    connection,
    onPointerDown2,
    isValidConnection,
    onconnect,
    ondisconnect,
    prevConnections,
    connections,
    $connection,
    $connectionMode,
    $connectionLookup,
    $edges,
    $connectable,
    $$scope,
    slots
  ];
}
var Handle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        id: 1,
        type: 2,
        position: 3,
        style: 4,
        isConnectable: 0,
        isValidConnection: 33,
        onconnect: 34,
        ondisconnect: 35,
        class: 5
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Handle",
      options,
      id: create_fragment.name
    });
  }
  get id() {
    throw new Error("<Handle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Handle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Handle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Handle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Handle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Handle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Handle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Handle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isConnectable() {
    throw new Error("<Handle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isConnectable(value) {
    throw new Error("<Handle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isValidConnection() {
    throw new Error("<Handle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isValidConnection(value) {
    throw new Error("<Handle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onconnect() {
    throw new Error("<Handle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onconnect(value) {
    throw new Error("<Handle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ondisconnect() {
    throw new Error("<Handle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ondisconnect(value) {
    throw new Error("<Handle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Handle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Handle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Handle_default = Handle;

// node_modules/@xyflow/svelte/dist/lib/components/nodes/DefaultNode.svelte
function create_fragment2(ctx) {
  var _a;
  let handle0;
  let t02;
  let t1_value = (
    /*data*/
    ((_a = ctx[0]) == null ? void 0 : _a.label) + ""
  );
  let t12;
  let t22;
  let handle1;
  let current;
  handle0 = new Handle_default({
    props: {
      type: "target",
      position: (
        /*targetPosition*/
        ctx[1] ?? Position.Top
      )
    },
    $$inline: true
  });
  handle1 = new Handle_default({
    props: {
      type: "source",
      position: (
        /*sourcePosition*/
        ctx[2] ?? Position.Bottom
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(handle0.$$.fragment);
      t02 = space();
      t12 = text(t1_value);
      t22 = space();
      create_component(handle1.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(handle0, target, anchor);
      insert_dev(target, t02, anchor);
      insert_dev(target, t12, anchor);
      insert_dev(target, t22, anchor);
      mount_component(handle1, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      var _a2;
      const handle0_changes = {};
      if (dirty & /*targetPosition*/
      2) handle0_changes.position = /*targetPosition*/
      ctx2[1] ?? Position.Top;
      handle0.$set(handle0_changes);
      if ((!current || dirty & /*data*/
      1) && t1_value !== (t1_value = /*data*/
      ((_a2 = ctx2[0]) == null ? void 0 : _a2.label) + "")) set_data_dev(t12, t1_value);
      const handle1_changes = {};
      if (dirty & /*sourcePosition*/
      4) handle1_changes.position = /*sourcePosition*/
      ctx2[2] ?? Position.Bottom;
      handle1.$set(handle1_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(handle0.$$.fragment, local2);
      transition_in(handle1.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(handle0.$$.fragment, local2);
      transition_out(handle1.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t02);
        detach_dev(t12);
        detach_dev(t22);
      }
      destroy_component(handle0, detaching);
      destroy_component(handle1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = ["data", "targetPosition", "sourcePosition"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DefaultNode", slots, []);
  let { data = { label: "Node" } } = $$props;
  let { targetPosition = void 0 } = $$props;
  let { sourcePosition = void 0 } = $$props;
  $$restProps;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("data" in $$new_props) $$invalidate(0, data = $$new_props.data);
    if ("targetPosition" in $$new_props) $$invalidate(1, targetPosition = $$new_props.targetPosition);
    if ("sourcePosition" in $$new_props) $$invalidate(2, sourcePosition = $$new_props.sourcePosition);
  };
  $$self.$capture_state = () => ({
    Position,
    Handle: Handle_default,
    data,
    targetPosition,
    sourcePosition
  });
  $$self.$inject_state = ($$new_props) => {
    if ("data" in $$props) $$invalidate(0, data = $$new_props.data);
    if ("targetPosition" in $$props) $$invalidate(1, targetPosition = $$new_props.targetPosition);
    if ("sourcePosition" in $$props) $$invalidate(2, sourcePosition = $$new_props.sourcePosition);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [data, targetPosition, sourcePosition];
}
var DefaultNode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      data: 0,
      targetPosition: 1,
      sourcePosition: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DefaultNode",
      options,
      id: create_fragment2.name
    });
  }
  get data() {
    throw new Error("<DefaultNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<DefaultNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<DefaultNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<DefaultNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<DefaultNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<DefaultNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DefaultNode_default = DefaultNode;

// node_modules/@xyflow/svelte/dist/lib/components/nodes/InputNode.svelte
function create_fragment3(ctx) {
  var _a;
  let t0_value = (
    /*data*/
    ((_a = ctx[0]) == null ? void 0 : _a.label) + ""
  );
  let t02;
  let t12;
  let handle;
  let current;
  handle = new Handle_default({
    props: {
      type: "source",
      position: (
        /*sourcePosition*/
        ctx[1] ?? Position.Bottom
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      t02 = text(t0_value);
      t12 = space();
      create_component(handle.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t02, anchor);
      insert_dev(target, t12, anchor);
      mount_component(handle, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      var _a2;
      if ((!current || dirty & /*data*/
      1) && t0_value !== (t0_value = /*data*/
      ((_a2 = ctx2[0]) == null ? void 0 : _a2.label) + "")) set_data_dev(t02, t0_value);
      const handle_changes = {};
      if (dirty & /*sourcePosition*/
      2) handle_changes.position = /*sourcePosition*/
      ctx2[1] ?? Position.Bottom;
      handle.$set(handle_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(handle.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(handle.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t02);
        detach_dev(t12);
      }
      destroy_component(handle, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = ["data", "sourcePosition"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InputNode", slots, []);
  let { data = { label: "Node" } } = $$props;
  let { sourcePosition = void 0 } = $$props;
  $$restProps;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("data" in $$new_props) $$invalidate(0, data = $$new_props.data);
    if ("sourcePosition" in $$new_props) $$invalidate(1, sourcePosition = $$new_props.sourcePosition);
  };
  $$self.$capture_state = () => ({ Position, Handle: Handle_default, data, sourcePosition });
  $$self.$inject_state = ($$new_props) => {
    if ("data" in $$props) $$invalidate(0, data = $$new_props.data);
    if ("sourcePosition" in $$props) $$invalidate(1, sourcePosition = $$new_props.sourcePosition);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [data, sourcePosition];
}
var InputNode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { data: 0, sourcePosition: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputNode",
      options,
      id: create_fragment3.name
    });
  }
  get data() {
    throw new Error("<InputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<InputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<InputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<InputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputNode_default = InputNode;

// node_modules/@xyflow/svelte/dist/lib/components/nodes/OutputNode.svelte
function create_fragment4(ctx) {
  var _a;
  let t0_value = (
    /*data*/
    ((_a = ctx[0]) == null ? void 0 : _a.label) + ""
  );
  let t02;
  let t12;
  let handle;
  let current;
  handle = new Handle_default({
    props: {
      type: "target",
      position: (
        /*targetPosition*/
        ctx[1] ?? Position.Top
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      t02 = text(t0_value);
      t12 = space();
      create_component(handle.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t02, anchor);
      insert_dev(target, t12, anchor);
      mount_component(handle, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      var _a2;
      if ((!current || dirty & /*data*/
      1) && t0_value !== (t0_value = /*data*/
      ((_a2 = ctx2[0]) == null ? void 0 : _a2.label) + "")) set_data_dev(t02, t0_value);
      const handle_changes = {};
      if (dirty & /*targetPosition*/
      2) handle_changes.position = /*targetPosition*/
      ctx2[1] ?? Position.Top;
      handle.$set(handle_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(handle.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(handle.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t02);
        detach_dev(t12);
      }
      destroy_component(handle, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  const omit_props_names = ["data", "targetPosition"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OutputNode", slots, []);
  let { data = { label: "Node" } } = $$props;
  let { targetPosition = void 0 } = $$props;
  $$restProps;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("data" in $$new_props) $$invalidate(0, data = $$new_props.data);
    if ("targetPosition" in $$new_props) $$invalidate(1, targetPosition = $$new_props.targetPosition);
  };
  $$self.$capture_state = () => ({ Position, Handle: Handle_default, data, targetPosition });
  $$self.$inject_state = ($$new_props) => {
    if ("data" in $$props) $$invalidate(0, data = $$new_props.data);
    if ("targetPosition" in $$props) $$invalidate(1, targetPosition = $$new_props.targetPosition);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [data, targetPosition];
}
var OutputNode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { data: 0, targetPosition: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OutputNode",
      options,
      id: create_fragment4.name
    });
  }
  get data() {
    throw new Error("<OutputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<OutputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<OutputNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<OutputNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OutputNode_default = OutputNode;

// node_modules/@xyflow/svelte/dist/lib/components/nodes/GroupNode.svelte
function create_fragment5(ctx) {
  const block = {
    c: noop,
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GroupNode", slots, []);
  $$restProps;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [];
}
var GroupNode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GroupNode",
      options,
      id: create_fragment5.name
    });
  }
};
var GroupNode_default = GroupNode;

// node_modules/@xyflow/svelte/dist/lib/actions/portal/index.js
function tryToMount(node, domNode, target) {
  if (!domNode) {
    return;
  }
  const targetEl = target ? domNode.querySelector(target) : domNode;
  if (targetEl) {
    targetEl.appendChild(node);
  }
}
function portal_default(node, { target, domNode }) {
  tryToMount(node, domNode, target);
  return {
    async update({ target: target2, domNode: domNode2 }) {
      tryToMount(node, domNode2, target2);
    },
    destroy() {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/components/EdgeLabelRenderer/EdgeLabelRenderer.svelte
var file2 = "node_modules/@xyflow/svelte/dist/lib/components/EdgeLabelRenderer/EdgeLabelRenderer.svelte";
function create_fragment6(ctx) {
  let div;
  let portal_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create2() {
      div = element("div");
      if (default_slot) default_slot.c();
      add_location(div, file2, 5, 0, 134);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(portal_action = portal_default.call(null, div, {
          target: ".svelte-flow__edgelabel-renderer",
          domNode: (
            /*$domNode*/
            ctx[0]
          )
        }));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (portal_action && is_function(portal_action.update) && dirty & /*$domNode*/
      1) portal_action.update.call(null, {
        target: ".svelte-flow__edgelabel-renderer",
        domNode: (
          /*$domNode*/
          ctx2[0]
        )
      });
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(default_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(default_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let $domNode;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EdgeLabelRenderer", slots, ["default"]);
  const { domNode } = useStore();
  validate_store(domNode, "domNode");
  component_subscribe($$self, domNode, (value) => $$invalidate(0, $domNode = value));
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<EdgeLabelRenderer> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ portal: portal_default, useStore, domNode, $domNode });
  return [$domNode, domNode, $$scope, slots];
}
var EdgeLabelRenderer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EdgeLabelRenderer",
      options,
      id: create_fragment6.name
    });
  }
};
var EdgeLabelRenderer_default = EdgeLabelRenderer;

// node_modules/@xyflow/svelte/dist/lib/hooks/useHandleEdgeSelect.js
function useHandleEdgeSelect() {
  const { edgeLookup, selectionRect, selectionRectMode, multiselectionKeyPressed, addSelectedEdges, unselectNodesAndEdges, elementsSelectable } = useStore();
  return (id2) => {
    const edge = get_store_value(edgeLookup).get(id2);
    if (!edge) {
      console.warn("012", errorMessages["error012"](id2));
      return;
    }
    const selectable = edge.selectable || get_store_value(elementsSelectable) && typeof edge.selectable === "undefined";
    if (selectable) {
      selectionRect.set(null);
      selectionRectMode.set(null);
      if (!edge.selected) {
        addSelectedEdges([id2]);
      } else if (edge.selected && get_store_value(multiselectionKeyPressed)) {
        unselectNodesAndEdges({ nodes: [], edges: [edge] });
      }
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/components/EdgeLabel/EdgeLabel.svelte
var file3 = "node_modules/@xyflow/svelte/dist/lib/components/EdgeLabel/EdgeLabel.svelte";
function create_default_slot(ctx) {
  let div;
  let div_style_value;
  let style_transform = `translate(-50%, -50%) translate(${/*x*/
  ctx[1]}px,${/*y*/
  ctx[2]}px)`;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  const block = {
    c: function create2() {
      div = element("div");
      if (default_slot) default_slot.c();
      attr_dev(div, "class", "svelte-flow__edge-label");
      attr_dev(div, "style", div_style_value = "pointer-events: all;" + /*style*/
      ctx[0]);
      attr_dev(div, "role", "button");
      attr_dev(div, "tabindex", "-1");
      set_style(div, "transform", style_transform);
      add_location(div, file3, 11, 2, 383);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "keyup", keyup_handler, false, false, false, false),
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*style*/
      1 && div_style_value !== (div_style_value = "pointer-events: all;" + /*style*/
      ctx2[0])) {
        attr_dev(div, "style", div_style_value);
      }
      const style_changed = dirty & /*style*/
      1;
      if (dirty & /*x, y, style*/
      7 && style_transform !== (style_transform = `translate(-50%, -50%) translate(${/*x*/
      ctx2[1]}px,${/*y*/
      ctx2[2]}px)`) || style_changed) {
        set_style(div, "transform", style_transform);
      }
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(default_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(default_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(11:0) <EdgeLabelRenderer>",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let edgelabelrenderer;
  let current;
  edgelabelrenderer = new EdgeLabelRenderer_default({
    props: {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(edgelabelrenderer.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(edgelabelrenderer, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const edgelabelrenderer_changes = {};
      if (dirty & /*$$scope, style, x, y*/
      135) {
        edgelabelrenderer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      edgelabelrenderer.$set(edgelabelrenderer_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(edgelabelrenderer.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(edgelabelrenderer.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(edgelabelrenderer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var keyup_handler = () => {
};
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EdgeLabel", slots, ["default"]);
  let { style = void 0 } = $$props;
  let { x = void 0 } = $$props;
  let { y = void 0 } = $$props;
  const handleEdgeSelect = useHandleEdgeSelect();
  const id2 = getContext("svelteflow__edge_id");
  const writable_props = ["style", "x", "y"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<EdgeLabel> was created with unknown prop '${key2}'`);
  });
  const click_handler = () => {
    if (id2) handleEdgeSelect(id2);
  };
  $$self.$$set = ($$props2) => {
    if ("style" in $$props2) $$invalidate(0, style = $$props2.style);
    if ("x" in $$props2) $$invalidate(1, x = $$props2.x);
    if ("y" in $$props2) $$invalidate(2, y = $$props2.y);
    if ("$$scope" in $$props2) $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    EdgeLabelRenderer: EdgeLabelRenderer_default,
    useHandleEdgeSelect,
    style,
    x,
    y,
    handleEdgeSelect,
    id: id2
  });
  $$self.$inject_state = ($$props2) => {
    if ("style" in $$props2) $$invalidate(0, style = $$props2.style);
    if ("x" in $$props2) $$invalidate(1, x = $$props2.x);
    if ("y" in $$props2) $$invalidate(2, y = $$props2.y);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [style, x, y, handleEdgeSelect, id2, slots, click_handler, $$scope];
}
var EdgeLabel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { style: 0, x: 1, y: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EdgeLabel",
      options,
      id: create_fragment7.name
    });
  }
  get style() {
    throw new Error("<EdgeLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<EdgeLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x() {
    throw new Error("<EdgeLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<EdgeLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<EdgeLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<EdgeLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var EdgeLabel_default = EdgeLabel;

// node_modules/@xyflow/svelte/dist/lib/components/BaseEdge/BaseEdge.svelte
var file4 = "node_modules/@xyflow/svelte/dist/lib/components/BaseEdge/BaseEdge.svelte";
function create_if_block_1(ctx) {
  let path_1;
  let path_1_stroke_opacity_value;
  const block = {
    c: function create2() {
      path_1 = svg_element("path");
      attr_dev(
        path_1,
        "d",
        /*path*/
        ctx[1]
      );
      attr_dev(path_1, "stroke-opacity", path_1_stroke_opacity_value = 0);
      attr_dev(
        path_1,
        "stroke-width",
        /*interactionWidthValue*/
        ctx[10]
      );
      attr_dev(path_1, "fill", "none");
      attr_dev(path_1, "class", "svelte-flow__edge-interaction");
      add_location(path_1, file4, 28, 2, 736);
    },
    m: function mount(target, anchor) {
      insert_dev(target, path_1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*path*/
      2) {
        attr_dev(
          path_1,
          "d",
          /*path*/
          ctx2[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(28:0) {#if interactionWidthValue}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let edgelabel;
  let current;
  edgelabel = new EdgeLabel_default({
    props: {
      x: (
        /*labelX*/
        ctx[3]
      ),
      y: (
        /*labelY*/
        ctx[4]
      ),
      style: (
        /*labelStyle*/
        ctx[5]
      ),
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(edgelabel.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(edgelabel, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const edgelabel_changes = {};
      if (dirty & /*labelX*/
      8) edgelabel_changes.x = /*labelX*/
      ctx2[3];
      if (dirty & /*labelY*/
      16) edgelabel_changes.y = /*labelY*/
      ctx2[4];
      if (dirty & /*labelStyle*/
      32) edgelabel_changes.style = /*labelStyle*/
      ctx2[5];
      if (dirty & /*$$scope, label*/
      4100) {
        edgelabel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      edgelabel.$set(edgelabel_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(edgelabel.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(edgelabel.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(edgelabel, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(38:0) {#if label}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let t;
  const block = {
    c: function create2() {
      t = text(
        /*label*/
        ctx[2]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*label*/
      4) set_data_dev(
        t,
        /*label*/
        ctx2[2]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(39:2) <EdgeLabel x={labelX} y={labelY} style={labelStyle}>",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let path_1;
  let path_1_class_value;
  let t02;
  let t12;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*interactionWidthValue*/
    ctx[10] && create_if_block_1(ctx)
  );
  let if_block1 = (
    /*label*/
    ctx[2] && create_if_block(ctx)
  );
  const block = {
    c: function create2() {
      path_1 = svg_element("path");
      t02 = space();
      if (if_block0) if_block0.c();
      t12 = space();
      if (if_block1) if_block1.c();
      if_block1_anchor = empty();
      attr_dev(
        path_1,
        "id",
        /*id*/
        ctx[0]
      );
      attr_dev(
        path_1,
        "d",
        /*path*/
        ctx[1]
      );
      attr_dev(path_1, "class", path_1_class_value = cc([
        "svelte-flow__edge-path",
        /*className*/
        ctx[9]
      ]));
      attr_dev(
        path_1,
        "marker-start",
        /*markerStart*/
        ctx[6]
      );
      attr_dev(
        path_1,
        "marker-end",
        /*markerEnd*/
        ctx[7]
      );
      attr_dev(path_1, "fill", "none");
      attr_dev(
        path_1,
        "style",
        /*style*/
        ctx[8]
      );
      add_location(path_1, file4, 17, 0, 548);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, path_1, anchor);
      insert_dev(target, t02, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert_dev(target, t12, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*id*/
      1) {
        attr_dev(
          path_1,
          "id",
          /*id*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*path*/
      2) {
        attr_dev(
          path_1,
          "d",
          /*path*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*className*/
      512 && path_1_class_value !== (path_1_class_value = cc([
        "svelte-flow__edge-path",
        /*className*/
        ctx2[9]
      ]))) {
        attr_dev(path_1, "class", path_1_class_value);
      }
      if (!current || dirty & /*markerStart*/
      64) {
        attr_dev(
          path_1,
          "marker-start",
          /*markerStart*/
          ctx2[6]
        );
      }
      if (!current || dirty & /*markerEnd*/
      128) {
        attr_dev(
          path_1,
          "marker-end",
          /*markerEnd*/
          ctx2[7]
        );
      }
      if (!current || dirty & /*style*/
      256) {
        attr_dev(
          path_1,
          "style",
          /*style*/
          ctx2[8]
        );
      }
      if (
        /*interactionWidthValue*/
        ctx2[10]
      ) if_block0.p(ctx2, dirty);
      if (
        /*label*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*label*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path_1);
        detach_dev(t02);
        detach_dev(t12);
        detach_dev(if_block1_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BaseEdge", slots, []);
  let { id: id2 = void 0 } = $$props;
  let { path } = $$props;
  let { label = void 0 } = $$props;
  let { labelX = void 0 } = $$props;
  let { labelY = void 0 } = $$props;
  let { labelStyle = void 0 } = $$props;
  let { markerStart = void 0 } = $$props;
  let { markerEnd = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { interactionWidth = 20 } = $$props;
  let { class: className = void 0 } = $$props;
  let interactionWidthValue = interactionWidth === void 0 ? 20 : interactionWidth;
  $$self.$$.on_mount.push(function() {
    if (path === void 0 && !("path" in $$props || $$self.$$.bound[$$self.$$.props["path"]])) {
      console.warn("<BaseEdge> was created without expected prop 'path'");
    }
  });
  const writable_props = [
    "id",
    "path",
    "label",
    "labelX",
    "labelY",
    "labelStyle",
    "markerStart",
    "markerEnd",
    "style",
    "interactionWidth",
    "class"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<BaseEdge> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id2 = $$props2.id);
    if ("path" in $$props2) $$invalidate(1, path = $$props2.path);
    if ("label" in $$props2) $$invalidate(2, label = $$props2.label);
    if ("labelX" in $$props2) $$invalidate(3, labelX = $$props2.labelX);
    if ("labelY" in $$props2) $$invalidate(4, labelY = $$props2.labelY);
    if ("labelStyle" in $$props2) $$invalidate(5, labelStyle = $$props2.labelStyle);
    if ("markerStart" in $$props2) $$invalidate(6, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2) $$invalidate(7, markerEnd = $$props2.markerEnd);
    if ("style" in $$props2) $$invalidate(8, style = $$props2.style);
    if ("interactionWidth" in $$props2) $$invalidate(11, interactionWidth = $$props2.interactionWidth);
    if ("class" in $$props2) $$invalidate(9, className = $$props2.class);
  };
  $$self.$capture_state = () => ({
    cc,
    EdgeLabel: EdgeLabel_default,
    id: id2,
    path,
    label,
    labelX,
    labelY,
    labelStyle,
    markerStart,
    markerEnd,
    style,
    interactionWidth,
    className,
    interactionWidthValue
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id2 = $$props2.id);
    if ("path" in $$props2) $$invalidate(1, path = $$props2.path);
    if ("label" in $$props2) $$invalidate(2, label = $$props2.label);
    if ("labelX" in $$props2) $$invalidate(3, labelX = $$props2.labelX);
    if ("labelY" in $$props2) $$invalidate(4, labelY = $$props2.labelY);
    if ("labelStyle" in $$props2) $$invalidate(5, labelStyle = $$props2.labelStyle);
    if ("markerStart" in $$props2) $$invalidate(6, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2) $$invalidate(7, markerEnd = $$props2.markerEnd);
    if ("style" in $$props2) $$invalidate(8, style = $$props2.style);
    if ("interactionWidth" in $$props2) $$invalidate(11, interactionWidth = $$props2.interactionWidth);
    if ("className" in $$props2) $$invalidate(9, className = $$props2.className);
    if ("interactionWidthValue" in $$props2) $$invalidate(10, interactionWidthValue = $$props2.interactionWidthValue);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    id2,
    path,
    label,
    labelX,
    labelY,
    labelStyle,
    markerStart,
    markerEnd,
    style,
    className,
    interactionWidthValue,
    interactionWidth
  ];
}
var BaseEdge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      id: 0,
      path: 1,
      label: 2,
      labelX: 3,
      labelY: 4,
      labelStyle: 5,
      markerStart: 6,
      markerEnd: 7,
      style: 8,
      interactionWidth: 11,
      class: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BaseEdge",
      options,
      id: create_fragment8.name
    });
  }
  get id() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get path() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set path(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelX() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelX(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelY() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelY(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelStyle() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelStyle(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerStart() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerStart(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerEnd() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerEnd(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactionWidth() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactionWidth(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BaseEdge_default = BaseEdge;

// node_modules/@xyflow/svelte/dist/lib/components/edges/BezierEdge.svelte
function create_fragment9(ctx) {
  let baseedge;
  let current;
  baseedge = new BaseEdge_default({
    props: {
      id: (
        /*id*/
        ctx[0]
      ),
      path: (
        /*path*/
        ctx[9]
      ),
      labelX: (
        /*labelX*/
        ctx[8]
      ),
      labelY: (
        /*labelY*/
        ctx[7]
      ),
      label: (
        /*label*/
        ctx[1]
      ),
      labelStyle: (
        /*labelStyle*/
        ctx[2]
      ),
      markerStart: (
        /*markerStart*/
        ctx[4]
      ),
      markerEnd: (
        /*markerEnd*/
        ctx[5]
      ),
      interactionWidth: (
        /*interactionWidth*/
        ctx[6]
      ),
      style: (
        /*style*/
        ctx[3]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(baseedge.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(baseedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const baseedge_changes = {};
      if (dirty & /*id*/
      1) baseedge_changes.id = /*id*/
      ctx2[0];
      if (dirty & /*path*/
      512) baseedge_changes.path = /*path*/
      ctx2[9];
      if (dirty & /*labelX*/
      256) baseedge_changes.labelX = /*labelX*/
      ctx2[8];
      if (dirty & /*labelY*/
      128) baseedge_changes.labelY = /*labelY*/
      ctx2[7];
      if (dirty & /*label*/
      2) baseedge_changes.label = /*label*/
      ctx2[1];
      if (dirty & /*labelStyle*/
      4) baseedge_changes.labelStyle = /*labelStyle*/
      ctx2[2];
      if (dirty & /*markerStart*/
      16) baseedge_changes.markerStart = /*markerStart*/
      ctx2[4];
      if (dirty & /*markerEnd*/
      32) baseedge_changes.markerEnd = /*markerEnd*/
      ctx2[5];
      if (dirty & /*interactionWidth*/
      64) baseedge_changes.interactionWidth = /*interactionWidth*/
      ctx2[6];
      if (dirty & /*style*/
      8) baseedge_changes.style = /*style*/
      ctx2[3];
      baseedge.$set(baseedge_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(baseedge.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(baseedge.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(baseedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let path;
  let labelX;
  let labelY;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BezierEdge", slots, []);
  let { id: id2 = void 0 } = $$props;
  let { label = void 0 } = $$props;
  let { labelStyle = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { markerStart = void 0 } = $$props;
  let { markerEnd = void 0 } = $$props;
  let { pathOptions = void 0 } = $$props;
  let { interactionWidth = void 0 } = $$props;
  let { sourceX } = $$props;
  let { sourceY } = $$props;
  let { sourcePosition } = $$props;
  let { targetX } = $$props;
  let { targetY } = $$props;
  let { targetPosition } = $$props;
  $$self.$$.on_mount.push(function() {
    if (sourceX === void 0 && !("sourceX" in $$props || $$self.$$.bound[$$self.$$.props["sourceX"]])) {
      console.warn("<BezierEdge> was created without expected prop 'sourceX'");
    }
    if (sourceY === void 0 && !("sourceY" in $$props || $$self.$$.bound[$$self.$$.props["sourceY"]])) {
      console.warn("<BezierEdge> was created without expected prop 'sourceY'");
    }
    if (sourcePosition === void 0 && !("sourcePosition" in $$props || $$self.$$.bound[$$self.$$.props["sourcePosition"]])) {
      console.warn("<BezierEdge> was created without expected prop 'sourcePosition'");
    }
    if (targetX === void 0 && !("targetX" in $$props || $$self.$$.bound[$$self.$$.props["targetX"]])) {
      console.warn("<BezierEdge> was created without expected prop 'targetX'");
    }
    if (targetY === void 0 && !("targetY" in $$props || $$self.$$.bound[$$self.$$.props["targetY"]])) {
      console.warn("<BezierEdge> was created without expected prop 'targetY'");
    }
    if (targetPosition === void 0 && !("targetPosition" in $$props || $$self.$$.bound[$$self.$$.props["targetPosition"]])) {
      console.warn("<BezierEdge> was created without expected prop 'targetPosition'");
    }
  });
  const writable_props = [
    "id",
    "label",
    "labelStyle",
    "style",
    "markerStart",
    "markerEnd",
    "pathOptions",
    "interactionWidth",
    "sourceX",
    "sourceY",
    "sourcePosition",
    "targetX",
    "targetY",
    "targetPosition"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<BezierEdge> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id2 = $$props2.id);
    if ("label" in $$props2) $$invalidate(1, label = $$props2.label);
    if ("labelStyle" in $$props2) $$invalidate(2, labelStyle = $$props2.labelStyle);
    if ("style" in $$props2) $$invalidate(3, style = $$props2.style);
    if ("markerStart" in $$props2) $$invalidate(4, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2) $$invalidate(5, markerEnd = $$props2.markerEnd);
    if ("pathOptions" in $$props2) $$invalidate(10, pathOptions = $$props2.pathOptions);
    if ("interactionWidth" in $$props2) $$invalidate(6, interactionWidth = $$props2.interactionWidth);
    if ("sourceX" in $$props2) $$invalidate(11, sourceX = $$props2.sourceX);
    if ("sourceY" in $$props2) $$invalidate(12, sourceY = $$props2.sourceY);
    if ("sourcePosition" in $$props2) $$invalidate(13, sourcePosition = $$props2.sourcePosition);
    if ("targetX" in $$props2) $$invalidate(14, targetX = $$props2.targetX);
    if ("targetY" in $$props2) $$invalidate(15, targetY = $$props2.targetY);
    if ("targetPosition" in $$props2) $$invalidate(16, targetPosition = $$props2.targetPosition);
  };
  $$self.$capture_state = () => ({
    getBezierPath,
    BaseEdge: BaseEdge_default,
    id: id2,
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    pathOptions,
    interactionWidth,
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
    labelY,
    labelX,
    path
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id2 = $$props2.id);
    if ("label" in $$props2) $$invalidate(1, label = $$props2.label);
    if ("labelStyle" in $$props2) $$invalidate(2, labelStyle = $$props2.labelStyle);
    if ("style" in $$props2) $$invalidate(3, style = $$props2.style);
    if ("markerStart" in $$props2) $$invalidate(4, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2) $$invalidate(5, markerEnd = $$props2.markerEnd);
    if ("pathOptions" in $$props2) $$invalidate(10, pathOptions = $$props2.pathOptions);
    if ("interactionWidth" in $$props2) $$invalidate(6, interactionWidth = $$props2.interactionWidth);
    if ("sourceX" in $$props2) $$invalidate(11, sourceX = $$props2.sourceX);
    if ("sourceY" in $$props2) $$invalidate(12, sourceY = $$props2.sourceY);
    if ("sourcePosition" in $$props2) $$invalidate(13, sourcePosition = $$props2.sourcePosition);
    if ("targetX" in $$props2) $$invalidate(14, targetX = $$props2.targetX);
    if ("targetY" in $$props2) $$invalidate(15, targetY = $$props2.targetY);
    if ("targetPosition" in $$props2) $$invalidate(16, targetPosition = $$props2.targetPosition);
    if ("labelY" in $$props2) $$invalidate(7, labelY = $$props2.labelY);
    if ("labelX" in $$props2) $$invalidate(8, labelX = $$props2.labelX);
    if ("path" in $$props2) $$invalidate(9, path = $$props2.path);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, pathOptions*/
    130048) {
      $: $$invalidate(
        9,
        [path, labelX, labelY] = getBezierPath({
          sourceX,
          sourceY,
          targetX,
          targetY,
          sourcePosition,
          targetPosition,
          curvature: pathOptions == null ? void 0 : pathOptions.curvature
        }),
        path,
        ($$invalidate(8, labelX), $$invalidate(11, sourceX), $$invalidate(12, sourceY), $$invalidate(14, targetX), $$invalidate(15, targetY), $$invalidate(13, sourcePosition), $$invalidate(16, targetPosition), $$invalidate(10, pathOptions)),
        ($$invalidate(7, labelY), $$invalidate(11, sourceX), $$invalidate(12, sourceY), $$invalidate(14, targetX), $$invalidate(15, targetY), $$invalidate(13, sourcePosition), $$invalidate(16, targetPosition), $$invalidate(10, pathOptions))
      );
    }
  };
  return [
    id2,
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    labelY,
    labelX,
    path,
    pathOptions,
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition
  ];
}
var BezierEdge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      id: 0,
      label: 1,
      labelStyle: 2,
      style: 3,
      markerStart: 4,
      markerEnd: 5,
      pathOptions: 10,
      interactionWidth: 6,
      sourceX: 11,
      sourceY: 12,
      sourcePosition: 13,
      targetX: 14,
      targetY: 15,
      targetPosition: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BezierEdge",
      options,
      id: create_fragment9.name
    });
  }
  get id() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelStyle() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelStyle(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerStart() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerStart(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerEnd() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerEnd(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pathOptions() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pathOptions(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactionWidth() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactionWidth(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceX() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceX(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceY() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceY(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetX() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetX(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetY() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetY(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<BezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<BezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BezierEdge_default = BezierEdge;

// node_modules/@xyflow/svelte/dist/lib/components/edges/BezierEdgeInternal.svelte
function create_fragment10(ctx) {
  let baseedge;
  let current;
  baseedge = new BaseEdge_default({
    props: {
      path: (
        /*path*/
        ctx[8]
      ),
      labelX: (
        /*labelX*/
        ctx[7]
      ),
      labelY: (
        /*labelY*/
        ctx[6]
      ),
      label: (
        /*label*/
        ctx[0]
      ),
      labelStyle: (
        /*labelStyle*/
        ctx[1]
      ),
      markerStart: (
        /*markerStart*/
        ctx[3]
      ),
      markerEnd: (
        /*markerEnd*/
        ctx[4]
      ),
      interactionWidth: (
        /*interactionWidth*/
        ctx[5]
      ),
      style: (
        /*style*/
        ctx[2]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(baseedge.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(baseedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const baseedge_changes = {};
      if (dirty & /*path*/
      256) baseedge_changes.path = /*path*/
      ctx2[8];
      if (dirty & /*labelX*/
      128) baseedge_changes.labelX = /*labelX*/
      ctx2[7];
      if (dirty & /*labelY*/
      64) baseedge_changes.labelY = /*labelY*/
      ctx2[6];
      if (dirty & /*label*/
      1) baseedge_changes.label = /*label*/
      ctx2[0];
      if (dirty & /*labelStyle*/
      2) baseedge_changes.labelStyle = /*labelStyle*/
      ctx2[1];
      if (dirty & /*markerStart*/
      8) baseedge_changes.markerStart = /*markerStart*/
      ctx2[3];
      if (dirty & /*markerEnd*/
      16) baseedge_changes.markerEnd = /*markerEnd*/
      ctx2[4];
      if (dirty & /*interactionWidth*/
      32) baseedge_changes.interactionWidth = /*interactionWidth*/
      ctx2[5];
      if (dirty & /*style*/
      4) baseedge_changes.style = /*style*/
      ctx2[2];
      baseedge.$set(baseedge_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(baseedge.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(baseedge.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(baseedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let path;
  let labelX;
  let labelY;
  const omit_props_names = [
    "label",
    "labelStyle",
    "style",
    "markerStart",
    "markerEnd",
    "interactionWidth",
    "sourceX",
    "sourceY",
    "sourcePosition",
    "targetX",
    "targetY",
    "targetPosition"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BezierEdgeInternal", slots, []);
  let { label = void 0 } = $$props;
  let { labelStyle = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { markerStart = void 0 } = $$props;
  let { markerEnd = void 0 } = $$props;
  let { interactionWidth = void 0 } = $$props;
  let { sourceX } = $$props;
  let { sourceY } = $$props;
  let { sourcePosition } = $$props;
  let { targetX } = $$props;
  let { targetY } = $$props;
  let { targetPosition } = $$props;
  $$restProps;
  $$self.$$.on_mount.push(function() {
    if (sourceX === void 0 && !("sourceX" in $$props || $$self.$$.bound[$$self.$$.props["sourceX"]])) {
      console.warn("<BezierEdgeInternal> was created without expected prop 'sourceX'");
    }
    if (sourceY === void 0 && !("sourceY" in $$props || $$self.$$.bound[$$self.$$.props["sourceY"]])) {
      console.warn("<BezierEdgeInternal> was created without expected prop 'sourceY'");
    }
    if (sourcePosition === void 0 && !("sourcePosition" in $$props || $$self.$$.bound[$$self.$$.props["sourcePosition"]])) {
      console.warn("<BezierEdgeInternal> was created without expected prop 'sourcePosition'");
    }
    if (targetX === void 0 && !("targetX" in $$props || $$self.$$.bound[$$self.$$.props["targetX"]])) {
      console.warn("<BezierEdgeInternal> was created without expected prop 'targetX'");
    }
    if (targetY === void 0 && !("targetY" in $$props || $$self.$$.bound[$$self.$$.props["targetY"]])) {
      console.warn("<BezierEdgeInternal> was created without expected prop 'targetY'");
    }
    if (targetPosition === void 0 && !("targetPosition" in $$props || $$self.$$.bound[$$self.$$.props["targetPosition"]])) {
      console.warn("<BezierEdgeInternal> was created without expected prop 'targetPosition'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("label" in $$new_props) $$invalidate(0, label = $$new_props.label);
    if ("labelStyle" in $$new_props) $$invalidate(1, labelStyle = $$new_props.labelStyle);
    if ("style" in $$new_props) $$invalidate(2, style = $$new_props.style);
    if ("markerStart" in $$new_props) $$invalidate(3, markerStart = $$new_props.markerStart);
    if ("markerEnd" in $$new_props) $$invalidate(4, markerEnd = $$new_props.markerEnd);
    if ("interactionWidth" in $$new_props) $$invalidate(5, interactionWidth = $$new_props.interactionWidth);
    if ("sourceX" in $$new_props) $$invalidate(9, sourceX = $$new_props.sourceX);
    if ("sourceY" in $$new_props) $$invalidate(10, sourceY = $$new_props.sourceY);
    if ("sourcePosition" in $$new_props) $$invalidate(11, sourcePosition = $$new_props.sourcePosition);
    if ("targetX" in $$new_props) $$invalidate(12, targetX = $$new_props.targetX);
    if ("targetY" in $$new_props) $$invalidate(13, targetY = $$new_props.targetY);
    if ("targetPosition" in $$new_props) $$invalidate(14, targetPosition = $$new_props.targetPosition);
  };
  $$self.$capture_state = () => ({
    getBezierPath,
    BaseEdge: BaseEdge_default,
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
    labelY,
    labelX,
    path
  });
  $$self.$inject_state = ($$new_props) => {
    if ("label" in $$props) $$invalidate(0, label = $$new_props.label);
    if ("labelStyle" in $$props) $$invalidate(1, labelStyle = $$new_props.labelStyle);
    if ("style" in $$props) $$invalidate(2, style = $$new_props.style);
    if ("markerStart" in $$props) $$invalidate(3, markerStart = $$new_props.markerStart);
    if ("markerEnd" in $$props) $$invalidate(4, markerEnd = $$new_props.markerEnd);
    if ("interactionWidth" in $$props) $$invalidate(5, interactionWidth = $$new_props.interactionWidth);
    if ("sourceX" in $$props) $$invalidate(9, sourceX = $$new_props.sourceX);
    if ("sourceY" in $$props) $$invalidate(10, sourceY = $$new_props.sourceY);
    if ("sourcePosition" in $$props) $$invalidate(11, sourcePosition = $$new_props.sourcePosition);
    if ("targetX" in $$props) $$invalidate(12, targetX = $$new_props.targetX);
    if ("targetY" in $$props) $$invalidate(13, targetY = $$new_props.targetY);
    if ("targetPosition" in $$props) $$invalidate(14, targetPosition = $$new_props.targetPosition);
    if ("labelY" in $$props) $$invalidate(6, labelY = $$new_props.labelY);
    if ("labelX" in $$props) $$invalidate(7, labelX = $$new_props.labelX);
    if ("path" in $$props) $$invalidate(8, path = $$new_props.path);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition*/
    32256) {
      $: $$invalidate(
        8,
        [path, labelX, labelY] = getBezierPath({
          sourceX,
          sourceY,
          targetX,
          targetY,
          sourcePosition,
          targetPosition
        }),
        path,
        ($$invalidate(7, labelX), $$invalidate(9, sourceX), $$invalidate(10, sourceY), $$invalidate(12, targetX), $$invalidate(13, targetY), $$invalidate(11, sourcePosition), $$invalidate(14, targetPosition)),
        ($$invalidate(6, labelY), $$invalidate(9, sourceX), $$invalidate(10, sourceY), $$invalidate(12, targetX), $$invalidate(13, targetY), $$invalidate(11, sourcePosition), $$invalidate(14, targetPosition))
      );
    }
  };
  return [
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    labelY,
    labelX,
    path,
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition
  ];
}
var BezierEdgeInternal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, {
      label: 0,
      labelStyle: 1,
      style: 2,
      markerStart: 3,
      markerEnd: 4,
      interactionWidth: 5,
      sourceX: 9,
      sourceY: 10,
      sourcePosition: 11,
      targetX: 12,
      targetY: 13,
      targetPosition: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BezierEdgeInternal",
      options,
      id: create_fragment10.name
    });
  }
  get label() {
    throw new Error("<BezierEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<BezierEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelStyle() {
    throw new Error("<BezierEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelStyle(value) {
    throw new Error("<BezierEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<BezierEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<BezierEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerStart() {
    throw new Error("<BezierEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerStart(value) {
    throw new Error("<BezierEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerEnd() {
    throw new Error("<BezierEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerEnd(value) {
    throw new Error("<BezierEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactionWidth() {
    throw new Error("<BezierEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactionWidth(value) {
    throw new Error("<BezierEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceX() {
    throw new Error("<BezierEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceX(value) {
    throw new Error("<BezierEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceY() {
    throw new Error("<BezierEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceY(value) {
    throw new Error("<BezierEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<BezierEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<BezierEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetX() {
    throw new Error("<BezierEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetX(value) {
    throw new Error("<BezierEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetY() {
    throw new Error("<BezierEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetY(value) {
    throw new Error("<BezierEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<BezierEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<BezierEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BezierEdgeInternal_default = BezierEdgeInternal;

// node_modules/@xyflow/svelte/dist/lib/components/edges/SmoothStepEdge.svelte
function create_fragment11(ctx) {
  let baseedge;
  let current;
  baseedge = new BaseEdge_default({
    props: {
      id: (
        /*id*/
        ctx[0]
      ),
      path: (
        /*path*/
        ctx[9]
      ),
      labelX: (
        /*labelX*/
        ctx[8]
      ),
      labelY: (
        /*labelY*/
        ctx[7]
      ),
      label: (
        /*label*/
        ctx[1]
      ),
      labelStyle: (
        /*labelStyle*/
        ctx[2]
      ),
      markerStart: (
        /*markerStart*/
        ctx[4]
      ),
      markerEnd: (
        /*markerEnd*/
        ctx[5]
      ),
      interactionWidth: (
        /*interactionWidth*/
        ctx[6]
      ),
      style: (
        /*style*/
        ctx[3]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(baseedge.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(baseedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const baseedge_changes = {};
      if (dirty & /*id*/
      1) baseedge_changes.id = /*id*/
      ctx2[0];
      if (dirty & /*path*/
      512) baseedge_changes.path = /*path*/
      ctx2[9];
      if (dirty & /*labelX*/
      256) baseedge_changes.labelX = /*labelX*/
      ctx2[8];
      if (dirty & /*labelY*/
      128) baseedge_changes.labelY = /*labelY*/
      ctx2[7];
      if (dirty & /*label*/
      2) baseedge_changes.label = /*label*/
      ctx2[1];
      if (dirty & /*labelStyle*/
      4) baseedge_changes.labelStyle = /*labelStyle*/
      ctx2[2];
      if (dirty & /*markerStart*/
      16) baseedge_changes.markerStart = /*markerStart*/
      ctx2[4];
      if (dirty & /*markerEnd*/
      32) baseedge_changes.markerEnd = /*markerEnd*/
      ctx2[5];
      if (dirty & /*interactionWidth*/
      64) baseedge_changes.interactionWidth = /*interactionWidth*/
      ctx2[6];
      if (dirty & /*style*/
      8) baseedge_changes.style = /*style*/
      ctx2[3];
      baseedge.$set(baseedge_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(baseedge.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(baseedge.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(baseedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let path;
  let labelX;
  let labelY;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SmoothStepEdge", slots, []);
  let { id: id2 = void 0 } = $$props;
  let { label = void 0 } = $$props;
  let { labelStyle = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { markerStart = void 0 } = $$props;
  let { markerEnd = void 0 } = $$props;
  let { pathOptions = void 0 } = $$props;
  let { interactionWidth = void 0 } = $$props;
  let { sourceX } = $$props;
  let { sourceY } = $$props;
  let { sourcePosition } = $$props;
  let { targetX } = $$props;
  let { targetY } = $$props;
  let { targetPosition } = $$props;
  $$self.$$.on_mount.push(function() {
    if (sourceX === void 0 && !("sourceX" in $$props || $$self.$$.bound[$$self.$$.props["sourceX"]])) {
      console.warn("<SmoothStepEdge> was created without expected prop 'sourceX'");
    }
    if (sourceY === void 0 && !("sourceY" in $$props || $$self.$$.bound[$$self.$$.props["sourceY"]])) {
      console.warn("<SmoothStepEdge> was created without expected prop 'sourceY'");
    }
    if (sourcePosition === void 0 && !("sourcePosition" in $$props || $$self.$$.bound[$$self.$$.props["sourcePosition"]])) {
      console.warn("<SmoothStepEdge> was created without expected prop 'sourcePosition'");
    }
    if (targetX === void 0 && !("targetX" in $$props || $$self.$$.bound[$$self.$$.props["targetX"]])) {
      console.warn("<SmoothStepEdge> was created without expected prop 'targetX'");
    }
    if (targetY === void 0 && !("targetY" in $$props || $$self.$$.bound[$$self.$$.props["targetY"]])) {
      console.warn("<SmoothStepEdge> was created without expected prop 'targetY'");
    }
    if (targetPosition === void 0 && !("targetPosition" in $$props || $$self.$$.bound[$$self.$$.props["targetPosition"]])) {
      console.warn("<SmoothStepEdge> was created without expected prop 'targetPosition'");
    }
  });
  const writable_props = [
    "id",
    "label",
    "labelStyle",
    "style",
    "markerStart",
    "markerEnd",
    "pathOptions",
    "interactionWidth",
    "sourceX",
    "sourceY",
    "sourcePosition",
    "targetX",
    "targetY",
    "targetPosition"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<SmoothStepEdge> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id2 = $$props2.id);
    if ("label" in $$props2) $$invalidate(1, label = $$props2.label);
    if ("labelStyle" in $$props2) $$invalidate(2, labelStyle = $$props2.labelStyle);
    if ("style" in $$props2) $$invalidate(3, style = $$props2.style);
    if ("markerStart" in $$props2) $$invalidate(4, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2) $$invalidate(5, markerEnd = $$props2.markerEnd);
    if ("pathOptions" in $$props2) $$invalidate(10, pathOptions = $$props2.pathOptions);
    if ("interactionWidth" in $$props2) $$invalidate(6, interactionWidth = $$props2.interactionWidth);
    if ("sourceX" in $$props2) $$invalidate(11, sourceX = $$props2.sourceX);
    if ("sourceY" in $$props2) $$invalidate(12, sourceY = $$props2.sourceY);
    if ("sourcePosition" in $$props2) $$invalidate(13, sourcePosition = $$props2.sourcePosition);
    if ("targetX" in $$props2) $$invalidate(14, targetX = $$props2.targetX);
    if ("targetY" in $$props2) $$invalidate(15, targetY = $$props2.targetY);
    if ("targetPosition" in $$props2) $$invalidate(16, targetPosition = $$props2.targetPosition);
  };
  $$self.$capture_state = () => ({
    getSmoothStepPath,
    BaseEdge: BaseEdge_default,
    id: id2,
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    pathOptions,
    interactionWidth,
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
    labelY,
    labelX,
    path
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id2 = $$props2.id);
    if ("label" in $$props2) $$invalidate(1, label = $$props2.label);
    if ("labelStyle" in $$props2) $$invalidate(2, labelStyle = $$props2.labelStyle);
    if ("style" in $$props2) $$invalidate(3, style = $$props2.style);
    if ("markerStart" in $$props2) $$invalidate(4, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2) $$invalidate(5, markerEnd = $$props2.markerEnd);
    if ("pathOptions" in $$props2) $$invalidate(10, pathOptions = $$props2.pathOptions);
    if ("interactionWidth" in $$props2) $$invalidate(6, interactionWidth = $$props2.interactionWidth);
    if ("sourceX" in $$props2) $$invalidate(11, sourceX = $$props2.sourceX);
    if ("sourceY" in $$props2) $$invalidate(12, sourceY = $$props2.sourceY);
    if ("sourcePosition" in $$props2) $$invalidate(13, sourcePosition = $$props2.sourcePosition);
    if ("targetX" in $$props2) $$invalidate(14, targetX = $$props2.targetX);
    if ("targetY" in $$props2) $$invalidate(15, targetY = $$props2.targetY);
    if ("targetPosition" in $$props2) $$invalidate(16, targetPosition = $$props2.targetPosition);
    if ("labelY" in $$props2) $$invalidate(7, labelY = $$props2.labelY);
    if ("labelX" in $$props2) $$invalidate(8, labelX = $$props2.labelX);
    if ("path" in $$props2) $$invalidate(9, path = $$props2.path);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, pathOptions*/
    130048) {
      $: $$invalidate(
        9,
        [path, labelX, labelY] = getSmoothStepPath({
          sourceX,
          sourceY,
          targetX,
          targetY,
          sourcePosition,
          targetPosition,
          borderRadius: pathOptions == null ? void 0 : pathOptions.borderRadius,
          offset: pathOptions == null ? void 0 : pathOptions.offset
        }),
        path,
        ($$invalidate(8, labelX), $$invalidate(11, sourceX), $$invalidate(12, sourceY), $$invalidate(14, targetX), $$invalidate(15, targetY), $$invalidate(13, sourcePosition), $$invalidate(16, targetPosition), $$invalidate(10, pathOptions)),
        ($$invalidate(7, labelY), $$invalidate(11, sourceX), $$invalidate(12, sourceY), $$invalidate(14, targetX), $$invalidate(15, targetY), $$invalidate(13, sourcePosition), $$invalidate(16, targetPosition), $$invalidate(10, pathOptions))
      );
    }
  };
  return [
    id2,
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    labelY,
    labelX,
    path,
    pathOptions,
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition
  ];
}
var SmoothStepEdge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, {
      id: 0,
      label: 1,
      labelStyle: 2,
      style: 3,
      markerStart: 4,
      markerEnd: 5,
      pathOptions: 10,
      interactionWidth: 6,
      sourceX: 11,
      sourceY: 12,
      sourcePosition: 13,
      targetX: 14,
      targetY: 15,
      targetPosition: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SmoothStepEdge",
      options,
      id: create_fragment11.name
    });
  }
  get id() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelStyle() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelStyle(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerStart() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerStart(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerEnd() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerEnd(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pathOptions() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pathOptions(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactionWidth() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactionWidth(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceX() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceX(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceY() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceY(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetX() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetX(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetY() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetY(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SmoothStepEdge_default = SmoothStepEdge;

// node_modules/@xyflow/svelte/dist/lib/components/edges/SmoothStepEdgeInternal.svelte
function create_fragment12(ctx) {
  let baseedge;
  let current;
  baseedge = new BaseEdge_default({
    props: {
      path: (
        /*path*/
        ctx[8]
      ),
      labelX: (
        /*labelX*/
        ctx[7]
      ),
      labelY: (
        /*labelY*/
        ctx[6]
      ),
      label: (
        /*label*/
        ctx[0]
      ),
      labelStyle: (
        /*labelStyle*/
        ctx[1]
      ),
      markerStart: (
        /*markerStart*/
        ctx[3]
      ),
      markerEnd: (
        /*markerEnd*/
        ctx[4]
      ),
      interactionWidth: (
        /*interactionWidth*/
        ctx[5]
      ),
      style: (
        /*style*/
        ctx[2]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(baseedge.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(baseedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const baseedge_changes = {};
      if (dirty & /*path*/
      256) baseedge_changes.path = /*path*/
      ctx2[8];
      if (dirty & /*labelX*/
      128) baseedge_changes.labelX = /*labelX*/
      ctx2[7];
      if (dirty & /*labelY*/
      64) baseedge_changes.labelY = /*labelY*/
      ctx2[6];
      if (dirty & /*label*/
      1) baseedge_changes.label = /*label*/
      ctx2[0];
      if (dirty & /*labelStyle*/
      2) baseedge_changes.labelStyle = /*labelStyle*/
      ctx2[1];
      if (dirty & /*markerStart*/
      8) baseedge_changes.markerStart = /*markerStart*/
      ctx2[3];
      if (dirty & /*markerEnd*/
      16) baseedge_changes.markerEnd = /*markerEnd*/
      ctx2[4];
      if (dirty & /*interactionWidth*/
      32) baseedge_changes.interactionWidth = /*interactionWidth*/
      ctx2[5];
      if (dirty & /*style*/
      4) baseedge_changes.style = /*style*/
      ctx2[2];
      baseedge.$set(baseedge_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(baseedge.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(baseedge.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(baseedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let path;
  let labelX;
  let labelY;
  const omit_props_names = [
    "label",
    "labelStyle",
    "style",
    "markerStart",
    "markerEnd",
    "interactionWidth",
    "sourceX",
    "sourceY",
    "sourcePosition",
    "targetX",
    "targetY",
    "targetPosition"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SmoothStepEdgeInternal", slots, []);
  let { label = void 0 } = $$props;
  let { labelStyle = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { markerStart = void 0 } = $$props;
  let { markerEnd = void 0 } = $$props;
  let { interactionWidth = void 0 } = $$props;
  let { sourceX } = $$props;
  let { sourceY } = $$props;
  let { sourcePosition } = $$props;
  let { targetX } = $$props;
  let { targetY } = $$props;
  let { targetPosition } = $$props;
  $$restProps;
  $$self.$$.on_mount.push(function() {
    if (sourceX === void 0 && !("sourceX" in $$props || $$self.$$.bound[$$self.$$.props["sourceX"]])) {
      console.warn("<SmoothStepEdgeInternal> was created without expected prop 'sourceX'");
    }
    if (sourceY === void 0 && !("sourceY" in $$props || $$self.$$.bound[$$self.$$.props["sourceY"]])) {
      console.warn("<SmoothStepEdgeInternal> was created without expected prop 'sourceY'");
    }
    if (sourcePosition === void 0 && !("sourcePosition" in $$props || $$self.$$.bound[$$self.$$.props["sourcePosition"]])) {
      console.warn("<SmoothStepEdgeInternal> was created without expected prop 'sourcePosition'");
    }
    if (targetX === void 0 && !("targetX" in $$props || $$self.$$.bound[$$self.$$.props["targetX"]])) {
      console.warn("<SmoothStepEdgeInternal> was created without expected prop 'targetX'");
    }
    if (targetY === void 0 && !("targetY" in $$props || $$self.$$.bound[$$self.$$.props["targetY"]])) {
      console.warn("<SmoothStepEdgeInternal> was created without expected prop 'targetY'");
    }
    if (targetPosition === void 0 && !("targetPosition" in $$props || $$self.$$.bound[$$self.$$.props["targetPosition"]])) {
      console.warn("<SmoothStepEdgeInternal> was created without expected prop 'targetPosition'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("label" in $$new_props) $$invalidate(0, label = $$new_props.label);
    if ("labelStyle" in $$new_props) $$invalidate(1, labelStyle = $$new_props.labelStyle);
    if ("style" in $$new_props) $$invalidate(2, style = $$new_props.style);
    if ("markerStart" in $$new_props) $$invalidate(3, markerStart = $$new_props.markerStart);
    if ("markerEnd" in $$new_props) $$invalidate(4, markerEnd = $$new_props.markerEnd);
    if ("interactionWidth" in $$new_props) $$invalidate(5, interactionWidth = $$new_props.interactionWidth);
    if ("sourceX" in $$new_props) $$invalidate(9, sourceX = $$new_props.sourceX);
    if ("sourceY" in $$new_props) $$invalidate(10, sourceY = $$new_props.sourceY);
    if ("sourcePosition" in $$new_props) $$invalidate(11, sourcePosition = $$new_props.sourcePosition);
    if ("targetX" in $$new_props) $$invalidate(12, targetX = $$new_props.targetX);
    if ("targetY" in $$new_props) $$invalidate(13, targetY = $$new_props.targetY);
    if ("targetPosition" in $$new_props) $$invalidate(14, targetPosition = $$new_props.targetPosition);
  };
  $$self.$capture_state = () => ({
    getSmoothStepPath,
    BaseEdge: BaseEdge_default,
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
    labelY,
    labelX,
    path
  });
  $$self.$inject_state = ($$new_props) => {
    if ("label" in $$props) $$invalidate(0, label = $$new_props.label);
    if ("labelStyle" in $$props) $$invalidate(1, labelStyle = $$new_props.labelStyle);
    if ("style" in $$props) $$invalidate(2, style = $$new_props.style);
    if ("markerStart" in $$props) $$invalidate(3, markerStart = $$new_props.markerStart);
    if ("markerEnd" in $$props) $$invalidate(4, markerEnd = $$new_props.markerEnd);
    if ("interactionWidth" in $$props) $$invalidate(5, interactionWidth = $$new_props.interactionWidth);
    if ("sourceX" in $$props) $$invalidate(9, sourceX = $$new_props.sourceX);
    if ("sourceY" in $$props) $$invalidate(10, sourceY = $$new_props.sourceY);
    if ("sourcePosition" in $$props) $$invalidate(11, sourcePosition = $$new_props.sourcePosition);
    if ("targetX" in $$props) $$invalidate(12, targetX = $$new_props.targetX);
    if ("targetY" in $$props) $$invalidate(13, targetY = $$new_props.targetY);
    if ("targetPosition" in $$props) $$invalidate(14, targetPosition = $$new_props.targetPosition);
    if ("labelY" in $$props) $$invalidate(6, labelY = $$new_props.labelY);
    if ("labelX" in $$props) $$invalidate(7, labelX = $$new_props.labelX);
    if ("path" in $$props) $$invalidate(8, path = $$new_props.path);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition*/
    32256) {
      $: $$invalidate(
        8,
        [path, labelX, labelY] = getSmoothStepPath({
          sourceX,
          sourceY,
          targetX,
          targetY,
          sourcePosition,
          targetPosition
        }),
        path,
        ($$invalidate(7, labelX), $$invalidate(9, sourceX), $$invalidate(10, sourceY), $$invalidate(12, targetX), $$invalidate(13, targetY), $$invalidate(11, sourcePosition), $$invalidate(14, targetPosition)),
        ($$invalidate(6, labelY), $$invalidate(9, sourceX), $$invalidate(10, sourceY), $$invalidate(12, targetX), $$invalidate(13, targetY), $$invalidate(11, sourcePosition), $$invalidate(14, targetPosition))
      );
    }
  };
  return [
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    labelY,
    labelX,
    path,
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition
  ];
}
var SmoothStepEdgeInternal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, {
      label: 0,
      labelStyle: 1,
      style: 2,
      markerStart: 3,
      markerEnd: 4,
      interactionWidth: 5,
      sourceX: 9,
      sourceY: 10,
      sourcePosition: 11,
      targetX: 12,
      targetY: 13,
      targetPosition: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SmoothStepEdgeInternal",
      options,
      id: create_fragment12.name
    });
  }
  get label() {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelStyle() {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelStyle(value) {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerStart() {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerStart(value) {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerEnd() {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerEnd(value) {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactionWidth() {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactionWidth(value) {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceX() {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceX(value) {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceY() {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceY(value) {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetX() {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetX(value) {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetY() {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetY(value) {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<SmoothStepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SmoothStepEdgeInternal_default = SmoothStepEdgeInternal;

// node_modules/@xyflow/svelte/dist/lib/components/edges/StraightEdge.svelte
function create_fragment13(ctx) {
  let baseedge;
  let current;
  baseedge = new BaseEdge_default({
    props: {
      id: (
        /*id*/
        ctx[0]
      ),
      path: (
        /*path*/
        ctx[9]
      ),
      labelX: (
        /*labelX*/
        ctx[8]
      ),
      labelY: (
        /*labelY*/
        ctx[7]
      ),
      label: (
        /*label*/
        ctx[1]
      ),
      labelStyle: (
        /*labelStyle*/
        ctx[2]
      ),
      markerStart: (
        /*markerStart*/
        ctx[4]
      ),
      markerEnd: (
        /*markerEnd*/
        ctx[5]
      ),
      interactionWidth: (
        /*interactionWidth*/
        ctx[6]
      ),
      style: (
        /*style*/
        ctx[3]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(baseedge.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(baseedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const baseedge_changes = {};
      if (dirty & /*id*/
      1) baseedge_changes.id = /*id*/
      ctx2[0];
      if (dirty & /*path*/
      512) baseedge_changes.path = /*path*/
      ctx2[9];
      if (dirty & /*labelX*/
      256) baseedge_changes.labelX = /*labelX*/
      ctx2[8];
      if (dirty & /*labelY*/
      128) baseedge_changes.labelY = /*labelY*/
      ctx2[7];
      if (dirty & /*label*/
      2) baseedge_changes.label = /*label*/
      ctx2[1];
      if (dirty & /*labelStyle*/
      4) baseedge_changes.labelStyle = /*labelStyle*/
      ctx2[2];
      if (dirty & /*markerStart*/
      16) baseedge_changes.markerStart = /*markerStart*/
      ctx2[4];
      if (dirty & /*markerEnd*/
      32) baseedge_changes.markerEnd = /*markerEnd*/
      ctx2[5];
      if (dirty & /*interactionWidth*/
      64) baseedge_changes.interactionWidth = /*interactionWidth*/
      ctx2[6];
      if (dirty & /*style*/
      8) baseedge_changes.style = /*style*/
      ctx2[3];
      baseedge.$set(baseedge_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(baseedge.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(baseedge.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(baseedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let path;
  let labelX;
  let labelY;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StraightEdge", slots, []);
  let { id: id2 = void 0 } = $$props;
  let { label = void 0 } = $$props;
  let { labelStyle = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { markerStart = void 0 } = $$props;
  let { markerEnd = void 0 } = $$props;
  let { interactionWidth = void 0 } = $$props;
  let { sourceX } = $$props;
  let { sourceY } = $$props;
  let { targetX } = $$props;
  let { targetY } = $$props;
  $$self.$$.on_mount.push(function() {
    if (sourceX === void 0 && !("sourceX" in $$props || $$self.$$.bound[$$self.$$.props["sourceX"]])) {
      console.warn("<StraightEdge> was created without expected prop 'sourceX'");
    }
    if (sourceY === void 0 && !("sourceY" in $$props || $$self.$$.bound[$$self.$$.props["sourceY"]])) {
      console.warn("<StraightEdge> was created without expected prop 'sourceY'");
    }
    if (targetX === void 0 && !("targetX" in $$props || $$self.$$.bound[$$self.$$.props["targetX"]])) {
      console.warn("<StraightEdge> was created without expected prop 'targetX'");
    }
    if (targetY === void 0 && !("targetY" in $$props || $$self.$$.bound[$$self.$$.props["targetY"]])) {
      console.warn("<StraightEdge> was created without expected prop 'targetY'");
    }
  });
  const writable_props = [
    "id",
    "label",
    "labelStyle",
    "style",
    "markerStart",
    "markerEnd",
    "interactionWidth",
    "sourceX",
    "sourceY",
    "targetX",
    "targetY"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<StraightEdge> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id2 = $$props2.id);
    if ("label" in $$props2) $$invalidate(1, label = $$props2.label);
    if ("labelStyle" in $$props2) $$invalidate(2, labelStyle = $$props2.labelStyle);
    if ("style" in $$props2) $$invalidate(3, style = $$props2.style);
    if ("markerStart" in $$props2) $$invalidate(4, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2) $$invalidate(5, markerEnd = $$props2.markerEnd);
    if ("interactionWidth" in $$props2) $$invalidate(6, interactionWidth = $$props2.interactionWidth);
    if ("sourceX" in $$props2) $$invalidate(10, sourceX = $$props2.sourceX);
    if ("sourceY" in $$props2) $$invalidate(11, sourceY = $$props2.sourceY);
    if ("targetX" in $$props2) $$invalidate(12, targetX = $$props2.targetX);
    if ("targetY" in $$props2) $$invalidate(13, targetY = $$props2.targetY);
  };
  $$self.$capture_state = () => ({
    getStraightPath,
    BaseEdge: BaseEdge_default,
    id: id2,
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    sourceX,
    sourceY,
    targetX,
    targetY,
    labelY,
    labelX,
    path
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id2 = $$props2.id);
    if ("label" in $$props2) $$invalidate(1, label = $$props2.label);
    if ("labelStyle" in $$props2) $$invalidate(2, labelStyle = $$props2.labelStyle);
    if ("style" in $$props2) $$invalidate(3, style = $$props2.style);
    if ("markerStart" in $$props2) $$invalidate(4, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2) $$invalidate(5, markerEnd = $$props2.markerEnd);
    if ("interactionWidth" in $$props2) $$invalidate(6, interactionWidth = $$props2.interactionWidth);
    if ("sourceX" in $$props2) $$invalidate(10, sourceX = $$props2.sourceX);
    if ("sourceY" in $$props2) $$invalidate(11, sourceY = $$props2.sourceY);
    if ("targetX" in $$props2) $$invalidate(12, targetX = $$props2.targetX);
    if ("targetY" in $$props2) $$invalidate(13, targetY = $$props2.targetY);
    if ("labelY" in $$props2) $$invalidate(7, labelY = $$props2.labelY);
    if ("labelX" in $$props2) $$invalidate(8, labelX = $$props2.labelX);
    if ("path" in $$props2) $$invalidate(9, path = $$props2.path);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sourceX, sourceY, targetX, targetY*/
    15360) {
      $: $$invalidate(9, [path, labelX, labelY] = getStraightPath({ sourceX, sourceY, targetX, targetY }), path, ($$invalidate(8, labelX), $$invalidate(10, sourceX), $$invalidate(11, sourceY), $$invalidate(12, targetX), $$invalidate(13, targetY)), ($$invalidate(7, labelY), $$invalidate(10, sourceX), $$invalidate(11, sourceY), $$invalidate(12, targetX), $$invalidate(13, targetY)));
    }
  };
  return [
    id2,
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    labelY,
    labelX,
    path,
    sourceX,
    sourceY,
    targetX,
    targetY
  ];
}
var StraightEdge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, {
      id: 0,
      label: 1,
      labelStyle: 2,
      style: 3,
      markerStart: 4,
      markerEnd: 5,
      interactionWidth: 6,
      sourceX: 10,
      sourceY: 11,
      targetX: 12,
      targetY: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StraightEdge",
      options,
      id: create_fragment13.name
    });
  }
  get id() {
    throw new Error("<StraightEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<StraightEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<StraightEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<StraightEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelStyle() {
    throw new Error("<StraightEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelStyle(value) {
    throw new Error("<StraightEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<StraightEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<StraightEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerStart() {
    throw new Error("<StraightEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerStart(value) {
    throw new Error("<StraightEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerEnd() {
    throw new Error("<StraightEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerEnd(value) {
    throw new Error("<StraightEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactionWidth() {
    throw new Error("<StraightEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactionWidth(value) {
    throw new Error("<StraightEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceX() {
    throw new Error("<StraightEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceX(value) {
    throw new Error("<StraightEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceY() {
    throw new Error("<StraightEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceY(value) {
    throw new Error("<StraightEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetX() {
    throw new Error("<StraightEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetX(value) {
    throw new Error("<StraightEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetY() {
    throw new Error("<StraightEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetY(value) {
    throw new Error("<StraightEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StraightEdge_default = StraightEdge;

// node_modules/@xyflow/svelte/dist/lib/components/edges/StraightEdgeInternal.svelte
function create_fragment14(ctx) {
  let baseedge;
  let current;
  baseedge = new BaseEdge_default({
    props: {
      path: (
        /*path*/
        ctx[8]
      ),
      labelX: (
        /*labelX*/
        ctx[7]
      ),
      labelY: (
        /*labelY*/
        ctx[6]
      ),
      label: (
        /*label*/
        ctx[0]
      ),
      labelStyle: (
        /*labelStyle*/
        ctx[1]
      ),
      markerStart: (
        /*markerStart*/
        ctx[3]
      ),
      markerEnd: (
        /*markerEnd*/
        ctx[4]
      ),
      interactionWidth: (
        /*interactionWidth*/
        ctx[5]
      ),
      style: (
        /*style*/
        ctx[2]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(baseedge.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(baseedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const baseedge_changes = {};
      if (dirty & /*path*/
      256) baseedge_changes.path = /*path*/
      ctx2[8];
      if (dirty & /*labelX*/
      128) baseedge_changes.labelX = /*labelX*/
      ctx2[7];
      if (dirty & /*labelY*/
      64) baseedge_changes.labelY = /*labelY*/
      ctx2[6];
      if (dirty & /*label*/
      1) baseedge_changes.label = /*label*/
      ctx2[0];
      if (dirty & /*labelStyle*/
      2) baseedge_changes.labelStyle = /*labelStyle*/
      ctx2[1];
      if (dirty & /*markerStart*/
      8) baseedge_changes.markerStart = /*markerStart*/
      ctx2[3];
      if (dirty & /*markerEnd*/
      16) baseedge_changes.markerEnd = /*markerEnd*/
      ctx2[4];
      if (dirty & /*interactionWidth*/
      32) baseedge_changes.interactionWidth = /*interactionWidth*/
      ctx2[5];
      if (dirty & /*style*/
      4) baseedge_changes.style = /*style*/
      ctx2[2];
      baseedge.$set(baseedge_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(baseedge.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(baseedge.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(baseedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let path;
  let labelX;
  let labelY;
  const omit_props_names = [
    "label",
    "labelStyle",
    "style",
    "markerStart",
    "markerEnd",
    "interactionWidth",
    "sourceX",
    "sourceY",
    "targetX",
    "targetY"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StraightEdgeInternal", slots, []);
  let { label = void 0 } = $$props;
  let { labelStyle = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { markerStart = void 0 } = $$props;
  let { markerEnd = void 0 } = $$props;
  let { interactionWidth = void 0 } = $$props;
  let { sourceX } = $$props;
  let { sourceY } = $$props;
  let { targetX } = $$props;
  let { targetY } = $$props;
  $$restProps;
  $$self.$$.on_mount.push(function() {
    if (sourceX === void 0 && !("sourceX" in $$props || $$self.$$.bound[$$self.$$.props["sourceX"]])) {
      console.warn("<StraightEdgeInternal> was created without expected prop 'sourceX'");
    }
    if (sourceY === void 0 && !("sourceY" in $$props || $$self.$$.bound[$$self.$$.props["sourceY"]])) {
      console.warn("<StraightEdgeInternal> was created without expected prop 'sourceY'");
    }
    if (targetX === void 0 && !("targetX" in $$props || $$self.$$.bound[$$self.$$.props["targetX"]])) {
      console.warn("<StraightEdgeInternal> was created without expected prop 'targetX'");
    }
    if (targetY === void 0 && !("targetY" in $$props || $$self.$$.bound[$$self.$$.props["targetY"]])) {
      console.warn("<StraightEdgeInternal> was created without expected prop 'targetY'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("label" in $$new_props) $$invalidate(0, label = $$new_props.label);
    if ("labelStyle" in $$new_props) $$invalidate(1, labelStyle = $$new_props.labelStyle);
    if ("style" in $$new_props) $$invalidate(2, style = $$new_props.style);
    if ("markerStart" in $$new_props) $$invalidate(3, markerStart = $$new_props.markerStart);
    if ("markerEnd" in $$new_props) $$invalidate(4, markerEnd = $$new_props.markerEnd);
    if ("interactionWidth" in $$new_props) $$invalidate(5, interactionWidth = $$new_props.interactionWidth);
    if ("sourceX" in $$new_props) $$invalidate(9, sourceX = $$new_props.sourceX);
    if ("sourceY" in $$new_props) $$invalidate(10, sourceY = $$new_props.sourceY);
    if ("targetX" in $$new_props) $$invalidate(11, targetX = $$new_props.targetX);
    if ("targetY" in $$new_props) $$invalidate(12, targetY = $$new_props.targetY);
  };
  $$self.$capture_state = () => ({
    getStraightPath,
    BaseEdge: BaseEdge_default,
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    sourceX,
    sourceY,
    targetX,
    targetY,
    labelY,
    labelX,
    path
  });
  $$self.$inject_state = ($$new_props) => {
    if ("label" in $$props) $$invalidate(0, label = $$new_props.label);
    if ("labelStyle" in $$props) $$invalidate(1, labelStyle = $$new_props.labelStyle);
    if ("style" in $$props) $$invalidate(2, style = $$new_props.style);
    if ("markerStart" in $$props) $$invalidate(3, markerStart = $$new_props.markerStart);
    if ("markerEnd" in $$props) $$invalidate(4, markerEnd = $$new_props.markerEnd);
    if ("interactionWidth" in $$props) $$invalidate(5, interactionWidth = $$new_props.interactionWidth);
    if ("sourceX" in $$props) $$invalidate(9, sourceX = $$new_props.sourceX);
    if ("sourceY" in $$props) $$invalidate(10, sourceY = $$new_props.sourceY);
    if ("targetX" in $$props) $$invalidate(11, targetX = $$new_props.targetX);
    if ("targetY" in $$props) $$invalidate(12, targetY = $$new_props.targetY);
    if ("labelY" in $$props) $$invalidate(6, labelY = $$new_props.labelY);
    if ("labelX" in $$props) $$invalidate(7, labelX = $$new_props.labelX);
    if ("path" in $$props) $$invalidate(8, path = $$new_props.path);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sourceX, sourceY, targetX, targetY*/
    7680) {
      $: $$invalidate(8, [path, labelX, labelY] = getStraightPath({ sourceX, sourceY, targetX, targetY }), path, ($$invalidate(7, labelX), $$invalidate(9, sourceX), $$invalidate(10, sourceY), $$invalidate(11, targetX), $$invalidate(12, targetY)), ($$invalidate(6, labelY), $$invalidate(9, sourceX), $$invalidate(10, sourceY), $$invalidate(11, targetX), $$invalidate(12, targetY)));
    }
  };
  return [
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    labelY,
    labelX,
    path,
    sourceX,
    sourceY,
    targetX,
    targetY
  ];
}
var StraightEdgeInternal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, {
      label: 0,
      labelStyle: 1,
      style: 2,
      markerStart: 3,
      markerEnd: 4,
      interactionWidth: 5,
      sourceX: 9,
      sourceY: 10,
      targetX: 11,
      targetY: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StraightEdgeInternal",
      options,
      id: create_fragment14.name
    });
  }
  get label() {
    throw new Error("<StraightEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<StraightEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelStyle() {
    throw new Error("<StraightEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelStyle(value) {
    throw new Error("<StraightEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<StraightEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<StraightEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerStart() {
    throw new Error("<StraightEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerStart(value) {
    throw new Error("<StraightEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerEnd() {
    throw new Error("<StraightEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerEnd(value) {
    throw new Error("<StraightEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactionWidth() {
    throw new Error("<StraightEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactionWidth(value) {
    throw new Error("<StraightEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceX() {
    throw new Error("<StraightEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceX(value) {
    throw new Error("<StraightEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceY() {
    throw new Error("<StraightEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceY(value) {
    throw new Error("<StraightEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetX() {
    throw new Error("<StraightEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetX(value) {
    throw new Error("<StraightEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetY() {
    throw new Error("<StraightEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetY(value) {
    throw new Error("<StraightEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StraightEdgeInternal_default = StraightEdgeInternal;

// node_modules/@xyflow/svelte/dist/lib/components/edges/StepEdge.svelte
function create_fragment15(ctx) {
  let baseedge;
  let current;
  baseedge = new BaseEdge_default({
    props: {
      id: (
        /*id*/
        ctx[0]
      ),
      path: (
        /*path*/
        ctx[9]
      ),
      labelX: (
        /*labelX*/
        ctx[8]
      ),
      labelY: (
        /*labelY*/
        ctx[7]
      ),
      label: (
        /*label*/
        ctx[1]
      ),
      labelStyle: (
        /*labelStyle*/
        ctx[2]
      ),
      markerStart: (
        /*markerStart*/
        ctx[4]
      ),
      markerEnd: (
        /*markerEnd*/
        ctx[5]
      ),
      interactionWidth: (
        /*interactionWidth*/
        ctx[6]
      ),
      style: (
        /*style*/
        ctx[3]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(baseedge.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(baseedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const baseedge_changes = {};
      if (dirty & /*id*/
      1) baseedge_changes.id = /*id*/
      ctx2[0];
      if (dirty & /*path*/
      512) baseedge_changes.path = /*path*/
      ctx2[9];
      if (dirty & /*labelX*/
      256) baseedge_changes.labelX = /*labelX*/
      ctx2[8];
      if (dirty & /*labelY*/
      128) baseedge_changes.labelY = /*labelY*/
      ctx2[7];
      if (dirty & /*label*/
      2) baseedge_changes.label = /*label*/
      ctx2[1];
      if (dirty & /*labelStyle*/
      4) baseedge_changes.labelStyle = /*labelStyle*/
      ctx2[2];
      if (dirty & /*markerStart*/
      16) baseedge_changes.markerStart = /*markerStart*/
      ctx2[4];
      if (dirty & /*markerEnd*/
      32) baseedge_changes.markerEnd = /*markerEnd*/
      ctx2[5];
      if (dirty & /*interactionWidth*/
      64) baseedge_changes.interactionWidth = /*interactionWidth*/
      ctx2[6];
      if (dirty & /*style*/
      8) baseedge_changes.style = /*style*/
      ctx2[3];
      baseedge.$set(baseedge_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(baseedge.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(baseedge.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(baseedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let path;
  let labelX;
  let labelY;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StepEdge", slots, []);
  let { id: id2 = void 0 } = $$props;
  let { label = void 0 } = $$props;
  let { labelStyle = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { markerStart = void 0 } = $$props;
  let { markerEnd = void 0 } = $$props;
  let { pathOptions = void 0 } = $$props;
  let { interactionWidth = void 0 } = $$props;
  let { sourceX } = $$props;
  let { sourceY } = $$props;
  let { sourcePosition } = $$props;
  let { targetX } = $$props;
  let { targetY } = $$props;
  let { targetPosition } = $$props;
  $$self.$$.on_mount.push(function() {
    if (sourceX === void 0 && !("sourceX" in $$props || $$self.$$.bound[$$self.$$.props["sourceX"]])) {
      console.warn("<StepEdge> was created without expected prop 'sourceX'");
    }
    if (sourceY === void 0 && !("sourceY" in $$props || $$self.$$.bound[$$self.$$.props["sourceY"]])) {
      console.warn("<StepEdge> was created without expected prop 'sourceY'");
    }
    if (sourcePosition === void 0 && !("sourcePosition" in $$props || $$self.$$.bound[$$self.$$.props["sourcePosition"]])) {
      console.warn("<StepEdge> was created without expected prop 'sourcePosition'");
    }
    if (targetX === void 0 && !("targetX" in $$props || $$self.$$.bound[$$self.$$.props["targetX"]])) {
      console.warn("<StepEdge> was created without expected prop 'targetX'");
    }
    if (targetY === void 0 && !("targetY" in $$props || $$self.$$.bound[$$self.$$.props["targetY"]])) {
      console.warn("<StepEdge> was created without expected prop 'targetY'");
    }
    if (targetPosition === void 0 && !("targetPosition" in $$props || $$self.$$.bound[$$self.$$.props["targetPosition"]])) {
      console.warn("<StepEdge> was created without expected prop 'targetPosition'");
    }
  });
  const writable_props = [
    "id",
    "label",
    "labelStyle",
    "style",
    "markerStart",
    "markerEnd",
    "pathOptions",
    "interactionWidth",
    "sourceX",
    "sourceY",
    "sourcePosition",
    "targetX",
    "targetY",
    "targetPosition"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<StepEdge> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id2 = $$props2.id);
    if ("label" in $$props2) $$invalidate(1, label = $$props2.label);
    if ("labelStyle" in $$props2) $$invalidate(2, labelStyle = $$props2.labelStyle);
    if ("style" in $$props2) $$invalidate(3, style = $$props2.style);
    if ("markerStart" in $$props2) $$invalidate(4, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2) $$invalidate(5, markerEnd = $$props2.markerEnd);
    if ("pathOptions" in $$props2) $$invalidate(10, pathOptions = $$props2.pathOptions);
    if ("interactionWidth" in $$props2) $$invalidate(6, interactionWidth = $$props2.interactionWidth);
    if ("sourceX" in $$props2) $$invalidate(11, sourceX = $$props2.sourceX);
    if ("sourceY" in $$props2) $$invalidate(12, sourceY = $$props2.sourceY);
    if ("sourcePosition" in $$props2) $$invalidate(13, sourcePosition = $$props2.sourcePosition);
    if ("targetX" in $$props2) $$invalidate(14, targetX = $$props2.targetX);
    if ("targetY" in $$props2) $$invalidate(15, targetY = $$props2.targetY);
    if ("targetPosition" in $$props2) $$invalidate(16, targetPosition = $$props2.targetPosition);
  };
  $$self.$capture_state = () => ({
    getSmoothStepPath,
    BaseEdge: BaseEdge_default,
    id: id2,
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    pathOptions,
    interactionWidth,
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
    labelY,
    labelX,
    path
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id2 = $$props2.id);
    if ("label" in $$props2) $$invalidate(1, label = $$props2.label);
    if ("labelStyle" in $$props2) $$invalidate(2, labelStyle = $$props2.labelStyle);
    if ("style" in $$props2) $$invalidate(3, style = $$props2.style);
    if ("markerStart" in $$props2) $$invalidate(4, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2) $$invalidate(5, markerEnd = $$props2.markerEnd);
    if ("pathOptions" in $$props2) $$invalidate(10, pathOptions = $$props2.pathOptions);
    if ("interactionWidth" in $$props2) $$invalidate(6, interactionWidth = $$props2.interactionWidth);
    if ("sourceX" in $$props2) $$invalidate(11, sourceX = $$props2.sourceX);
    if ("sourceY" in $$props2) $$invalidate(12, sourceY = $$props2.sourceY);
    if ("sourcePosition" in $$props2) $$invalidate(13, sourcePosition = $$props2.sourcePosition);
    if ("targetX" in $$props2) $$invalidate(14, targetX = $$props2.targetX);
    if ("targetY" in $$props2) $$invalidate(15, targetY = $$props2.targetY);
    if ("targetPosition" in $$props2) $$invalidate(16, targetPosition = $$props2.targetPosition);
    if ("labelY" in $$props2) $$invalidate(7, labelY = $$props2.labelY);
    if ("labelX" in $$props2) $$invalidate(8, labelX = $$props2.labelX);
    if ("path" in $$props2) $$invalidate(9, path = $$props2.path);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, pathOptions*/
    130048) {
      $: $$invalidate(
        9,
        [path, labelX, labelY] = getSmoothStepPath({
          sourceX,
          sourceY,
          targetX,
          targetY,
          sourcePosition,
          targetPosition,
          borderRadius: 0,
          offset: pathOptions == null ? void 0 : pathOptions.offset
        }),
        path,
        ($$invalidate(8, labelX), $$invalidate(11, sourceX), $$invalidate(12, sourceY), $$invalidate(14, targetX), $$invalidate(15, targetY), $$invalidate(13, sourcePosition), $$invalidate(16, targetPosition), $$invalidate(10, pathOptions)),
        ($$invalidate(7, labelY), $$invalidate(11, sourceX), $$invalidate(12, sourceY), $$invalidate(14, targetX), $$invalidate(15, targetY), $$invalidate(13, sourcePosition), $$invalidate(16, targetPosition), $$invalidate(10, pathOptions))
      );
    }
  };
  return [
    id2,
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    labelY,
    labelX,
    path,
    pathOptions,
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition
  ];
}
var StepEdge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, {
      id: 0,
      label: 1,
      labelStyle: 2,
      style: 3,
      markerStart: 4,
      markerEnd: 5,
      pathOptions: 10,
      interactionWidth: 6,
      sourceX: 11,
      sourceY: 12,
      sourcePosition: 13,
      targetX: 14,
      targetY: 15,
      targetPosition: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StepEdge",
      options,
      id: create_fragment15.name
    });
  }
  get id() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelStyle() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelStyle(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerStart() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerStart(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerEnd() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerEnd(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pathOptions() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pathOptions(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactionWidth() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactionWidth(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceX() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceX(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceY() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceY(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetX() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetX(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetY() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetY(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StepEdge_default = StepEdge;

// node_modules/@xyflow/svelte/dist/lib/components/edges/StepEdgeInternal.svelte
function create_fragment16(ctx) {
  let baseedge;
  let current;
  baseedge = new BaseEdge_default({
    props: {
      path: (
        /*path*/
        ctx[8]
      ),
      labelX: (
        /*labelX*/
        ctx[7]
      ),
      labelY: (
        /*labelY*/
        ctx[6]
      ),
      label: (
        /*label*/
        ctx[0]
      ),
      labelStyle: (
        /*labelStyle*/
        ctx[1]
      ),
      markerStart: (
        /*markerStart*/
        ctx[3]
      ),
      markerEnd: (
        /*markerEnd*/
        ctx[4]
      ),
      interactionWidth: (
        /*interactionWidth*/
        ctx[5]
      ),
      style: (
        /*style*/
        ctx[2]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(baseedge.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(baseedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const baseedge_changes = {};
      if (dirty & /*path*/
      256) baseedge_changes.path = /*path*/
      ctx2[8];
      if (dirty & /*labelX*/
      128) baseedge_changes.labelX = /*labelX*/
      ctx2[7];
      if (dirty & /*labelY*/
      64) baseedge_changes.labelY = /*labelY*/
      ctx2[6];
      if (dirty & /*label*/
      1) baseedge_changes.label = /*label*/
      ctx2[0];
      if (dirty & /*labelStyle*/
      2) baseedge_changes.labelStyle = /*labelStyle*/
      ctx2[1];
      if (dirty & /*markerStart*/
      8) baseedge_changes.markerStart = /*markerStart*/
      ctx2[3];
      if (dirty & /*markerEnd*/
      16) baseedge_changes.markerEnd = /*markerEnd*/
      ctx2[4];
      if (dirty & /*interactionWidth*/
      32) baseedge_changes.interactionWidth = /*interactionWidth*/
      ctx2[5];
      if (dirty & /*style*/
      4) baseedge_changes.style = /*style*/
      ctx2[2];
      baseedge.$set(baseedge_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(baseedge.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(baseedge.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(baseedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let path;
  let labelX;
  let labelY;
  const omit_props_names = [
    "label",
    "labelStyle",
    "style",
    "markerStart",
    "markerEnd",
    "interactionWidth",
    "sourceX",
    "sourceY",
    "sourcePosition",
    "targetX",
    "targetY",
    "targetPosition"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StepEdgeInternal", slots, []);
  let { label = void 0 } = $$props;
  let { labelStyle = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { markerStart = void 0 } = $$props;
  let { markerEnd = void 0 } = $$props;
  let { interactionWidth = void 0 } = $$props;
  let { sourceX } = $$props;
  let { sourceY } = $$props;
  let { sourcePosition } = $$props;
  let { targetX } = $$props;
  let { targetY } = $$props;
  let { targetPosition } = $$props;
  $$restProps;
  $$self.$$.on_mount.push(function() {
    if (sourceX === void 0 && !("sourceX" in $$props || $$self.$$.bound[$$self.$$.props["sourceX"]])) {
      console.warn("<StepEdgeInternal> was created without expected prop 'sourceX'");
    }
    if (sourceY === void 0 && !("sourceY" in $$props || $$self.$$.bound[$$self.$$.props["sourceY"]])) {
      console.warn("<StepEdgeInternal> was created without expected prop 'sourceY'");
    }
    if (sourcePosition === void 0 && !("sourcePosition" in $$props || $$self.$$.bound[$$self.$$.props["sourcePosition"]])) {
      console.warn("<StepEdgeInternal> was created without expected prop 'sourcePosition'");
    }
    if (targetX === void 0 && !("targetX" in $$props || $$self.$$.bound[$$self.$$.props["targetX"]])) {
      console.warn("<StepEdgeInternal> was created without expected prop 'targetX'");
    }
    if (targetY === void 0 && !("targetY" in $$props || $$self.$$.bound[$$self.$$.props["targetY"]])) {
      console.warn("<StepEdgeInternal> was created without expected prop 'targetY'");
    }
    if (targetPosition === void 0 && !("targetPosition" in $$props || $$self.$$.bound[$$self.$$.props["targetPosition"]])) {
      console.warn("<StepEdgeInternal> was created without expected prop 'targetPosition'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("label" in $$new_props) $$invalidate(0, label = $$new_props.label);
    if ("labelStyle" in $$new_props) $$invalidate(1, labelStyle = $$new_props.labelStyle);
    if ("style" in $$new_props) $$invalidate(2, style = $$new_props.style);
    if ("markerStart" in $$new_props) $$invalidate(3, markerStart = $$new_props.markerStart);
    if ("markerEnd" in $$new_props) $$invalidate(4, markerEnd = $$new_props.markerEnd);
    if ("interactionWidth" in $$new_props) $$invalidate(5, interactionWidth = $$new_props.interactionWidth);
    if ("sourceX" in $$new_props) $$invalidate(9, sourceX = $$new_props.sourceX);
    if ("sourceY" in $$new_props) $$invalidate(10, sourceY = $$new_props.sourceY);
    if ("sourcePosition" in $$new_props) $$invalidate(11, sourcePosition = $$new_props.sourcePosition);
    if ("targetX" in $$new_props) $$invalidate(12, targetX = $$new_props.targetX);
    if ("targetY" in $$new_props) $$invalidate(13, targetY = $$new_props.targetY);
    if ("targetPosition" in $$new_props) $$invalidate(14, targetPosition = $$new_props.targetPosition);
  };
  $$self.$capture_state = () => ({
    getSmoothStepPath,
    BaseEdge: BaseEdge_default,
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
    labelY,
    labelX,
    path
  });
  $$self.$inject_state = ($$new_props) => {
    if ("label" in $$props) $$invalidate(0, label = $$new_props.label);
    if ("labelStyle" in $$props) $$invalidate(1, labelStyle = $$new_props.labelStyle);
    if ("style" in $$props) $$invalidate(2, style = $$new_props.style);
    if ("markerStart" in $$props) $$invalidate(3, markerStart = $$new_props.markerStart);
    if ("markerEnd" in $$props) $$invalidate(4, markerEnd = $$new_props.markerEnd);
    if ("interactionWidth" in $$props) $$invalidate(5, interactionWidth = $$new_props.interactionWidth);
    if ("sourceX" in $$props) $$invalidate(9, sourceX = $$new_props.sourceX);
    if ("sourceY" in $$props) $$invalidate(10, sourceY = $$new_props.sourceY);
    if ("sourcePosition" in $$props) $$invalidate(11, sourcePosition = $$new_props.sourcePosition);
    if ("targetX" in $$props) $$invalidate(12, targetX = $$new_props.targetX);
    if ("targetY" in $$props) $$invalidate(13, targetY = $$new_props.targetY);
    if ("targetPosition" in $$props) $$invalidate(14, targetPosition = $$new_props.targetPosition);
    if ("labelY" in $$props) $$invalidate(6, labelY = $$new_props.labelY);
    if ("labelX" in $$props) $$invalidate(7, labelX = $$new_props.labelX);
    if ("path" in $$props) $$invalidate(8, path = $$new_props.path);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition*/
    32256) {
      $: $$invalidate(
        8,
        [path, labelX, labelY] = getSmoothStepPath({
          sourceX,
          sourceY,
          targetX,
          targetY,
          sourcePosition,
          targetPosition,
          borderRadius: 0
        }),
        path,
        ($$invalidate(7, labelX), $$invalidate(9, sourceX), $$invalidate(10, sourceY), $$invalidate(12, targetX), $$invalidate(13, targetY), $$invalidate(11, sourcePosition), $$invalidate(14, targetPosition)),
        ($$invalidate(6, labelY), $$invalidate(9, sourceX), $$invalidate(10, sourceY), $$invalidate(12, targetX), $$invalidate(13, targetY), $$invalidate(11, sourcePosition), $$invalidate(14, targetPosition))
      );
    }
  };
  return [
    label,
    labelStyle,
    style,
    markerStart,
    markerEnd,
    interactionWidth,
    labelY,
    labelX,
    path,
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition
  ];
}
var StepEdgeInternal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, {
      label: 0,
      labelStyle: 1,
      style: 2,
      markerStart: 3,
      markerEnd: 4,
      interactionWidth: 5,
      sourceX: 9,
      sourceY: 10,
      sourcePosition: 11,
      targetX: 12,
      targetY: 13,
      targetPosition: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StepEdgeInternal",
      options,
      id: create_fragment16.name
    });
  }
  get label() {
    throw new Error("<StepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<StepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelStyle() {
    throw new Error("<StepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelStyle(value) {
    throw new Error("<StepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<StepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<StepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerStart() {
    throw new Error("<StepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerStart(value) {
    throw new Error("<StepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerEnd() {
    throw new Error("<StepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerEnd(value) {
    throw new Error("<StepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactionWidth() {
    throw new Error("<StepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactionWidth(value) {
    throw new Error("<StepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceX() {
    throw new Error("<StepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceX(value) {
    throw new Error("<StepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceY() {
    throw new Error("<StepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceY(value) {
    throw new Error("<StepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<StepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<StepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetX() {
    throw new Error("<StepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetX(value) {
    throw new Error("<StepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetY() {
    throw new Error("<StepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetY(value) {
    throw new Error("<StepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<StepEdgeInternal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<StepEdgeInternal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StepEdgeInternal_default = StepEdgeInternal;

// node_modules/@xyflow/svelte/dist/lib/store/utils.js
function syncNodeStores(nodesStore, userNodesStore) {
  const nodesStoreSetter = nodesStore.set;
  const userNodesStoreSetter = userNodesStore.set;
  const currentNodesStore = get_store_value(nodesStore);
  const currentUserNodesStore = get_store_value(userNodesStore);
  const initWithUserNodes = currentNodesStore.length === 0 && currentUserNodesStore.length > 0;
  let val = initWithUserNodes ? currentUserNodesStore : currentNodesStore;
  nodesStore.set(val);
  const _set = (nds) => {
    const updatedNodes = nodesStoreSetter(nds);
    val = updatedNodes;
    userNodesStoreSetter(val);
    return updatedNodes;
  };
  nodesStore.set = userNodesStore.set = _set;
  nodesStore.update = userNodesStore.update = (fn) => _set(fn(val));
}
function syncEdgeStores(edgesStore, userEdgesStore) {
  const nodesStoreSetter = edgesStore.set;
  const userEdgesStoreSetter = userEdgesStore.set;
  let val = get_store_value(userEdgesStore);
  edgesStore.set(val);
  const _set = (eds) => {
    nodesStoreSetter(eds);
    userEdgesStoreSetter(eds);
    val = eds;
  };
  edgesStore.set = userEdgesStore.set = _set;
  edgesStore.update = userEdgesStore.update = (fn) => _set(fn(val));
}
var syncViewportStores = (panZoomStore, viewportStore, userViewportStore) => {
  if (!userViewportStore) {
    return;
  }
  const panZoom = get_store_value(panZoomStore);
  const viewportStoreSetter = viewportStore.set;
  const userViewportStoreSetter = userViewportStore.set;
  let val = userViewportStore ? get_store_value(userViewportStore) : { x: 0, y: 0, zoom: 1 };
  viewportStore.set(val);
  viewportStore.set = (vp) => {
    viewportStoreSetter(vp);
    userViewportStoreSetter(vp);
    val = vp;
    return vp;
  };
  userViewportStore.set = (vp) => {
    panZoom == null ? void 0 : panZoom.syncViewport(vp);
    viewportStoreSetter(vp);
    userViewportStoreSetter(vp);
    val = vp;
    return vp;
  };
  viewportStore.update = (fn) => {
    viewportStore.set(fn(val));
  };
  userViewportStore.update = (fn) => {
    userViewportStore.set(fn(val));
  };
};
var createNodesStore = (nodes, nodeLookup, parentLookup, nodeOrigin = [0, 0]) => {
  const { subscribe: subscribe2, set: set3, update } = writable([]);
  let value = nodes;
  let defaults = {};
  let elevateNodesOnSelect = true;
  const _set = (nds) => {
    adoptUserNodes(nds, nodeLookup, parentLookup, {
      elevateNodesOnSelect,
      nodeOrigin,
      defaults,
      checkEquality: false
    });
    value = nds;
    set3(value);
    return value;
  };
  const _update = (fn) => _set(fn(value));
  const setDefaultOptions = (options) => {
    defaults = options;
  };
  const setOptions = (options) => {
    elevateNodesOnSelect = options.elevateNodesOnSelect ?? elevateNodesOnSelect;
  };
  _set(value);
  return {
    subscribe: subscribe2,
    set: _set,
    update: _update,
    setDefaultOptions,
    setOptions
  };
};
var createEdgesStore = (edges, connectionLookup, edgeLookup, defaultOptions2) => {
  const { subscribe: subscribe2, set: set3, update } = writable([]);
  let value = edges;
  let defaults = defaultOptions2 || {};
  const _set = (eds) => {
    const nextEdges = defaults ? eds.map((edge) => ({ ...defaults, ...edge })) : eds;
    updateConnectionLookup(connectionLookup, edgeLookup, nextEdges);
    value = nextEdges;
    set3(value);
  };
  const _update = (fn) => _set(fn(value));
  const setDefaultOptions = (options) => {
    defaults = options;
  };
  _set(value);
  return {
    subscribe: subscribe2,
    set: _set,
    update: _update,
    setDefaultOptions
  };
};

// node_modules/@xyflow/svelte/dist/lib/store/initial-store.js
var initialNodeTypes = {
  input: InputNode_default,
  output: OutputNode_default,
  default: DefaultNode_default,
  group: GroupNode_default
};
var initialEdgeTypes = {
  straight: StraightEdgeInternal_default,
  smoothstep: SmoothStepEdgeInternal_default,
  default: BezierEdgeInternal_default,
  step: StepEdgeInternal_default
};
var getInitialStore = ({ nodes = [], edges = [], width, height, fitView: fitView2, nodeOrigin }) => {
  const nodeLookup = /* @__PURE__ */ new Map();
  const parentLookup = /* @__PURE__ */ new Map();
  const storeNodeOrigin = nodeOrigin ?? [0, 0];
  adoptUserNodes(nodes, nodeLookup, parentLookup, {
    nodeOrigin: storeNodeOrigin,
    elevateNodesOnSelect: false,
    checkEquality: false
  });
  const connectionLookup = /* @__PURE__ */ new Map();
  const edgeLookup = /* @__PURE__ */ new Map();
  updateConnectionLookup(connectionLookup, edgeLookup, edges);
  let viewport = { x: 0, y: 0, zoom: 1 };
  if (fitView2 && width && height) {
    const bounds = getInternalNodesBounds(nodeLookup, {
      filter: (node) => !!((node.width || node.initialWidth) && (node.height || node.initialHeight))
    });
    viewport = getViewportForBounds(bounds, width, height, 0.5, 2, 0.1);
  }
  return {
    flowId: writable(null),
    nodes: createNodesStore(nodes, nodeLookup, parentLookup, storeNodeOrigin),
    nodeLookup: readable(nodeLookup),
    parentLookup: readable(parentLookup),
    edgeLookup: readable(edgeLookup),
    visibleNodes: readable([]),
    edges: createEdgesStore(edges, connectionLookup, edgeLookup),
    visibleEdges: readable([]),
    connectionLookup: readable(connectionLookup),
    height: writable(500),
    width: writable(500),
    minZoom: writable(0.5),
    maxZoom: writable(2),
    nodeOrigin: writable(storeNodeOrigin),
    nodeDragThreshold: writable(1),
    nodeExtent: writable(infiniteExtent),
    translateExtent: writable(infiniteExtent),
    autoPanOnNodeDrag: writable(true),
    autoPanOnConnect: writable(true),
    fitViewOnInit: writable(false),
    fitViewOnInitDone: writable(false),
    fitViewOptions: writable(void 0),
    panZoom: writable(null),
    snapGrid: writable(null),
    dragging: writable(false),
    selectionRect: writable(null),
    selectionKeyPressed: writable(false),
    multiselectionKeyPressed: writable(false),
    deleteKeyPressed: writable(false),
    panActivationKeyPressed: writable(false),
    zoomActivationKeyPressed: writable(false),
    selectionRectMode: writable(null),
    selectionMode: writable(SelectionMode.Partial),
    nodeTypes: writable(initialNodeTypes),
    edgeTypes: writable(initialEdgeTypes),
    viewport: writable(viewport),
    connectionMode: writable(ConnectionMode.Strict),
    domNode: writable(null),
    connection: readable(initialConnection),
    connectionLineType: writable(ConnectionLineType.Bezier),
    connectionRadius: writable(20),
    isValidConnection: writable(() => true),
    nodesDraggable: writable(true),
    nodesConnectable: writable(true),
    elementsSelectable: writable(true),
    selectNodesOnDrag: writable(true),
    markers: readable([]),
    defaultMarkerColor: writable("#b1b1b7"),
    lib: readable("svelte"),
    onlyRenderVisibleElements: writable(false),
    onerror: writable(devWarn),
    ondelete: writable(void 0),
    onedgecreate: writable(void 0),
    onconnect: writable(void 0),
    onconnectstart: writable(void 0),
    onconnectend: writable(void 0),
    onbeforedelete: writable(void 0),
    nodesInitialized: writable(false),
    edgesInitialized: writable(false),
    viewportInitialized: writable(false),
    initialized: readable(false)
  };
};

// node_modules/@xyflow/svelte/dist/lib/store/visible-edges.js
function getVisibleEdges(store) {
  const visibleEdges = derived([
    store.edges,
    store.nodes,
    store.nodeLookup,
    store.onlyRenderVisibleElements,
    store.viewport,
    store.width,
    store.height
  ], ([edges, , nodeLookup, onlyRenderVisibleElements, viewport, width, height]) => {
    const visibleEdges2 = onlyRenderVisibleElements && width && height ? edges.filter((edge) => {
      const sourceNode = nodeLookup.get(edge.source);
      const targetNode = nodeLookup.get(edge.target);
      return sourceNode && targetNode && isEdgeVisible({
        sourceNode,
        targetNode,
        width,
        height,
        transform: [viewport.x, viewport.y, viewport.zoom]
      });
    }) : edges;
    return visibleEdges2;
  });
  return derived([visibleEdges, store.nodes, store.nodeLookup, store.connectionMode, store.onerror], ([visibleEdges2, , nodeLookup, connectionMode, onerror]) => {
    const layoutedEdges = visibleEdges2.reduce((res, edge) => {
      const sourceNode = nodeLookup.get(edge.source);
      const targetNode = nodeLookup.get(edge.target);
      if (!sourceNode || !targetNode) {
        return res;
      }
      const edgePosition = getEdgePosition({
        id: edge.id,
        sourceNode,
        targetNode,
        sourceHandle: edge.sourceHandle || null,
        targetHandle: edge.targetHandle || null,
        connectionMode,
        onError: onerror
      });
      if (edgePosition) {
        res.push({
          ...edge,
          zIndex: getElevatedEdgeZIndex({
            selected: edge.selected,
            zIndex: edge.zIndex,
            sourceNode,
            targetNode,
            elevateOnSelect: false
          }),
          ...edgePosition
        });
      }
      return res;
    }, []);
    return layoutedEdges;
  });
}

// node_modules/@xyflow/svelte/dist/lib/store/visible-nodes.js
function getVisibleNodes(store) {
  return derived([
    store.nodeLookup,
    store.onlyRenderVisibleElements,
    store.width,
    store.height,
    store.viewport,
    store.nodes
  ], ([nodeLookup, onlyRenderVisibleElements, width, height, viewport]) => {
    const transform2 = [viewport.x, viewport.y, viewport.zoom];
    return onlyRenderVisibleElements ? getNodesInside(nodeLookup, { x: 0, y: 0, width, height }, transform2, true) : Array.from(nodeLookup.values());
  });
}

// node_modules/@xyflow/svelte/dist/lib/store/index.js
var key = Symbol();
function createStore({ nodes, edges, width, height, fitView: fitViewOnCreate, nodeOrigin }) {
  const store = getInitialStore({
    nodes,
    edges,
    width,
    height,
    fitView: fitViewOnCreate,
    nodeOrigin
  });
  function setNodeTypes(nodeTypes) {
    store.nodeTypes.set({
      ...initialNodeTypes,
      ...nodeTypes
    });
  }
  function setEdgeTypes(edgeTypes) {
    store.edgeTypes.set({
      ...initialEdgeTypes,
      ...edgeTypes
    });
  }
  function addEdge2(edgeParams) {
    const edges2 = get_store_value(store.edges);
    store.edges.set(addEdge(edgeParams, edges2));
  }
  const updateNodePositions = (nodeDragItems, dragging = false) => {
    var _a;
    const nodeLookup = get_store_value(store.nodeLookup);
    for (const [id2, dragItem] of nodeDragItems) {
      const node = (_a = nodeLookup.get(id2)) == null ? void 0 : _a.internals.userNode;
      if (!node) {
        continue;
      }
      node.position = dragItem.position;
      node.dragging = dragging;
    }
    store.nodes.update((nds) => nds);
  };
  function updateNodeInternals2(updates) {
    var _a, _b, _c;
    const nodeLookup = get_store_value(store.nodeLookup);
    const { changes, updatedInternals } = updateNodeInternals(updates, nodeLookup, get_store_value(store.parentLookup), get_store_value(store.domNode), get_store_value(store.nodeOrigin));
    if (!updatedInternals) {
      return;
    }
    if (!get_store_value(store.fitViewOnInitDone) && get_store_value(store.fitViewOnInit)) {
      const fitViewOptions = get_store_value(store.fitViewOptions);
      const fitViewOnInitDone = fitViewSync({
        ...fitViewOptions,
        nodes: fitViewOptions == null ? void 0 : fitViewOptions.nodes
      });
      store.fitViewOnInitDone.set(fitViewOnInitDone);
    }
    for (const change of changes) {
      const node = (_a = nodeLookup.get(change.id)) == null ? void 0 : _a.internals.userNode;
      if (!node) {
        continue;
      }
      switch (change.type) {
        case "dimensions": {
          const measured = { ...node.measured, ...change.dimensions };
          if (change.setAttributes) {
            node.width = ((_b = change.dimensions) == null ? void 0 : _b.width) ?? node.width;
            node.height = ((_c = change.dimensions) == null ? void 0 : _c.height) ?? node.height;
          }
          node.measured = measured;
          break;
        }
        case "position":
          node.position = change.position ?? node.position;
          break;
      }
    }
    store.nodes.update((nds) => nds);
    if (!get_store_value(store.nodesInitialized)) {
      store.nodesInitialized.set(true);
    }
  }
  function fitView2(options) {
    const panZoom = get_store_value(store.panZoom);
    if (!panZoom) {
      return Promise.resolve(false);
    }
    const fitViewNodes = getFitViewNodes(get_store_value(store.nodeLookup), options);
    return fitView({
      nodes: fitViewNodes,
      width: get_store_value(store.width),
      height: get_store_value(store.height),
      minZoom: get_store_value(store.minZoom),
      maxZoom: get_store_value(store.maxZoom),
      panZoom
    }, options);
  }
  function fitViewSync(options) {
    const panZoom = get_store_value(store.panZoom);
    if (!panZoom) {
      return false;
    }
    const fitViewNodes = getFitViewNodes(get_store_value(store.nodeLookup), options);
    fitView({
      nodes: fitViewNodes,
      width: get_store_value(store.width),
      height: get_store_value(store.height),
      minZoom: get_store_value(store.minZoom),
      maxZoom: get_store_value(store.maxZoom),
      panZoom
    }, options);
    return fitViewNodes.size > 0;
  }
  function zoomBy(factor, options) {
    const panZoom = get_store_value(store.panZoom);
    if (!panZoom) {
      return Promise.resolve(false);
    }
    return panZoom.scaleBy(factor, options);
  }
  function zoomIn(options) {
    return zoomBy(1.2, options);
  }
  function zoomOut(options) {
    return zoomBy(1 / 1.2, options);
  }
  function setMinZoom(minZoom) {
    const panZoom = get_store_value(store.panZoom);
    if (panZoom) {
      panZoom.setScaleExtent([minZoom, get_store_value(store.maxZoom)]);
      store.minZoom.set(minZoom);
    }
  }
  function setMaxZoom(maxZoom) {
    const panZoom = get_store_value(store.panZoom);
    if (panZoom) {
      panZoom.setScaleExtent([get_store_value(store.minZoom), maxZoom]);
      store.maxZoom.set(maxZoom);
    }
  }
  function setTranslateExtent(extent) {
    const panZoom = get_store_value(store.panZoom);
    if (panZoom) {
      panZoom.setTranslateExtent(extent);
      store.translateExtent.set(extent);
    }
  }
  function resetSelectedElements(elements) {
    let elementsChanged = false;
    elements.forEach((element2) => {
      if (element2.selected) {
        element2.selected = false;
        elementsChanged = true;
      }
    });
    return elementsChanged;
  }
  function setPaneClickDistance(distance2) {
    var _a;
    (_a = get_store_value(store.panZoom)) == null ? void 0 : _a.setClickDistance(distance2);
  }
  function unselectNodesAndEdges(params) {
    const resetNodes = resetSelectedElements((params == null ? void 0 : params.nodes) || get_store_value(store.nodes));
    if (resetNodes)
      store.nodes.set(get_store_value(store.nodes));
    const resetEdges = resetSelectedElements((params == null ? void 0 : params.edges) || get_store_value(store.edges));
    if (resetEdges)
      store.edges.set(get_store_value(store.edges));
  }
  store.deleteKeyPressed.subscribe(async (deleteKeyPressed) => {
    var _a;
    if (deleteKeyPressed) {
      const nodes2 = get_store_value(store.nodes);
      const edges2 = get_store_value(store.edges);
      const selectedNodes = nodes2.filter((node) => node.selected);
      const selectedEdges = edges2.filter((edge) => edge.selected);
      const { nodes: matchingNodes, edges: matchingEdges } = await getElementsToRemove({
        nodesToRemove: selectedNodes,
        edgesToRemove: selectedEdges,
        nodes: nodes2,
        edges: edges2,
        onBeforeDelete: get_store_value(store.onbeforedelete)
      });
      if (matchingNodes.length || matchingEdges.length) {
        store.nodes.update((nds) => nds.filter((node) => !matchingNodes.some((mN) => mN.id === node.id)));
        store.edges.update((eds) => eds.filter((edge) => !matchingEdges.some((mE) => mE.id === edge.id)));
        (_a = get_store_value(store.ondelete)) == null ? void 0 : _a({
          nodes: matchingNodes,
          edges: matchingEdges
        });
      }
    }
  });
  function addSelectedNodes(ids) {
    const isMultiSelection = get_store_value(store.multiselectionKeyPressed);
    store.nodes.update((ns) => ns.map((node) => {
      const nodeWillBeSelected = ids.includes(node.id);
      const selected = isMultiSelection ? node.selected || nodeWillBeSelected : nodeWillBeSelected;
      node.selected = selected;
      return node;
    }));
    if (!isMultiSelection) {
      store.edges.update((es) => es.map((edge) => {
        edge.selected = false;
        return edge;
      }));
    }
  }
  function addSelectedEdges(ids) {
    const isMultiSelection = get_store_value(store.multiselectionKeyPressed);
    store.edges.update((edges2) => edges2.map((edge) => {
      const edgeWillBeSelected = ids.includes(edge.id);
      const selected = isMultiSelection ? edge.selected || edgeWillBeSelected : edgeWillBeSelected;
      edge.selected = selected;
      return edge;
    }));
    if (!isMultiSelection) {
      store.nodes.update((ns) => ns.map((node) => {
        node.selected = false;
        return node;
      }));
    }
  }
  function handleNodeSelection(id2) {
    var _a;
    const node = (_a = get_store_value(store.nodes)) == null ? void 0 : _a.find((n) => n.id === id2);
    if (!node) {
      console.warn("012", errorMessages["error012"](id2));
      return;
    }
    store.selectionRect.set(null);
    store.selectionRectMode.set(null);
    if (!node.selected) {
      addSelectedNodes([id2]);
    } else if (node.selected && get_store_value(store.multiselectionKeyPressed)) {
      unselectNodesAndEdges({ nodes: [node], edges: [] });
    }
  }
  function panBy2(delta) {
    const viewport = get_store_value(store.viewport);
    return panBy({
      delta,
      panZoom: get_store_value(store.panZoom),
      transform: [viewport.x, viewport.y, viewport.zoom],
      translateExtent: get_store_value(store.translateExtent),
      width: get_store_value(store.width),
      height: get_store_value(store.height)
    });
  }
  const _connection = writable(initialConnection);
  const updateConnection = (newConnection) => {
    _connection.set({ ...newConnection });
  };
  function cancelConnection() {
    _connection.set(initialConnection);
  }
  function reset() {
    store.fitViewOnInitDone.set(false);
    store.selectionRect.set(null);
    store.selectionRectMode.set(null);
    store.snapGrid.set(null);
    store.isValidConnection.set(() => true);
    unselectNodesAndEdges();
    cancelConnection();
  }
  return {
    // state
    ...store,
    // derived state
    visibleEdges: getVisibleEdges(store),
    visibleNodes: getVisibleNodes(store),
    connection: derived([_connection, store.viewport], ([connection, viewport]) => {
      return connection.inProgress ? {
        ...connection,
        to: pointToRendererPoint(connection.to, [viewport.x, viewport.y, viewport.zoom])
      } : { ...connection };
    }),
    markers: derived([store.edges, store.defaultMarkerColor, store.flowId], ([edges2, defaultColor, id2]) => createMarkerIds(edges2, { defaultColor, id: id2 })),
    initialized: (() => {
      let initialized = false;
      const initialNodesLength = get_store_value(store.nodes).length;
      const initialEdgesLength = get_store_value(store.edges).length;
      return derived([store.nodesInitialized, store.edgesInitialized, store.viewportInitialized], ([nodesInitialized, edgesInitialized, viewportInitialized]) => {
        if (initialized)
          return initialized;
        if (initialNodesLength === 0) {
          initialized = viewportInitialized;
        } else if (initialEdgesLength === 0) {
          initialized = viewportInitialized && nodesInitialized;
        } else {
          initialized = viewportInitialized && nodesInitialized && edgesInitialized;
        }
        return initialized;
      });
    })(),
    // actions
    syncNodeStores: (nodes2) => syncNodeStores(store.nodes, nodes2),
    syncEdgeStores: (edges2) => syncEdgeStores(store.edges, edges2),
    syncViewport: (viewport) => syncViewportStores(store.panZoom, store.viewport, viewport),
    setNodeTypes,
    setEdgeTypes,
    addEdge: addEdge2,
    updateNodePositions,
    updateNodeInternals: updateNodeInternals2,
    zoomIn,
    zoomOut,
    fitView: (options) => fitView2(options),
    setMinZoom,
    setMaxZoom,
    setTranslateExtent,
    setPaneClickDistance,
    unselectNodesAndEdges,
    addSelectedNodes,
    addSelectedEdges,
    handleNodeSelection,
    panBy: panBy2,
    updateConnection,
    cancelConnection,
    reset
  };
}
function useStore() {
  const store = getContext(key);
  if (!store) {
    throw new Error("In order to use useStore you need to wrap your component in a <SvelteFlowProvider />");
  }
  return store.getStore();
}
function createStoreContext({ nodes, edges, width, height, fitView: fitView2, nodeOrigin }) {
  const store = createStore({ nodes, edges, width, height, fitView: fitView2, nodeOrigin });
  setContext(key, {
    getStore: () => store
  });
  return store;
}

// node_modules/@xyflow/svelte/dist/lib/actions/zoom/index.js
function zoom(domNode, params) {
  const { panZoom, minZoom, maxZoom, initialViewport, viewport, dragging, translateExtent, paneClickDistance } = params;
  const panZoomInstance = XYPanZoom({
    domNode,
    minZoom,
    maxZoom,
    translateExtent,
    viewport: initialViewport,
    paneClickDistance,
    onTransformChange: (transform2) => viewport.set({ x: transform2[0], y: transform2[1], zoom: transform2[2] }),
    onDraggingChange: dragging.set
  });
  const currentViewport = panZoomInstance.getViewport();
  viewport.set(currentViewport);
  panZoom.set(panZoomInstance);
  panZoomInstance.update(params);
  return {
    update(params2) {
      panZoomInstance.update(params2);
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/container/Zoom/Zoom.svelte
var file5 = "node_modules/@xyflow/svelte/dist/lib/container/Zoom/Zoom.svelte";
function add_css(target) {
  append_styles(target, "svelte-4xkw84", ".svelte-flow__zoom.svelte-4xkw84{width:100%;height:100%;position:absolute;top:0;left:0;z-index:4}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiWm9vbS5zdmVsdGUiLCJzb3VyY2VzIjpbIlpvb20uc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+aW1wb3J0IHsgUGFuT25TY3JvbGxNb2RlIH0gZnJvbSAnQHh5Zmxvdy9zeXN0ZW0nO1xuaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICcuLi8uLi9zdG9yZSc7XG5pbXBvcnQgem9vbSBmcm9tICcuLi8uLi9hY3Rpb25zL3pvb20nO1xuaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gJ3N2ZWx0ZSc7XG5leHBvcnQgbGV0IGluaXRpYWxWaWV3cG9ydCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgb25Nb3ZlU3RhcnQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IG9uTW92ZSA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgb25Nb3ZlRW5kID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBwYW5PblNjcm9sbE1vZGU7XG5leHBvcnQgbGV0IHByZXZlbnRTY3JvbGxpbmc7XG5leHBvcnQgbGV0IHpvb21PblNjcm9sbDtcbmV4cG9ydCBsZXQgem9vbU9uRG91YmxlQ2xpY2s7XG5leHBvcnQgbGV0IHpvb21PblBpbmNoO1xuZXhwb3J0IGxldCBwYW5PbkRyYWc7XG5leHBvcnQgbGV0IHBhbk9uU2Nyb2xsO1xuZXhwb3J0IGxldCBwYW5lQ2xpY2tEaXN0YW5jZTtcbmNvbnN0IHsgdmlld3BvcnQsIHBhblpvb20sIHNlbGVjdGlvblJlY3QsIG1pblpvb20sIG1heFpvb20sIGRyYWdnaW5nLCB0cmFuc2xhdGVFeHRlbnQsIGxpYiwgcGFuQWN0aXZhdGlvbktleVByZXNzZWQsIHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCwgdmlld3BvcnRJbml0aWFsaXplZCB9ID0gdXNlU3RvcmUoKTtcbiQ6IHZpZXdQb3J0ID0gaW5pdGlhbFZpZXdwb3J0IHx8IHsgeDogMCwgeTogMCwgem9vbTogMSB9O1xuJDogX3Bhbk9uRHJhZyA9ICRwYW5BY3RpdmF0aW9uS2V5UHJlc3NlZCB8fCBwYW5PbkRyYWc7XG4kOiBfcGFuT25TY3JvbGwgPSAkcGFuQWN0aXZhdGlvbktleVByZXNzZWQgfHwgcGFuT25TY3JvbGw7XG5vbk1vdW50KCgpID0+IHtcbiAgICAkdmlld3BvcnRJbml0aWFsaXplZCA9IHRydWU7XG59KTtcbjwvc2NyaXB0PlxuXG48ZGl2XG4gIGNsYXNzPVwic3ZlbHRlLWZsb3dfX3pvb21cIlxuICB1c2U6em9vbT17e1xuICAgIHZpZXdwb3J0LFxuICAgIG1pblpvb206ICRtaW5ab29tLFxuICAgIG1heFpvb206ICRtYXhab29tLFxuICAgIGluaXRpYWxWaWV3cG9ydDogdmlld1BvcnQsXG4gICAgZHJhZ2dpbmcsXG4gICAgcGFuWm9vbSxcbiAgICBvblBhblpvb21TdGFydDogb25Nb3ZlU3RhcnQsXG4gICAgb25QYW5ab29tOiBvbk1vdmUsXG4gICAgb25QYW5ab29tRW5kOiBvbk1vdmVFbmQsXG4gICAgem9vbU9uU2Nyb2xsLFxuICAgIHpvb21PbkRvdWJsZUNsaWNrLFxuICAgIHpvb21PblBpbmNoLFxuICAgIHBhbk9uU2Nyb2xsOiBfcGFuT25TY3JvbGwsXG4gICAgcGFuT25EcmFnOiBfcGFuT25EcmFnLFxuICAgIHBhbk9uU2Nyb2xsU3BlZWQ6IDAuNSxcbiAgICBwYW5PblNjcm9sbE1vZGU6IHBhbk9uU2Nyb2xsTW9kZSB8fCBQYW5PblNjcm9sbE1vZGUuRnJlZSxcbiAgICB6b29tQWN0aXZhdGlvbktleVByZXNzZWQ6ICR6b29tQWN0aXZhdGlvbktleVByZXNzZWQsXG4gICAgcHJldmVudFNjcm9sbGluZzogdHlwZW9mIHByZXZlbnRTY3JvbGxpbmcgPT09ICdib29sZWFuJyA/IHByZXZlbnRTY3JvbGxpbmcgOiB0cnVlLFxuICAgIG5vUGFuQ2xhc3NOYW1lOiAnbm9wYW4nLFxuICAgIG5vV2hlZWxDbGFzc05hbWU6ICdub3doZWVsJyxcbiAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiAhISRzZWxlY3Rpb25SZWN0LFxuICAgIHRyYW5zbGF0ZUV4dGVudDogJHRyYW5zbGF0ZUV4dGVudCxcbiAgICBsaWI6ICRsaWIsXG4gICAgcGFuZUNsaWNrRGlzdGFuY2VcbiAgfX1cbj5cbiAgPHNsb3QgLz5cbjwvZGl2PlxuXG48c3R5bGU+XG4gIC5zdmVsdGUtZmxvd19fem9vbSB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICB6LWluZGV4OiA0O1xuICB9XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTBERSxnQ0FBbUIsQ0FDakIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxDQUFDLENBQ04sSUFBSSxDQUFFLENBQUMsQ0FDUCxPQUFPLENBQUUsQ0FDWCJ9 */");
}
function create_fragment17(ctx) {
  let div;
  let zoom_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[34].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[33],
    null
  );
  const block = {
    c: function create2() {
      div = element("div");
      if (default_slot) default_slot.c();
      attr_dev(div, "class", "svelte-flow__zoom svelte-4xkw84");
      add_location(div, file5, 25, 0, 939);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(zoom_action = zoom.call(null, div, {
          viewport: (
            /*viewport*/
            ctx[18]
          ),
          minZoom: (
            /*$minZoom*/
            ctx[12]
          ),
          maxZoom: (
            /*$maxZoom*/
            ctx[13]
          ),
          initialViewport: (
            /*viewPort*/
            ctx[11]
          ),
          dragging: (
            /*dragging*/
            ctx[23]
          ),
          panZoom: (
            /*panZoom*/
            ctx[19]
          ),
          onPanZoomStart: (
            /*onMoveStart*/
            ctx[0]
          ),
          onPanZoom: (
            /*onMove*/
            ctx[1]
          ),
          onPanZoomEnd: (
            /*onMoveEnd*/
            ctx[2]
          ),
          zoomOnScroll: (
            /*zoomOnScroll*/
            ctx[5]
          ),
          zoomOnDoubleClick: (
            /*zoomOnDoubleClick*/
            ctx[6]
          ),
          zoomOnPinch: (
            /*zoomOnPinch*/
            ctx[7]
          ),
          panOnScroll: (
            /*_panOnScroll*/
            ctx[9]
          ),
          panOnDrag: (
            /*_panOnDrag*/
            ctx[10]
          ),
          panOnScrollSpeed: 0.5,
          panOnScrollMode: (
            /*panOnScrollMode*/
            ctx[3] || PanOnScrollMode.Free
          ),
          zoomActivationKeyPressed: (
            /*$zoomActivationKeyPressed*/
            ctx[14]
          ),
          preventScrolling: typeof /*preventScrolling*/
          ctx[4] === "boolean" ? (
            /*preventScrolling*/
            ctx[4]
          ) : true,
          noPanClassName: "nopan",
          noWheelClassName: "nowheel",
          userSelectionActive: !!/*$selectionRect*/
          ctx[15],
          translateExtent: (
            /*$translateExtent*/
            ctx[16]
          ),
          lib: (
            /*$lib*/
            ctx[17]
          ),
          paneClickDistance: (
            /*paneClickDistance*/
            ctx[8]
          )
        }));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[33],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[33]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[33],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (zoom_action && is_function(zoom_action.update) && dirty[0] & /*$minZoom, $maxZoom, viewPort, onMoveStart, onMove, onMoveEnd, zoomOnScroll, zoomOnDoubleClick, zoomOnPinch, _panOnScroll, _panOnDrag, panOnScrollMode, $zoomActivationKeyPressed, preventScrolling, $selectionRect, $translateExtent, $lib, paneClickDistance*/
      262143) zoom_action.update.call(null, {
        viewport: (
          /*viewport*/
          ctx2[18]
        ),
        minZoom: (
          /*$minZoom*/
          ctx2[12]
        ),
        maxZoom: (
          /*$maxZoom*/
          ctx2[13]
        ),
        initialViewport: (
          /*viewPort*/
          ctx2[11]
        ),
        dragging: (
          /*dragging*/
          ctx2[23]
        ),
        panZoom: (
          /*panZoom*/
          ctx2[19]
        ),
        onPanZoomStart: (
          /*onMoveStart*/
          ctx2[0]
        ),
        onPanZoom: (
          /*onMove*/
          ctx2[1]
        ),
        onPanZoomEnd: (
          /*onMoveEnd*/
          ctx2[2]
        ),
        zoomOnScroll: (
          /*zoomOnScroll*/
          ctx2[5]
        ),
        zoomOnDoubleClick: (
          /*zoomOnDoubleClick*/
          ctx2[6]
        ),
        zoomOnPinch: (
          /*zoomOnPinch*/
          ctx2[7]
        ),
        panOnScroll: (
          /*_panOnScroll*/
          ctx2[9]
        ),
        panOnDrag: (
          /*_panOnDrag*/
          ctx2[10]
        ),
        panOnScrollSpeed: 0.5,
        panOnScrollMode: (
          /*panOnScrollMode*/
          ctx2[3] || PanOnScrollMode.Free
        ),
        zoomActivationKeyPressed: (
          /*$zoomActivationKeyPressed*/
          ctx2[14]
        ),
        preventScrolling: typeof /*preventScrolling*/
        ctx2[4] === "boolean" ? (
          /*preventScrolling*/
          ctx2[4]
        ) : true,
        noPanClassName: "nopan",
        noWheelClassName: "nowheel",
        userSelectionActive: !!/*$selectionRect*/
        ctx2[15],
        translateExtent: (
          /*$translateExtent*/
          ctx2[16]
        ),
        lib: (
          /*$lib*/
          ctx2[17]
        ),
        paneClickDistance: (
          /*paneClickDistance*/
          ctx2[8]
        )
      });
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(default_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(default_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let viewPort;
  let _panOnDrag;
  let _panOnScroll;
  let $viewportInitialized;
  let $panActivationKeyPressed;
  let $minZoom;
  let $maxZoom;
  let $zoomActivationKeyPressed;
  let $selectionRect;
  let $translateExtent;
  let $lib;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Zoom", slots, ["default"]);
  let { initialViewport = void 0 } = $$props;
  let { onMoveStart = void 0 } = $$props;
  let { onMove = void 0 } = $$props;
  let { onMoveEnd = void 0 } = $$props;
  let { panOnScrollMode } = $$props;
  let { preventScrolling } = $$props;
  let { zoomOnScroll } = $$props;
  let { zoomOnDoubleClick } = $$props;
  let { zoomOnPinch } = $$props;
  let { panOnDrag } = $$props;
  let { panOnScroll } = $$props;
  let { paneClickDistance } = $$props;
  const { viewport, panZoom, selectionRect, minZoom, maxZoom, dragging, translateExtent, lib, panActivationKeyPressed, zoomActivationKeyPressed, viewportInitialized } = useStore();
  validate_store(selectionRect, "selectionRect");
  component_subscribe($$self, selectionRect, (value) => $$invalidate(15, $selectionRect = value));
  validate_store(minZoom, "minZoom");
  component_subscribe($$self, minZoom, (value) => $$invalidate(12, $minZoom = value));
  validate_store(maxZoom, "maxZoom");
  component_subscribe($$self, maxZoom, (value) => $$invalidate(13, $maxZoom = value));
  validate_store(translateExtent, "translateExtent");
  component_subscribe($$self, translateExtent, (value) => $$invalidate(16, $translateExtent = value));
  validate_store(lib, "lib");
  component_subscribe($$self, lib, (value) => $$invalidate(17, $lib = value));
  validate_store(panActivationKeyPressed, "panActivationKeyPressed");
  component_subscribe($$self, panActivationKeyPressed, (value) => $$invalidate(32, $panActivationKeyPressed = value));
  validate_store(zoomActivationKeyPressed, "zoomActivationKeyPressed");
  component_subscribe($$self, zoomActivationKeyPressed, (value) => $$invalidate(14, $zoomActivationKeyPressed = value));
  validate_store(viewportInitialized, "viewportInitialized");
  component_subscribe($$self, viewportInitialized, (value) => $$invalidate(35, $viewportInitialized = value));
  onMount(() => {
    set_store_value(viewportInitialized, $viewportInitialized = true, $viewportInitialized);
  });
  $$self.$$.on_mount.push(function() {
    if (panOnScrollMode === void 0 && !("panOnScrollMode" in $$props || $$self.$$.bound[$$self.$$.props["panOnScrollMode"]])) {
      console.warn("<Zoom> was created without expected prop 'panOnScrollMode'");
    }
    if (preventScrolling === void 0 && !("preventScrolling" in $$props || $$self.$$.bound[$$self.$$.props["preventScrolling"]])) {
      console.warn("<Zoom> was created without expected prop 'preventScrolling'");
    }
    if (zoomOnScroll === void 0 && !("zoomOnScroll" in $$props || $$self.$$.bound[$$self.$$.props["zoomOnScroll"]])) {
      console.warn("<Zoom> was created without expected prop 'zoomOnScroll'");
    }
    if (zoomOnDoubleClick === void 0 && !("zoomOnDoubleClick" in $$props || $$self.$$.bound[$$self.$$.props["zoomOnDoubleClick"]])) {
      console.warn("<Zoom> was created without expected prop 'zoomOnDoubleClick'");
    }
    if (zoomOnPinch === void 0 && !("zoomOnPinch" in $$props || $$self.$$.bound[$$self.$$.props["zoomOnPinch"]])) {
      console.warn("<Zoom> was created without expected prop 'zoomOnPinch'");
    }
    if (panOnDrag === void 0 && !("panOnDrag" in $$props || $$self.$$.bound[$$self.$$.props["panOnDrag"]])) {
      console.warn("<Zoom> was created without expected prop 'panOnDrag'");
    }
    if (panOnScroll === void 0 && !("panOnScroll" in $$props || $$self.$$.bound[$$self.$$.props["panOnScroll"]])) {
      console.warn("<Zoom> was created without expected prop 'panOnScroll'");
    }
    if (paneClickDistance === void 0 && !("paneClickDistance" in $$props || $$self.$$.bound[$$self.$$.props["paneClickDistance"]])) {
      console.warn("<Zoom> was created without expected prop 'paneClickDistance'");
    }
  });
  const writable_props = [
    "initialViewport",
    "onMoveStart",
    "onMove",
    "onMoveEnd",
    "panOnScrollMode",
    "preventScrolling",
    "zoomOnScroll",
    "zoomOnDoubleClick",
    "zoomOnPinch",
    "panOnDrag",
    "panOnScroll",
    "paneClickDistance"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Zoom> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("initialViewport" in $$props2) $$invalidate(29, initialViewport = $$props2.initialViewport);
    if ("onMoveStart" in $$props2) $$invalidate(0, onMoveStart = $$props2.onMoveStart);
    if ("onMove" in $$props2) $$invalidate(1, onMove = $$props2.onMove);
    if ("onMoveEnd" in $$props2) $$invalidate(2, onMoveEnd = $$props2.onMoveEnd);
    if ("panOnScrollMode" in $$props2) $$invalidate(3, panOnScrollMode = $$props2.panOnScrollMode);
    if ("preventScrolling" in $$props2) $$invalidate(4, preventScrolling = $$props2.preventScrolling);
    if ("zoomOnScroll" in $$props2) $$invalidate(5, zoomOnScroll = $$props2.zoomOnScroll);
    if ("zoomOnDoubleClick" in $$props2) $$invalidate(6, zoomOnDoubleClick = $$props2.zoomOnDoubleClick);
    if ("zoomOnPinch" in $$props2) $$invalidate(7, zoomOnPinch = $$props2.zoomOnPinch);
    if ("panOnDrag" in $$props2) $$invalidate(30, panOnDrag = $$props2.panOnDrag);
    if ("panOnScroll" in $$props2) $$invalidate(31, panOnScroll = $$props2.panOnScroll);
    if ("paneClickDistance" in $$props2) $$invalidate(8, paneClickDistance = $$props2.paneClickDistance);
    if ("$$scope" in $$props2) $$invalidate(33, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    PanOnScrollMode,
    useStore,
    zoom,
    onMount,
    initialViewport,
    onMoveStart,
    onMove,
    onMoveEnd,
    panOnScrollMode,
    preventScrolling,
    zoomOnScroll,
    zoomOnDoubleClick,
    zoomOnPinch,
    panOnDrag,
    panOnScroll,
    paneClickDistance,
    viewport,
    panZoom,
    selectionRect,
    minZoom,
    maxZoom,
    dragging,
    translateExtent,
    lib,
    panActivationKeyPressed,
    zoomActivationKeyPressed,
    viewportInitialized,
    _panOnScroll,
    _panOnDrag,
    viewPort,
    $viewportInitialized,
    $panActivationKeyPressed,
    $minZoom,
    $maxZoom,
    $zoomActivationKeyPressed,
    $selectionRect,
    $translateExtent,
    $lib
  });
  $$self.$inject_state = ($$props2) => {
    if ("initialViewport" in $$props2) $$invalidate(29, initialViewport = $$props2.initialViewport);
    if ("onMoveStart" in $$props2) $$invalidate(0, onMoveStart = $$props2.onMoveStart);
    if ("onMove" in $$props2) $$invalidate(1, onMove = $$props2.onMove);
    if ("onMoveEnd" in $$props2) $$invalidate(2, onMoveEnd = $$props2.onMoveEnd);
    if ("panOnScrollMode" in $$props2) $$invalidate(3, panOnScrollMode = $$props2.panOnScrollMode);
    if ("preventScrolling" in $$props2) $$invalidate(4, preventScrolling = $$props2.preventScrolling);
    if ("zoomOnScroll" in $$props2) $$invalidate(5, zoomOnScroll = $$props2.zoomOnScroll);
    if ("zoomOnDoubleClick" in $$props2) $$invalidate(6, zoomOnDoubleClick = $$props2.zoomOnDoubleClick);
    if ("zoomOnPinch" in $$props2) $$invalidate(7, zoomOnPinch = $$props2.zoomOnPinch);
    if ("panOnDrag" in $$props2) $$invalidate(30, panOnDrag = $$props2.panOnDrag);
    if ("panOnScroll" in $$props2) $$invalidate(31, panOnScroll = $$props2.panOnScroll);
    if ("paneClickDistance" in $$props2) $$invalidate(8, paneClickDistance = $$props2.paneClickDistance);
    if ("_panOnScroll" in $$props2) $$invalidate(9, _panOnScroll = $$props2._panOnScroll);
    if ("_panOnDrag" in $$props2) $$invalidate(10, _panOnDrag = $$props2._panOnDrag);
    if ("viewPort" in $$props2) $$invalidate(11, viewPort = $$props2.viewPort);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*initialViewport*/
    536870912) {
      $: $$invalidate(11, viewPort = initialViewport || { x: 0, y: 0, zoom: 1 });
    }
    if ($$self.$$.dirty[0] & /*panOnDrag*/
    1073741824 | $$self.$$.dirty[1] & /*$panActivationKeyPressed*/
    2) {
      $: $$invalidate(10, _panOnDrag = $panActivationKeyPressed || panOnDrag);
    }
    if ($$self.$$.dirty[1] & /*$panActivationKeyPressed, panOnScroll*/
    3) {
      $: $$invalidate(9, _panOnScroll = $panActivationKeyPressed || panOnScroll);
    }
  };
  return [
    onMoveStart,
    onMove,
    onMoveEnd,
    panOnScrollMode,
    preventScrolling,
    zoomOnScroll,
    zoomOnDoubleClick,
    zoomOnPinch,
    paneClickDistance,
    _panOnScroll,
    _panOnDrag,
    viewPort,
    $minZoom,
    $maxZoom,
    $zoomActivationKeyPressed,
    $selectionRect,
    $translateExtent,
    $lib,
    viewport,
    panZoom,
    selectionRect,
    minZoom,
    maxZoom,
    dragging,
    translateExtent,
    lib,
    panActivationKeyPressed,
    zoomActivationKeyPressed,
    viewportInitialized,
    initialViewport,
    panOnDrag,
    panOnScroll,
    $panActivationKeyPressed,
    $$scope,
    slots
  ];
}
var Zoom = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance17,
      create_fragment17,
      safe_not_equal,
      {
        initialViewport: 29,
        onMoveStart: 0,
        onMove: 1,
        onMoveEnd: 2,
        panOnScrollMode: 3,
        preventScrolling: 4,
        zoomOnScroll: 5,
        zoomOnDoubleClick: 6,
        zoomOnPinch: 7,
        panOnDrag: 30,
        panOnScroll: 31,
        paneClickDistance: 8
      },
      add_css,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Zoom",
      options,
      id: create_fragment17.name
    });
  }
  get initialViewport() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialViewport(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMoveStart() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMoveStart(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMove() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMove(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMoveEnd() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMoveEnd(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panOnScrollMode() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panOnScrollMode(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get preventScrolling() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preventScrolling(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomOnScroll() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomOnScroll(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomOnDoubleClick() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomOnDoubleClick(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomOnPinch() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomOnPinch(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panOnDrag() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panOnDrag(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panOnScroll() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panOnScroll(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get paneClickDistance() {
    throw new Error("<Zoom>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set paneClickDistance(value) {
    throw new Error("<Zoom>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Zoom_default = Zoom;

// node_modules/@xyflow/svelte/dist/lib/container/Pane/Pane.svelte
var file6 = "node_modules/@xyflow/svelte/dist/lib/container/Pane/Pane.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1esy7hx", ".svelte-flow__pane.svelte-1esy7hx{position:absolute;top:0;left:0;width:100%;height:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGFuZS5zdmVsdGUiLCJzb3VyY2VzIjpbIlBhbmUuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQgY29udGV4dD1cIm1vZHVsZVwiPmV4cG9ydCBmdW5jdGlvbiB3cmFwSGFuZGxlcihoYW5kbGVyLCBjb250YWluZXIpIHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC50YXJnZXQgIT09IGNvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZXI/LihldmVudCk7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGVTZWxlY3RlZChpZHMpIHtcbiAgICByZXR1cm4gKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IGlkcy5pbmNsdWRlcyhpdGVtLmlkKTtcbiAgICAgICAgaWYgKGl0ZW0uc2VsZWN0ZWQgIT09IGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGl0ZW0uc2VsZWN0ZWQgPSBpc1NlbGVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH07XG59XG48L3NjcmlwdD5cblxuPHNjcmlwdD5pbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnO1xuaW1wb3J0IHsgU2VsZWN0aW9uTW9kZSwgZ2V0RXZlbnRQb3NpdGlvbiwgZ2V0Tm9kZXNJbnNpZGUsIGdldENvbm5lY3RlZEVkZ2VzIH0gZnJvbSAnQHh5Zmxvdy9zeXN0ZW0nO1xuaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICcuLi8uLi9zdG9yZSc7XG5leHBvcnQgbGV0IHBhbk9uRHJhZyA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgc2VsZWN0aW9uT25EcmFnID0gdW5kZWZpbmVkO1xuY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcbmNvbnN0IHsgbm9kZXMsIG5vZGVMb29rdXAsIGVkZ2VzLCB2aWV3cG9ydCwgZHJhZ2dpbmcsIGVsZW1lbnRzU2VsZWN0YWJsZSwgc2VsZWN0aW9uUmVjdCwgc2VsZWN0aW9uUmVjdE1vZGUsIHNlbGVjdGlvbktleVByZXNzZWQsIHNlbGVjdGlvbk1vZGUsIHBhbkFjdGl2YXRpb25LZXlQcmVzc2VkLCB1bnNlbGVjdE5vZGVzQW5kRWRnZXMgfSA9IHVzZVN0b3JlKCk7XG5sZXQgY29udGFpbmVyO1xubGV0IGNvbnRhaW5lckJvdW5kcyA9IG51bGw7XG5sZXQgc2VsZWN0ZWROb2RlcyA9IFtdO1xuJDogX3Bhbk9uRHJhZyA9ICRwYW5BY3RpdmF0aW9uS2V5UHJlc3NlZCB8fCBwYW5PbkRyYWc7XG4kOiBpc1NlbGVjdGluZyA9XG4gICAgJHNlbGVjdGlvbktleVByZXNzZWQgfHwgJHNlbGVjdGlvblJlY3QgfHwgKHNlbGVjdGlvbk9uRHJhZyAmJiBfcGFuT25EcmFnICE9PSB0cnVlKTtcbiQ6IGhhc0FjdGl2ZVNlbGVjdGlvbiA9ICRlbGVtZW50c1NlbGVjdGFibGUgJiYgKGlzU2VsZWN0aW5nIHx8ICRzZWxlY3Rpb25SZWN0TW9kZSA9PT0gJ3VzZXInKTtcbi8vIFVzZWQgdG8gcHJldmVudCBjbGljayBldmVudHMgd2hlbiB0aGUgdXNlciBsZXRzIGdvIG9mIHRoZSBzZWxlY3Rpb25LZXkgZHVyaW5nIGEgc2VsZWN0aW9uXG5sZXQgc2VsZWN0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlO1xuZnVuY3Rpb24gb25DbGljayhldmVudCkge1xuICAgIC8vIFdlIHByZXZlbnQgY2xpY2sgZXZlbnRzIHdoZW4gdGhlIHVzZXIgbGV0IGdvIG9mIHRoZSBzZWxlY3Rpb25LZXkgZHVyaW5nIGEgc2VsZWN0aW9uXG4gICAgaWYgKHNlbGVjdGlvbkluUHJvZ3Jlc3MpIHtcbiAgICAgICAgc2VsZWN0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpc3BhdGNoKCdwYW5lY2xpY2snLCB7IGV2ZW50IH0pO1xuICAgIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcygpO1xuICAgIHNlbGVjdGlvblJlY3RNb2RlLnNldChudWxsKTtcbn1cbmZ1bmN0aW9uIG9uUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICBjb250YWluZXJCb3VuZHMgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgZXZlbnQudGFyZ2V0Py5zZXRQb2ludGVyQ2FwdHVyZT8uKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgaWYgKCFlbGVtZW50c1NlbGVjdGFibGUgfHxcbiAgICAgICAgIWlzU2VsZWN0aW5nIHx8XG4gICAgICAgIGV2ZW50LmJ1dHRvbiAhPT0gMCB8fFxuICAgICAgICBldmVudC50YXJnZXQgIT09IGNvbnRhaW5lciB8fFxuICAgICAgICAhY29udGFpbmVyQm91bmRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyB4LCB5IH0gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LCBjb250YWluZXJCb3VuZHMpO1xuICAgIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcygpO1xuICAgIHNlbGVjdGlvblJlY3Quc2V0KHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgc3RhcnRYOiB4LFxuICAgICAgICBzdGFydFk6IHksXG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICB9KTtcbiAgICAvLyBvblNlbGVjdGlvblN0YXJ0Py4oZXZlbnQpO1xufVxuZnVuY3Rpb24gb25Qb2ludGVyTW92ZShldmVudCkge1xuICAgIGlmICghaXNTZWxlY3RpbmcgfHwgIWNvbnRhaW5lckJvdW5kcyB8fCAhJHNlbGVjdGlvblJlY3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxlY3Rpb25JblByb2dyZXNzID0gdHJ1ZTtcbiAgICBjb25zdCBtb3VzZVBvcyA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQsIGNvbnRhaW5lckJvdW5kcyk7XG4gICAgY29uc3Qgc3RhcnRYID0gJHNlbGVjdGlvblJlY3Quc3RhcnRYID8/IDA7XG4gICAgY29uc3Qgc3RhcnRZID0gJHNlbGVjdGlvblJlY3Quc3RhcnRZID8/IDA7XG4gICAgY29uc3QgbmV4dFVzZXJTZWxlY3RSZWN0ID0ge1xuICAgICAgICAuLi4kc2VsZWN0aW9uUmVjdCxcbiAgICAgICAgeDogbW91c2VQb3MueCA8IHN0YXJ0WCA/IG1vdXNlUG9zLnggOiBzdGFydFgsXG4gICAgICAgIHk6IG1vdXNlUG9zLnkgPCBzdGFydFkgPyBtb3VzZVBvcy55IDogc3RhcnRZLFxuICAgICAgICB3aWR0aDogTWF0aC5hYnMobW91c2VQb3MueCAtIHN0YXJ0WCksXG4gICAgICAgIGhlaWdodDogTWF0aC5hYnMobW91c2VQb3MueSAtIHN0YXJ0WSlcbiAgICB9O1xuICAgIGNvbnN0IHByZXZTZWxlY3RlZE5vZGVJZHMgPSBzZWxlY3RlZE5vZGVzLm1hcCgobikgPT4gbi5pZCk7XG4gICAgY29uc3QgcHJldlNlbGVjdGVkRWRnZUlkcyA9IGdldENvbm5lY3RlZEVkZ2VzKHNlbGVjdGVkTm9kZXMsICRlZGdlcykubWFwKChlKSA9PiBlLmlkKTtcbiAgICBzZWxlY3RlZE5vZGVzID0gZ2V0Tm9kZXNJbnNpZGUoJG5vZGVMb29rdXAsIG5leHRVc2VyU2VsZWN0UmVjdCwgWyR2aWV3cG9ydC54LCAkdmlld3BvcnQueSwgJHZpZXdwb3J0Lnpvb21dLCAkc2VsZWN0aW9uTW9kZSA9PT0gU2VsZWN0aW9uTW9kZS5QYXJ0aWFsLCB0cnVlKTtcbiAgICBjb25zdCBzZWxlY3RlZEVkZ2VJZHMgPSBnZXRDb25uZWN0ZWRFZGdlcyhzZWxlY3RlZE5vZGVzLCAkZWRnZXMpLm1hcCgoZSkgPT4gZS5pZCk7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlSWRzID0gc2VsZWN0ZWROb2Rlcy5tYXAoKG4pID0+IG4uaWQpO1xuICAgIC8vIHRoaXMgcHJldmVudHMgdW5uZWNlc3NhcnkgdXBkYXRlcyB3aGlsZSB1cGRhdGluZyB0aGUgc2VsZWN0aW9uIHJlY3RhbmdsZVxuICAgIGlmIChwcmV2U2VsZWN0ZWROb2RlSWRzLmxlbmd0aCAhPT0gc2VsZWN0ZWROb2RlSWRzLmxlbmd0aCB8fFxuICAgICAgICBzZWxlY3RlZE5vZGVJZHMuc29tZSgoaWQpID0+ICFwcmV2U2VsZWN0ZWROb2RlSWRzLmluY2x1ZGVzKGlkKSkpIHtcbiAgICAgICAgbm9kZXMudXBkYXRlKChub2RlcykgPT4gbm9kZXMubWFwKHRvZ2dsZVNlbGVjdGVkKHNlbGVjdGVkTm9kZUlkcykpKTtcbiAgICB9XG4gICAgaWYgKHByZXZTZWxlY3RlZEVkZ2VJZHMubGVuZ3RoICE9PSBzZWxlY3RlZEVkZ2VJZHMubGVuZ3RoIHx8XG4gICAgICAgIHNlbGVjdGVkRWRnZUlkcy5zb21lKChpZCkgPT4gIXByZXZTZWxlY3RlZEVkZ2VJZHMuaW5jbHVkZXMoaWQpKSkge1xuICAgICAgICBlZGdlcy51cGRhdGUoKGVkZ2VzKSA9PiBlZGdlcy5tYXAodG9nZ2xlU2VsZWN0ZWQoc2VsZWN0ZWRFZGdlSWRzKSkpO1xuICAgIH1cbiAgICBzZWxlY3Rpb25SZWN0TW9kZS5zZXQoJ3VzZXInKTtcbiAgICBzZWxlY3Rpb25SZWN0LnNldChuZXh0VXNlclNlbGVjdFJlY3QpO1xufVxuZnVuY3Rpb24gb25Qb2ludGVyVXAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZlbnQudGFyZ2V0Py5yZWxlYXNlUG9pbnRlckNhcHR1cmU/LihldmVudC5wb2ludGVySWQpO1xuICAgIC8vIFdlIG9ubHkgd2FudCB0byB0cmlnZ2VyIGNsaWNrIGZ1bmN0aW9ucyB3aGVuIGluIHNlbGVjdGlvbiBtb2RlIGlmXG4gICAgLy8gdGhlIHVzZXIgZGlkIG5vdCBtb3ZlIHRoZSBtb3VzZS5cbiAgICBpZiAoIWlzU2VsZWN0aW5nICYmICRzZWxlY3Rpb25SZWN0TW9kZSA9PT0gJ3VzZXInICYmIGV2ZW50LnRhcmdldCA9PT0gY29udGFpbmVyKSB7XG4gICAgICAgIG9uQ2xpY2s/LihldmVudCk7XG4gICAgfVxuICAgIHNlbGVjdGlvblJlY3Quc2V0KG51bGwpO1xuICAgIGlmIChzZWxlY3RlZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgJHNlbGVjdGlvblJlY3RNb2RlID0gJ25vZGVzJztcbiAgICB9XG4gICAgLy8gSWYgdGhlIHVzZXIga2VwdCBob2xkaW5nIHRoZSBzZWxlY3Rpb25LZXkgZHVyaW5nIHRoZSBzZWxlY3Rpb24sXG4gICAgLy8gd2UgbmVlZCB0byByZXNldCB0aGUgc2VsZWN0aW9uSW5Qcm9ncmVzcywgc28gdGhlIG5leHQgY2xpY2sgZXZlbnQgaXMgbm90IHByZXZlbnRlZFxuICAgIGlmICgkc2VsZWN0aW9uS2V5UHJlc3NlZCkge1xuICAgICAgICBzZWxlY3Rpb25JblByb2dyZXNzID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIG9uU2VsZWN0aW9uRW5kPy4oZXZlbnQpO1xufVxuY29uc3Qgb25Db250ZXh0TWVudSA9IChldmVudCkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KF9wYW5PbkRyYWcpICYmIF9wYW5PbkRyYWc/LmluY2x1ZGVzKDIpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlzcGF0Y2goJ3BhbmVjb250ZXh0bWVudScsIHsgZXZlbnQgfSk7XG59O1xuPC9zY3JpcHQ+XG5cbjwhLS0gc3ZlbHRlLWlnbm9yZSBhMTF5LW5vLXN0YXRpYy1lbGVtZW50LWludGVyYWN0aW9ucyAtLT5cbjwhLS0gc3ZlbHRlLWlnbm9yZSBhMTF5LWNsaWNrLWV2ZW50cy1oYXZlLWtleS1ldmVudHMgLS0+XG48ZGl2XG4gIGJpbmQ6dGhpcz17Y29udGFpbmVyfVxuICBjbGFzcz1cInN2ZWx0ZS1mbG93X19wYW5lXCJcbiAgY2xhc3M6ZHJhZ2dhYmxlPXtwYW5PbkRyYWd9XG4gIGNsYXNzOmRyYWdnaW5nPXskZHJhZ2dpbmd9XG4gIGNsYXNzOnNlbGVjdGlvbj17aXNTZWxlY3Rpbmd9XG4gIG9uOmNsaWNrPXtoYXNBY3RpdmVTZWxlY3Rpb24gPyB1bmRlZmluZWQgOiB3cmFwSGFuZGxlcihvbkNsaWNrLCBjb250YWluZXIpfVxuICBvbjpwb2ludGVyZG93bj17aGFzQWN0aXZlU2VsZWN0aW9uID8gb25Qb2ludGVyRG93biA6IHVuZGVmaW5lZH1cbiAgb246cG9pbnRlcm1vdmU9e2hhc0FjdGl2ZVNlbGVjdGlvbiA/IG9uUG9pbnRlck1vdmUgOiB1bmRlZmluZWR9XG4gIG9uOnBvaW50ZXJ1cD17aGFzQWN0aXZlU2VsZWN0aW9uID8gb25Qb2ludGVyVXAgOiB1bmRlZmluZWR9XG4gIG9uOmNvbnRleHRtZW51PXt3cmFwSGFuZGxlcihvbkNvbnRleHRNZW51LCBjb250YWluZXIpfVxuPlxuICA8c2xvdCAvPlxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgLnN2ZWx0ZS1mbG93X19wYW5lIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICB9XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW1KRSxpQ0FBbUIsQ0FDakIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLENBQUMsQ0FDTixJQUFJLENBQUUsQ0FBQyxDQUNQLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQ1YifQ== */");
}
function create_fragment18(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[28].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    null
  );
  const block = {
    c: function create2() {
      div = element("div");
      if (default_slot) default_slot.c();
      attr_dev(div, "class", "svelte-flow__pane svelte-1esy7hx");
      toggle_class(
        div,
        "draggable",
        /*panOnDrag*/
        ctx[0]
      );
      toggle_class(
        div,
        "dragging",
        /*$dragging*/
        ctx[4]
      );
      toggle_class(
        div,
        "selection",
        /*isSelecting*/
        ctx[1]
      );
      add_location(div, file6, 131, 0, 5025);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[29](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            function() {
              if (is_function(
                /*hasActiveSelection*/
                ctx[3] ? void 0 : wrapHandler(
                  /*onClick*/
                  ctx[15],
                  /*container*/
                  ctx[2]
                )
              )) /*hasActiveSelection*/
              (ctx[3] ? void 0 : wrapHandler(
                /*onClick*/
                ctx[15],
                /*container*/
                ctx[2]
              )).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "pointerdown",
            function() {
              if (is_function(
                /*hasActiveSelection*/
                ctx[3] ? (
                  /*onPointerDown*/
                  ctx[16]
                ) : void 0
              )) /*hasActiveSelection*/
              (ctx[3] ? (
                /*onPointerDown*/
                ctx[16]
              ) : void 0).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "pointermove",
            function() {
              if (is_function(
                /*hasActiveSelection*/
                ctx[3] ? (
                  /*onPointerMove*/
                  ctx[17]
                ) : void 0
              )) /*hasActiveSelection*/
              (ctx[3] ? (
                /*onPointerMove*/
                ctx[17]
              ) : void 0).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "pointerup",
            function() {
              if (is_function(
                /*hasActiveSelection*/
                ctx[3] ? (
                  /*onPointerUp*/
                  ctx[18]
                ) : void 0
              )) /*hasActiveSelection*/
              (ctx[3] ? (
                /*onPointerUp*/
                ctx[18]
              ) : void 0).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "contextmenu",
            function() {
              if (is_function(wrapHandler(
                /*onContextMenu*/
                ctx[19],
                /*container*/
                ctx[2]
              ))) wrapHandler(
                /*onContextMenu*/
                ctx[19],
                /*container*/
                ctx[2]
              ).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[27]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[27],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*panOnDrag*/
      1) {
        toggle_class(
          div,
          "draggable",
          /*panOnDrag*/
          ctx[0]
        );
      }
      if (!current || dirty[0] & /*$dragging*/
      16) {
        toggle_class(
          div,
          "dragging",
          /*$dragging*/
          ctx[4]
        );
      }
      if (!current || dirty[0] & /*isSelecting*/
      2) {
        toggle_class(
          div,
          "selection",
          /*isSelecting*/
          ctx[1]
        );
      }
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(default_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(default_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[29](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function wrapHandler(handler, container) {
  return (event) => {
    if (event.target !== container) {
      return;
    }
    handler == null ? void 0 : handler(event);
  };
}
function toggleSelected(ids) {
  return (item) => {
    const isSelected = ids.includes(item.id);
    if (item.selected !== isSelected) {
      item.selected = isSelected;
    }
    return item;
  };
}
function instance18($$self, $$props, $$invalidate) {
  let _panOnDrag;
  let isSelecting;
  let hasActiveSelection;
  let $selectionKeyPressed;
  let $selectionRectMode;
  let $edges;
  let $selectionMode;
  let $viewport;
  let $nodeLookup;
  let $selectionRect;
  let $elementsSelectable;
  let $panActivationKeyPressed;
  let $dragging;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Pane", slots, ["default"]);
  let { panOnDrag = void 0 } = $$props;
  let { selectionOnDrag = void 0 } = $$props;
  const dispatch2 = createEventDispatcher();
  const { nodes, nodeLookup, edges, viewport, dragging, elementsSelectable, selectionRect, selectionRectMode, selectionKeyPressed, selectionMode, panActivationKeyPressed, unselectNodesAndEdges } = useStore();
  validate_store(nodeLookup, "nodeLookup");
  component_subscribe($$self, nodeLookup, (value) => $$invalidate(36, $nodeLookup = value));
  validate_store(edges, "edges");
  component_subscribe($$self, edges, (value) => $$invalidate(33, $edges = value));
  validate_store(viewport, "viewport");
  component_subscribe($$self, viewport, (value) => $$invalidate(35, $viewport = value));
  validate_store(dragging, "dragging");
  component_subscribe($$self, dragging, (value) => $$invalidate(4, $dragging = value));
  validate_store(elementsSelectable, "elementsSelectable");
  component_subscribe($$self, elementsSelectable, (value) => $$invalidate(25, $elementsSelectable = value));
  validate_store(selectionRect, "selectionRect");
  component_subscribe($$self, selectionRect, (value) => $$invalidate(24, $selectionRect = value));
  validate_store(selectionRectMode, "selectionRectMode");
  component_subscribe($$self, selectionRectMode, (value) => $$invalidate(23, $selectionRectMode = value));
  validate_store(selectionKeyPressed, "selectionKeyPressed");
  component_subscribe($$self, selectionKeyPressed, (value) => $$invalidate(22, $selectionKeyPressed = value));
  validate_store(selectionMode, "selectionMode");
  component_subscribe($$self, selectionMode, (value) => $$invalidate(34, $selectionMode = value));
  validate_store(panActivationKeyPressed, "panActivationKeyPressed");
  component_subscribe($$self, panActivationKeyPressed, (value) => $$invalidate(26, $panActivationKeyPressed = value));
  let container;
  let containerBounds = null;
  let selectedNodes = [];
  let selectionInProgress = false;
  function onClick(event) {
    if (selectionInProgress) {
      selectionInProgress = false;
      return;
    }
    dispatch2("paneclick", { event });
    unselectNodesAndEdges();
    selectionRectMode.set(null);
  }
  function onPointerDown2(event) {
    var _a, _b;
    containerBounds = container.getBoundingClientRect();
    (_b = (_a = event.target) == null ? void 0 : _a.setPointerCapture) == null ? void 0 : _b.call(_a, event.pointerId);
    if (!elementsSelectable || !isSelecting || event.button !== 0 || event.target !== container || !containerBounds) {
      return;
    }
    const { x, y } = getEventPosition(event, containerBounds);
    unselectNodesAndEdges();
    selectionRect.set({
      width: 0,
      height: 0,
      startX: x,
      startY: y,
      x,
      y
    });
  }
  function onPointerMove(event) {
    if (!isSelecting || !containerBounds || !$selectionRect) {
      return;
    }
    selectionInProgress = true;
    const mousePos = getEventPosition(event, containerBounds);
    const startX = $selectionRect.startX ?? 0;
    const startY = $selectionRect.startY ?? 0;
    const nextUserSelectRect = {
      ...$selectionRect,
      x: mousePos.x < startX ? mousePos.x : startX,
      y: mousePos.y < startY ? mousePos.y : startY,
      width: Math.abs(mousePos.x - startX),
      height: Math.abs(mousePos.y - startY)
    };
    const prevSelectedNodeIds = selectedNodes.map((n) => n.id);
    const prevSelectedEdgeIds = getConnectedEdges(selectedNodes, $edges).map((e) => e.id);
    selectedNodes = getNodesInside($nodeLookup, nextUserSelectRect, [$viewport.x, $viewport.y, $viewport.zoom], $selectionMode === SelectionMode.Partial, true);
    const selectedEdgeIds = getConnectedEdges(selectedNodes, $edges).map((e) => e.id);
    const selectedNodeIds = selectedNodes.map((n) => n.id);
    if (prevSelectedNodeIds.length !== selectedNodeIds.length || selectedNodeIds.some((id2) => !prevSelectedNodeIds.includes(id2))) {
      nodes.update((nodes2) => nodes2.map(toggleSelected(selectedNodeIds)));
    }
    if (prevSelectedEdgeIds.length !== selectedEdgeIds.length || selectedEdgeIds.some((id2) => !prevSelectedEdgeIds.includes(id2))) {
      edges.update((edges2) => edges2.map(toggleSelected(selectedEdgeIds)));
    }
    selectionRectMode.set("user");
    selectionRect.set(nextUserSelectRect);
  }
  function onPointerUp(event) {
    var _a, _b;
    if (event.button !== 0) {
      return;
    }
    (_b = (_a = event.target) == null ? void 0 : _a.releasePointerCapture) == null ? void 0 : _b.call(_a, event.pointerId);
    if (!isSelecting && $selectionRectMode === "user" && event.target === container) {
      onClick == null ? void 0 : onClick(event);
    }
    selectionRect.set(null);
    if (selectedNodes.length > 0) {
      set_store_value(selectionRectMode, $selectionRectMode = "nodes", $selectionRectMode);
    }
    if ($selectionKeyPressed) {
      selectionInProgress = false;
    }
  }
  const onContextMenu = (event) => {
    if (Array.isArray(_panOnDrag) && (_panOnDrag == null ? void 0 : _panOnDrag.includes(2))) {
      event.preventDefault();
      return;
    }
    dispatch2("panecontextmenu", { event });
  };
  const writable_props = ["panOnDrag", "selectionOnDrag"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Pane> was created with unknown prop '${key2}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(2, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("panOnDrag" in $$props2) $$invalidate(0, panOnDrag = $$props2.panOnDrag);
    if ("selectionOnDrag" in $$props2) $$invalidate(20, selectionOnDrag = $$props2.selectionOnDrag);
    if ("$$scope" in $$props2) $$invalidate(27, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    wrapHandler,
    toggleSelected,
    createEventDispatcher,
    SelectionMode,
    getEventPosition,
    getNodesInside,
    getConnectedEdges,
    useStore,
    panOnDrag,
    selectionOnDrag,
    dispatch: dispatch2,
    nodes,
    nodeLookup,
    edges,
    viewport,
    dragging,
    elementsSelectable,
    selectionRect,
    selectionRectMode,
    selectionKeyPressed,
    selectionMode,
    panActivationKeyPressed,
    unselectNodesAndEdges,
    container,
    containerBounds,
    selectedNodes,
    selectionInProgress,
    onClick,
    onPointerDown: onPointerDown2,
    onPointerMove,
    onPointerUp,
    onContextMenu,
    _panOnDrag,
    isSelecting,
    hasActiveSelection,
    $selectionKeyPressed,
    $selectionRectMode,
    $edges,
    $selectionMode,
    $viewport,
    $nodeLookup,
    $selectionRect,
    $elementsSelectable,
    $panActivationKeyPressed,
    $dragging
  });
  $$self.$inject_state = ($$props2) => {
    if ("panOnDrag" in $$props2) $$invalidate(0, panOnDrag = $$props2.panOnDrag);
    if ("selectionOnDrag" in $$props2) $$invalidate(20, selectionOnDrag = $$props2.selectionOnDrag);
    if ("container" in $$props2) $$invalidate(2, container = $$props2.container);
    if ("containerBounds" in $$props2) containerBounds = $$props2.containerBounds;
    if ("selectedNodes" in $$props2) selectedNodes = $$props2.selectedNodes;
    if ("selectionInProgress" in $$props2) selectionInProgress = $$props2.selectionInProgress;
    if ("_panOnDrag" in $$props2) $$invalidate(21, _panOnDrag = $$props2._panOnDrag);
    if ("isSelecting" in $$props2) $$invalidate(1, isSelecting = $$props2.isSelecting);
    if ("hasActiveSelection" in $$props2) $$invalidate(3, hasActiveSelection = $$props2.hasActiveSelection);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$panActivationKeyPressed, panOnDrag*/
    67108865) {
      $: $$invalidate(21, _panOnDrag = $panActivationKeyPressed || panOnDrag);
    }
    if ($$self.$$.dirty[0] & /*$selectionKeyPressed, $selectionRect, selectionOnDrag, _panOnDrag*/
    24117248) {
      $: $$invalidate(1, isSelecting = $selectionKeyPressed || $selectionRect || selectionOnDrag && _panOnDrag !== true);
    }
    if ($$self.$$.dirty[0] & /*$elementsSelectable, isSelecting, $selectionRectMode*/
    41943042) {
      $: $$invalidate(3, hasActiveSelection = $elementsSelectable && (isSelecting || $selectionRectMode === "user"));
    }
  };
  return [
    panOnDrag,
    isSelecting,
    container,
    hasActiveSelection,
    $dragging,
    nodeLookup,
    edges,
    viewport,
    dragging,
    elementsSelectable,
    selectionRect,
    selectionRectMode,
    selectionKeyPressed,
    selectionMode,
    panActivationKeyPressed,
    onClick,
    onPointerDown2,
    onPointerMove,
    onPointerUp,
    onContextMenu,
    selectionOnDrag,
    _panOnDrag,
    $selectionKeyPressed,
    $selectionRectMode,
    $selectionRect,
    $elementsSelectable,
    $panActivationKeyPressed,
    $$scope,
    slots,
    div_binding
  ];
}
var Pane = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, { panOnDrag: 0, selectionOnDrag: 20 }, add_css2, [-1, -1]);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pane",
      options,
      id: create_fragment18.name
    });
  }
  get panOnDrag() {
    throw new Error("<Pane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panOnDrag(value) {
    throw new Error("<Pane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectionOnDrag() {
    throw new Error("<Pane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectionOnDrag(value) {
    throw new Error("<Pane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Pane_default = Pane;

// node_modules/@xyflow/svelte/dist/lib/container/Viewport/Viewport.svelte
var file7 = "node_modules/@xyflow/svelte/dist/lib/container/Viewport/Viewport.svelte";
function add_css3(target) {
  append_styles(target, "svelte-1floaup", ".svelte-flow__viewport.svelte-1floaup{width:100%;height:100%;position:absolute;top:0;left:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmlld3BvcnQuc3ZlbHRlIiwic291cmNlcyI6WyJWaWV3cG9ydC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5pbXBvcnQgeyB1c2VTdG9yZSB9IGZyb20gJy4uLy4uL3N0b3JlJztcbmNvbnN0IHsgdmlld3BvcnQgfSA9IHVzZVN0b3JlKCk7XG48L3NjcmlwdD5cblxuPGRpdlxuICBjbGFzcz1cInN2ZWx0ZS1mbG93X192aWV3cG9ydCB4eWZsb3dfX3ZpZXdwb3J0XCJcbiAgc3R5bGU9XCJ0cmFuc2Zvcm06IHRyYW5zbGF0ZSh7JHZpZXdwb3J0Lnh9cHgsIHskdmlld3BvcnQueX1weCkgc2NhbGUoeyR2aWV3cG9ydC56b29tfSlcIlxuPlxuICA8c2xvdCAvPlxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgLnN2ZWx0ZS1mbG93X192aWV3cG9ydCB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFZRSxxQ0FBdUIsQ0FDckIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxDQUFDLENBQ04sSUFBSSxDQUFFLENBQ1IifQ== */");
}
function create_fragment19(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create2() {
      div = element("div");
      if (default_slot) default_slot.c();
      attr_dev(div, "class", "svelte-flow__viewport xyflow__viewport svelte-1floaup");
      set_style(div, "transform", "translate(" + /*$viewport*/
      ctx[0].x + "px, " + /*$viewport*/
      ctx[0].y + "px) scale(" + /*$viewport*/
      ctx[0].zoom + ")");
      add_location(div, file7, 4, 0, 92);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$viewport*/
      1) {
        set_style(div, "transform", "translate(" + /*$viewport*/
        ctx2[0].x + "px, " + /*$viewport*/
        ctx2[0].y + "px) scale(" + /*$viewport*/
        ctx2[0].zoom + ")");
      }
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(default_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(default_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let $viewport;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Viewport", slots, ["default"]);
  const { viewport } = useStore();
  validate_store(viewport, "viewport");
  component_subscribe($$self, viewport, (value) => $$invalidate(0, $viewport = value));
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Viewport> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ useStore, viewport, $viewport });
  return [$viewport, viewport, $$scope, slots];
}
var Viewport = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, {}, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Viewport",
      options,
      id: create_fragment19.name
    });
  }
};
var Viewport_default = Viewport;

// node_modules/@xyflow/svelte/dist/lib/actions/drag/index.js
function drag(domNode, params) {
  const { store, onDrag, onDragStart, onDragStop, onNodeMouseDown } = params;
  const dragInstance = XYDrag({
    onDrag,
    onDragStart,
    onDragStop,
    onNodeMouseDown,
    getStoreItems: () => {
      const snapGrid = get_store_value(store.snapGrid);
      const vp = get_store_value(store.viewport);
      return {
        nodes: get_store_value(store.nodes),
        nodeLookup: get_store_value(store.nodeLookup),
        edges: get_store_value(store.edges),
        nodeExtent: get_store_value(store.nodeExtent),
        snapGrid: snapGrid ? snapGrid : [0, 0],
        snapToGrid: !!snapGrid,
        nodeOrigin: get_store_value(store.nodeOrigin),
        multiSelectionActive: get_store_value(store.multiselectionKeyPressed),
        domNode: get_store_value(store.domNode),
        transform: [vp.x, vp.y, vp.zoom],
        autoPanOnNodeDrag: get_store_value(store.autoPanOnNodeDrag),
        nodesDraggable: get_store_value(store.nodesDraggable),
        selectNodesOnDrag: get_store_value(store.selectNodesOnDrag),
        nodeDragThreshold: get_store_value(store.nodeDragThreshold),
        unselectNodesAndEdges: store.unselectNodesAndEdges,
        updateNodePositions: store.updateNodePositions,
        panBy: store.panBy
      };
    }
  });
  function updateDrag(domNode2, params2) {
    if (params2.disabled) {
      dragInstance.destroy();
      return;
    }
    dragInstance.update({
      domNode: domNode2,
      noDragClassName: params2.noDragClass,
      handleSelector: params2.handleSelector,
      nodeId: params2.nodeId,
      isSelectable: params2.isSelectable,
      nodeClickDistance: params2.nodeClickDistance
    });
  }
  updateDrag(domNode, params);
  return {
    update(params2) {
      updateDrag(domNode, params2);
    },
    destroy() {
      dragInstance.destroy();
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/components/NodeWrapper/utils.js
function getNodeInlineStyleDimensions({ width, height, initialWidth, initialHeight, measuredWidth, measuredHeight }) {
  if (measuredWidth === void 0 && measuredHeight === void 0) {
    const styleWidth = width ?? initialWidth;
    const styleHeight = height ?? initialHeight;
    return {
      width: styleWidth ? `width:${styleWidth}px;` : "",
      height: styleHeight ? `height:${styleHeight}px;` : ""
    };
  }
  return {
    width: width ? `width:${width}px;` : "",
    height: height ? `height:${height}px;` : ""
  };
}

// node_modules/@xyflow/svelte/dist/lib/components/NodeWrapper/NodeWrapper.svelte
var { console: console_1 } = globals;
var file8 = "node_modules/@xyflow/svelte/dist/lib/components/NodeWrapper/NodeWrapper.svelte";
function create_if_block2(ctx) {
  let div;
  let switch_instance;
  let div_class_value;
  let div_style_value;
  let drag_action;
  let style_transform = `translate(${/*positionX*/
  ctx[12]}px, ${/*positionY*/
  ctx[13]}px)`;
  let current;
  let mounted;
  let dispose;
  var switch_value = (
    /*nodeComponent*/
    ctx[27]
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        data: (
          /*data*/
          ctx2[2]
        ),
        id: (
          /*id*/
          ctx2[1]
        ),
        selected: (
          /*selected*/
          ctx2[3]
        ),
        selectable: (
          /*selectable*/
          ctx2[5]
        ),
        deletable: (
          /*deletable*/
          ctx2[7]
        ),
        sourcePosition: (
          /*sourcePosition*/
          ctx2[14]
        ),
        targetPosition: (
          /*targetPosition*/
          ctx2[15]
        ),
        zIndex: (
          /*zIndex*/
          ctx2[16]
        ),
        dragging: (
          /*dragging*/
          ctx2[9]
        ),
        draggable: (
          /*draggable*/
          ctx2[4]
        ),
        dragHandle: (
          /*dragHandle*/
          ctx2[19]
        ),
        parentId: (
          /*parentId*/
          ctx2[21]
        ),
        type: (
          /*nodeType*/
          ctx2[25]
        ),
        isConnectable: (
          /*$connectableStore*/
          ctx2[28]
        ),
        positionAbsoluteX: (
          /*positionX*/
          ctx2[12]
        ),
        positionAbsoluteY: (
          /*positionY*/
          ctx2[13]
        ),
        width: (
          /*width*/
          ctx2[17]
        ),
        height: (
          /*height*/
          ctx2[18]
        )
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create2() {
      div = element("div");
      if (switch_instance) create_component(switch_instance.$$.fragment);
      attr_dev(
        div,
        "data-id",
        /*id*/
        ctx[1]
      );
      attr_dev(div, "class", div_class_value = cc([
        "svelte-flow__node",
        `svelte-flow__node-${/*nodeType*/
        ctx[25]}`,
        /*className*/
        ctx[23]
      ]));
      attr_dev(div, "style", div_style_value = /*style*/
      (ctx[10] ?? "") + ";" + /*inlineStyleDimensions*/
      ctx[26].width + /*inlineStyleDimensions*/
      ctx[26].height);
      toggle_class(
        div,
        "dragging",
        /*dragging*/
        ctx[9]
      );
      toggle_class(
        div,
        "selected",
        /*selected*/
        ctx[3]
      );
      toggle_class(
        div,
        "draggable",
        /*draggable*/
        ctx[4]
      );
      toggle_class(
        div,
        "connectable",
        /*connectable*/
        ctx[6]
      );
      toggle_class(
        div,
        "selectable",
        /*selectable*/
        ctx[5]
      );
      toggle_class(
        div,
        "nopan",
        /*draggable*/
        ctx[4]
      );
      toggle_class(
        div,
        "parent",
        /*isParent*/
        ctx[11]
      );
      set_style(
        div,
        "z-index",
        /*zIndex*/
        ctx[16]
      );
      set_style(div, "transform", style_transform);
      set_style(
        div,
        "visibility",
        /*initialized*/
        ctx[20] ? "visible" : "hidden"
      );
      add_location(div, file8, 118, 2, 3874);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (switch_instance) mount_component(switch_instance, div, null);
      ctx[50](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(drag_action = drag.call(null, div, {
            nodeId: (
              /*id*/
              ctx[1]
            ),
            isSelectable: (
              /*selectable*/
              ctx[5]
            ),
            disabled: false,
            handleSelector: (
              /*dragHandle*/
              ctx[19]
            ),
            noDragClass: "nodrag",
            nodeClickDistance: (
              /*nodeClickDistance*/
              ctx[22]
            ),
            onNodeMouseDown: (
              /*handleNodeSelection*/
              ctx[31]
            ),
            onDrag: (
              /*drag_function*/
              ctx[47]
            ),
            onDragStart: (
              /*drag_function_1*/
              ctx[48]
            ),
            onDragStop: (
              /*drag_function_2*/
              ctx[49]
            ),
            store: (
              /*store*/
              ctx[29]
            )
          })),
          listen_dev(
            div,
            "click",
            /*onSelectNodeHandler*/
            ctx[34],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[51],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[52],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mousemove",
            /*mousemove_handler*/
            ctx[53],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "contextmenu",
            /*contextmenu_handler*/
            ctx[54],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*nodeComponent*/
      134217728 && switch_value !== (switch_value = /*nodeComponent*/
      ctx2[27])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty[0] & /*data*/
        4) switch_instance_changes.data = /*data*/
        ctx2[2];
        if (dirty[0] & /*id*/
        2) switch_instance_changes.id = /*id*/
        ctx2[1];
        if (dirty[0] & /*selected*/
        8) switch_instance_changes.selected = /*selected*/
        ctx2[3];
        if (dirty[0] & /*selectable*/
        32) switch_instance_changes.selectable = /*selectable*/
        ctx2[5];
        if (dirty[0] & /*deletable*/
        128) switch_instance_changes.deletable = /*deletable*/
        ctx2[7];
        if (dirty[0] & /*sourcePosition*/
        16384) switch_instance_changes.sourcePosition = /*sourcePosition*/
        ctx2[14];
        if (dirty[0] & /*targetPosition*/
        32768) switch_instance_changes.targetPosition = /*targetPosition*/
        ctx2[15];
        if (dirty[0] & /*zIndex*/
        65536) switch_instance_changes.zIndex = /*zIndex*/
        ctx2[16];
        if (dirty[0] & /*dragging*/
        512) switch_instance_changes.dragging = /*dragging*/
        ctx2[9];
        if (dirty[0] & /*draggable*/
        16) switch_instance_changes.draggable = /*draggable*/
        ctx2[4];
        if (dirty[0] & /*dragHandle*/
        524288) switch_instance_changes.dragHandle = /*dragHandle*/
        ctx2[19];
        if (dirty[0] & /*parentId*/
        2097152) switch_instance_changes.parentId = /*parentId*/
        ctx2[21];
        if (dirty[0] & /*nodeType*/
        33554432) switch_instance_changes.type = /*nodeType*/
        ctx2[25];
        if (dirty[0] & /*$connectableStore*/
        268435456) switch_instance_changes.isConnectable = /*$connectableStore*/
        ctx2[28];
        if (dirty[0] & /*positionX*/
        4096) switch_instance_changes.positionAbsoluteX = /*positionX*/
        ctx2[12];
        if (dirty[0] & /*positionY*/
        8192) switch_instance_changes.positionAbsoluteY = /*positionY*/
        ctx2[13];
        if (dirty[0] & /*width*/
        131072) switch_instance_changes.width = /*width*/
        ctx2[17];
        if (dirty[0] & /*height*/
        262144) switch_instance_changes.height = /*height*/
        ctx2[18];
        switch_instance.$set(switch_instance_changes);
      }
      if (!current || dirty[0] & /*id*/
      2) {
        attr_dev(
          div,
          "data-id",
          /*id*/
          ctx2[1]
        );
      }
      if (!current || dirty[0] & /*nodeType, className*/
      41943040 && div_class_value !== (div_class_value = cc([
        "svelte-flow__node",
        `svelte-flow__node-${/*nodeType*/
        ctx2[25]}`,
        /*className*/
        ctx2[23]
      ]))) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*style, inlineStyleDimensions*/
      67109888 && div_style_value !== (div_style_value = /*style*/
      (ctx2[10] ?? "") + ";" + /*inlineStyleDimensions*/
      ctx2[26].width + /*inlineStyleDimensions*/
      ctx2[26].height)) {
        attr_dev(div, "style", div_style_value);
      }
      if (drag_action && is_function(drag_action.update) && dirty[0] & /*id, selectable, dragHandle, nodeClickDistance*/
      4718626) drag_action.update.call(null, {
        nodeId: (
          /*id*/
          ctx2[1]
        ),
        isSelectable: (
          /*selectable*/
          ctx2[5]
        ),
        disabled: false,
        handleSelector: (
          /*dragHandle*/
          ctx2[19]
        ),
        noDragClass: "nodrag",
        nodeClickDistance: (
          /*nodeClickDistance*/
          ctx2[22]
        ),
        onNodeMouseDown: (
          /*handleNodeSelection*/
          ctx2[31]
        ),
        onDrag: (
          /*drag_function*/
          ctx2[47]
        ),
        onDragStart: (
          /*drag_function_1*/
          ctx2[48]
        ),
        onDragStop: (
          /*drag_function_2*/
          ctx2[49]
        ),
        store: (
          /*store*/
          ctx2[29]
        )
      });
      if (!current || dirty[0] & /*nodeType, className, dragging*/
      41943552) {
        toggle_class(
          div,
          "dragging",
          /*dragging*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*nodeType, className, selected*/
      41943048) {
        toggle_class(
          div,
          "selected",
          /*selected*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*nodeType, className, draggable*/
      41943056) {
        toggle_class(
          div,
          "draggable",
          /*draggable*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*nodeType, className, connectable*/
      41943104) {
        toggle_class(
          div,
          "connectable",
          /*connectable*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*nodeType, className, selectable*/
      41943072) {
        toggle_class(
          div,
          "selectable",
          /*selectable*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*nodeType, className, draggable*/
      41943056) {
        toggle_class(
          div,
          "nopan",
          /*draggable*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*nodeType, className, isParent*/
      41945088) {
        toggle_class(
          div,
          "parent",
          /*isParent*/
          ctx2[11]
        );
      }
      const style_changed = dirty[0] & /*style, inlineStyleDimensions*/
      67109888;
      if (dirty[0] & /*zIndex, style, inlineStyleDimensions*/
      67175424 || style_changed) {
        set_style(
          div,
          "z-index",
          /*zIndex*/
          ctx2[16]
        );
      }
      if (dirty[0] & /*positionX, positionY, style, inlineStyleDimensions*/
      67122176 && style_transform !== (style_transform = `translate(${/*positionX*/
      ctx2[12]}px, ${/*positionY*/
      ctx2[13]}px)`) || style_changed) {
        set_style(div, "transform", style_transform);
      }
      if (dirty[0] & /*initialized, style, inlineStyleDimensions*/
      68158464 || style_changed) {
        set_style(
          div,
          "visibility",
          /*initialized*/
          ctx2[20] ? "visible" : "hidden"
        );
      }
    },
    i: function intro(local2) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (switch_instance) destroy_component(switch_instance);
      ctx[50](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(118:0) {#if !hidden}",
    ctx
  });
  return block;
}
function create_fragment20(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*hidden*/
  ctx[8] && create_if_block2(ctx);
  const block = {
    c: function create2() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!/*hidden*/
      ctx2[8]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*hidden*/
          256) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let nodeType;
  let nodeTypeValid;
  let nodeComponent;
  let inlineStyleDimensions;
  let $nodeTypes;
  let $connectableStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NodeWrapper", slots, []);
  let { node } = $$props;
  let { id: id2 } = $$props;
  let { data = {} } = $$props;
  let { selected = false } = $$props;
  let { draggable = void 0 } = $$props;
  let { selectable = void 0 } = $$props;
  let { connectable = true } = $$props;
  let { deletable = true } = $$props;
  let { hidden = false } = $$props;
  let { dragging = false } = $$props;
  let { resizeObserver = null } = $$props;
  let { style = void 0 } = $$props;
  let { type = "default" } = $$props;
  let { isParent = false } = $$props;
  let { positionX } = $$props;
  let { positionY } = $$props;
  let { sourcePosition = void 0 } = $$props;
  let { targetPosition = void 0 } = $$props;
  let { zIndex } = $$props;
  let { measuredWidth = void 0 } = $$props;
  let { measuredHeight = void 0 } = $$props;
  let { initialWidth = void 0 } = $$props;
  let { initialHeight = void 0 } = $$props;
  let { width = void 0 } = $$props;
  let { height = void 0 } = $$props;
  let { dragHandle = void 0 } = $$props;
  let { initialized = false } = $$props;
  let { parentId = void 0 } = $$props;
  let { nodeClickDistance = void 0 } = $$props;
  let { class: className = "" } = $$props;
  const store = useStore();
  const { nodeTypes, nodeDragThreshold, selectNodesOnDrag, handleNodeSelection, updateNodeInternals: updateNodeInternals2 } = store;
  validate_store(nodeTypes, "nodeTypes");
  component_subscribe($$self, nodeTypes, (value) => $$invalidate(46, $nodeTypes = value));
  let nodeRef;
  let prevNodeRef = null;
  const dispatchNodeEvent = createEventDispatcher();
  const connectableStore = writable(connectable);
  validate_store(connectableStore, "connectableStore");
  component_subscribe($$self, connectableStore, (value) => $$invalidate(28, $connectableStore = value));
  let prevType = void 0;
  let prevSourcePosition = void 0;
  let prevTargetPosition = void 0;
  setContext("svelteflow__node_id", id2);
  setContext("svelteflow__node_connectable", connectableStore);
  onDestroy(() => {
    if (prevNodeRef) {
      resizeObserver == null ? void 0 : resizeObserver.unobserve(prevNodeRef);
    }
  });
  function onSelectNodeHandler(event) {
    if (selectable && (!get_store_value(selectNodesOnDrag) || !draggable || get_store_value(nodeDragThreshold) > 0)) {
      handleNodeSelection(id2);
    }
    dispatchNodeEvent("nodeclick", { node: node.internals.userNode, event });
  }
  $$self.$$.on_mount.push(function() {
    if (node === void 0 && !("node" in $$props || $$self.$$.bound[$$self.$$.props["node"]])) {
      console_1.warn("<NodeWrapper> was created without expected prop 'node'");
    }
    if (id2 === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console_1.warn("<NodeWrapper> was created without expected prop 'id'");
    }
    if (positionX === void 0 && !("positionX" in $$props || $$self.$$.bound[$$self.$$.props["positionX"]])) {
      console_1.warn("<NodeWrapper> was created without expected prop 'positionX'");
    }
    if (positionY === void 0 && !("positionY" in $$props || $$self.$$.bound[$$self.$$.props["positionY"]])) {
      console_1.warn("<NodeWrapper> was created without expected prop 'positionY'");
    }
    if (zIndex === void 0 && !("zIndex" in $$props || $$self.$$.bound[$$self.$$.props["zIndex"]])) {
      console_1.warn("<NodeWrapper> was created without expected prop 'zIndex'");
    }
  });
  const writable_props = [
    "node",
    "id",
    "data",
    "selected",
    "draggable",
    "selectable",
    "connectable",
    "deletable",
    "hidden",
    "dragging",
    "resizeObserver",
    "style",
    "type",
    "isParent",
    "positionX",
    "positionY",
    "sourcePosition",
    "targetPosition",
    "zIndex",
    "measuredWidth",
    "measuredHeight",
    "initialWidth",
    "initialHeight",
    "width",
    "height",
    "dragHandle",
    "initialized",
    "parentId",
    "nodeClickDistance",
    "class"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console_1.warn(`<NodeWrapper> was created with unknown prop '${key2}'`);
  });
  const drag_function = (event, _, targetNode, nodes) => {
    dispatchNodeEvent("nodedrag", { event, targetNode, nodes });
  };
  const drag_function_1 = (event, _, targetNode, nodes) => {
    dispatchNodeEvent("nodedragstart", { event, targetNode, nodes });
  };
  const drag_function_2 = (event, _, targetNode, nodes) => {
    dispatchNodeEvent("nodedragstop", { event, targetNode, nodes });
  };
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      nodeRef = $$value;
      $$invalidate(24, nodeRef);
    });
  }
  const mouseenter_handler = (event) => dispatchNodeEvent("nodemouseenter", { node, event });
  const mouseleave_handler = (event) => dispatchNodeEvent("nodemouseleave", { node, event });
  const mousemove_handler = (event) => dispatchNodeEvent("nodemousemove", { node, event });
  const contextmenu_handler = (event) => dispatchNodeEvent("nodecontextmenu", { node, event });
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2) $$invalidate(0, node = $$props2.node);
    if ("id" in $$props2) $$invalidate(1, id2 = $$props2.id);
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
    if ("selected" in $$props2) $$invalidate(3, selected = $$props2.selected);
    if ("draggable" in $$props2) $$invalidate(4, draggable = $$props2.draggable);
    if ("selectable" in $$props2) $$invalidate(5, selectable = $$props2.selectable);
    if ("connectable" in $$props2) $$invalidate(6, connectable = $$props2.connectable);
    if ("deletable" in $$props2) $$invalidate(7, deletable = $$props2.deletable);
    if ("hidden" in $$props2) $$invalidate(8, hidden = $$props2.hidden);
    if ("dragging" in $$props2) $$invalidate(9, dragging = $$props2.dragging);
    if ("resizeObserver" in $$props2) $$invalidate(35, resizeObserver = $$props2.resizeObserver);
    if ("style" in $$props2) $$invalidate(10, style = $$props2.style);
    if ("type" in $$props2) $$invalidate(36, type = $$props2.type);
    if ("isParent" in $$props2) $$invalidate(11, isParent = $$props2.isParent);
    if ("positionX" in $$props2) $$invalidate(12, positionX = $$props2.positionX);
    if ("positionY" in $$props2) $$invalidate(13, positionY = $$props2.positionY);
    if ("sourcePosition" in $$props2) $$invalidate(14, sourcePosition = $$props2.sourcePosition);
    if ("targetPosition" in $$props2) $$invalidate(15, targetPosition = $$props2.targetPosition);
    if ("zIndex" in $$props2) $$invalidate(16, zIndex = $$props2.zIndex);
    if ("measuredWidth" in $$props2) $$invalidate(37, measuredWidth = $$props2.measuredWidth);
    if ("measuredHeight" in $$props2) $$invalidate(38, measuredHeight = $$props2.measuredHeight);
    if ("initialWidth" in $$props2) $$invalidate(39, initialWidth = $$props2.initialWidth);
    if ("initialHeight" in $$props2) $$invalidate(40, initialHeight = $$props2.initialHeight);
    if ("width" in $$props2) $$invalidate(17, width = $$props2.width);
    if ("height" in $$props2) $$invalidate(18, height = $$props2.height);
    if ("dragHandle" in $$props2) $$invalidate(19, dragHandle = $$props2.dragHandle);
    if ("initialized" in $$props2) $$invalidate(20, initialized = $$props2.initialized);
    if ("parentId" in $$props2) $$invalidate(21, parentId = $$props2.parentId);
    if ("nodeClickDistance" in $$props2) $$invalidate(22, nodeClickDistance = $$props2.nodeClickDistance);
    if ("class" in $$props2) $$invalidate(23, className = $$props2.class);
  };
  $$self.$capture_state = () => ({
    setContext,
    onDestroy,
    createEventDispatcher,
    get: get_store_value,
    writable,
    cc,
    errorMessages,
    Position,
    drag,
    useStore,
    DefaultNode: DefaultNode_default,
    getNodeInlineStyleDimensions,
    node,
    id: id2,
    data,
    selected,
    draggable,
    selectable,
    connectable,
    deletable,
    hidden,
    dragging,
    resizeObserver,
    style,
    type,
    isParent,
    positionX,
    positionY,
    sourcePosition,
    targetPosition,
    zIndex,
    measuredWidth,
    measuredHeight,
    initialWidth,
    initialHeight,
    width,
    height,
    dragHandle,
    initialized,
    parentId,
    nodeClickDistance,
    className,
    store,
    nodeTypes,
    nodeDragThreshold,
    selectNodesOnDrag,
    handleNodeSelection,
    updateNodeInternals: updateNodeInternals2,
    nodeRef,
    prevNodeRef,
    dispatchNodeEvent,
    connectableStore,
    prevType,
    prevSourcePosition,
    prevTargetPosition,
    onSelectNodeHandler,
    nodeType,
    inlineStyleDimensions,
    nodeTypeValid,
    nodeComponent,
    $nodeTypes,
    $connectableStore
  });
  $$self.$inject_state = ($$props2) => {
    if ("node" in $$props2) $$invalidate(0, node = $$props2.node);
    if ("id" in $$props2) $$invalidate(1, id2 = $$props2.id);
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
    if ("selected" in $$props2) $$invalidate(3, selected = $$props2.selected);
    if ("draggable" in $$props2) $$invalidate(4, draggable = $$props2.draggable);
    if ("selectable" in $$props2) $$invalidate(5, selectable = $$props2.selectable);
    if ("connectable" in $$props2) $$invalidate(6, connectable = $$props2.connectable);
    if ("deletable" in $$props2) $$invalidate(7, deletable = $$props2.deletable);
    if ("hidden" in $$props2) $$invalidate(8, hidden = $$props2.hidden);
    if ("dragging" in $$props2) $$invalidate(9, dragging = $$props2.dragging);
    if ("resizeObserver" in $$props2) $$invalidate(35, resizeObserver = $$props2.resizeObserver);
    if ("style" in $$props2) $$invalidate(10, style = $$props2.style);
    if ("type" in $$props2) $$invalidate(36, type = $$props2.type);
    if ("isParent" in $$props2) $$invalidate(11, isParent = $$props2.isParent);
    if ("positionX" in $$props2) $$invalidate(12, positionX = $$props2.positionX);
    if ("positionY" in $$props2) $$invalidate(13, positionY = $$props2.positionY);
    if ("sourcePosition" in $$props2) $$invalidate(14, sourcePosition = $$props2.sourcePosition);
    if ("targetPosition" in $$props2) $$invalidate(15, targetPosition = $$props2.targetPosition);
    if ("zIndex" in $$props2) $$invalidate(16, zIndex = $$props2.zIndex);
    if ("measuredWidth" in $$props2) $$invalidate(37, measuredWidth = $$props2.measuredWidth);
    if ("measuredHeight" in $$props2) $$invalidate(38, measuredHeight = $$props2.measuredHeight);
    if ("initialWidth" in $$props2) $$invalidate(39, initialWidth = $$props2.initialWidth);
    if ("initialHeight" in $$props2) $$invalidate(40, initialHeight = $$props2.initialHeight);
    if ("width" in $$props2) $$invalidate(17, width = $$props2.width);
    if ("height" in $$props2) $$invalidate(18, height = $$props2.height);
    if ("dragHandle" in $$props2) $$invalidate(19, dragHandle = $$props2.dragHandle);
    if ("initialized" in $$props2) $$invalidate(20, initialized = $$props2.initialized);
    if ("parentId" in $$props2) $$invalidate(21, parentId = $$props2.parentId);
    if ("nodeClickDistance" in $$props2) $$invalidate(22, nodeClickDistance = $$props2.nodeClickDistance);
    if ("className" in $$props2) $$invalidate(23, className = $$props2.className);
    if ("nodeRef" in $$props2) $$invalidate(24, nodeRef = $$props2.nodeRef);
    if ("prevNodeRef" in $$props2) $$invalidate(41, prevNodeRef = $$props2.prevNodeRef);
    if ("prevType" in $$props2) $$invalidate(42, prevType = $$props2.prevType);
    if ("prevSourcePosition" in $$props2) $$invalidate(43, prevSourcePosition = $$props2.prevSourcePosition);
    if ("prevTargetPosition" in $$props2) $$invalidate(44, prevTargetPosition = $$props2.prevTargetPosition);
    if ("nodeType" in $$props2) $$invalidate(25, nodeType = $$props2.nodeType);
    if ("inlineStyleDimensions" in $$props2) $$invalidate(26, inlineStyleDimensions = $$props2.inlineStyleDimensions);
    if ("nodeTypeValid" in $$props2) $$invalidate(45, nodeTypeValid = $$props2.nodeTypeValid);
    if ("nodeComponent" in $$props2) $$invalidate(27, nodeComponent = $$props2.nodeComponent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & /*type*/
    32) {
      $: $$invalidate(25, nodeType = type || "default");
    }
    if ($$self.$$.dirty[0] & /*nodeType*/
    33554432 | $$self.$$.dirty[1] & /*$nodeTypes*/
    32768) {
      $: $$invalidate(45, nodeTypeValid = !!$nodeTypes[nodeType]);
    }
    if ($$self.$$.dirty[0] & /*nodeType*/
    33554432 | $$self.$$.dirty[1] & /*$nodeTypes*/
    32768) {
      $: $$invalidate(27, nodeComponent = $nodeTypes[nodeType] || DefaultNode_default);
    }
    if ($$self.$$.dirty[1] & /*nodeTypeValid, type*/
    16416) {
      $: {
        if (!nodeTypeValid) {
          console.warn("003", errorMessages["error003"](type));
        }
      }
    }
    if ($$self.$$.dirty[0] & /*width, height*/
    393216 | $$self.$$.dirty[1] & /*initialWidth, initialHeight, measuredWidth, measuredHeight*/
    960) {
      $: $$invalidate(26, inlineStyleDimensions = getNodeInlineStyleDimensions({
        width,
        height,
        initialWidth,
        initialHeight,
        measuredWidth,
        measuredHeight
      }));
    }
    if ($$self.$$.dirty[0] & /*connectable*/
    64) {
      $: {
        connectableStore.set(!!connectable);
      }
    }
    if ($$self.$$.dirty[0] & /*nodeType, sourcePosition, targetPosition, id, nodeRef*/
    50380802 | $$self.$$.dirty[1] & /*prevType, prevSourcePosition, prevTargetPosition*/
    14336) {
      $: {
        const doUpdate = prevType && nodeType !== prevType || prevSourcePosition && sourcePosition !== prevSourcePosition || prevTargetPosition && targetPosition !== prevTargetPosition;
        if (doUpdate) {
          requestAnimationFrame(() => updateNodeInternals2(/* @__PURE__ */ new Map([[id2, { id: id2, nodeElement: nodeRef, force: true }]])));
        }
        $$invalidate(42, prevType = nodeType);
        $$invalidate(43, prevSourcePosition = sourcePosition);
        $$invalidate(44, prevTargetPosition = targetPosition);
      }
    }
    if ($$self.$$.dirty[0] & /*nodeRef, initialized*/
    17825792 | $$self.$$.dirty[1] & /*resizeObserver, prevNodeRef*/
    1040) {
      $: {
        if (resizeObserver && (nodeRef !== prevNodeRef || !initialized)) {
          prevNodeRef && resizeObserver.unobserve(prevNodeRef);
          nodeRef && resizeObserver.observe(nodeRef);
          $$invalidate(41, prevNodeRef = nodeRef);
        }
      }
    }
  };
  return [
    node,
    id2,
    data,
    selected,
    draggable,
    selectable,
    connectable,
    deletable,
    hidden,
    dragging,
    style,
    isParent,
    positionX,
    positionY,
    sourcePosition,
    targetPosition,
    zIndex,
    width,
    height,
    dragHandle,
    initialized,
    parentId,
    nodeClickDistance,
    className,
    nodeRef,
    nodeType,
    inlineStyleDimensions,
    nodeComponent,
    $connectableStore,
    store,
    nodeTypes,
    handleNodeSelection,
    dispatchNodeEvent,
    connectableStore,
    onSelectNodeHandler,
    resizeObserver,
    type,
    measuredWidth,
    measuredHeight,
    initialWidth,
    initialHeight,
    prevNodeRef,
    prevType,
    prevSourcePosition,
    prevTargetPosition,
    nodeTypeValid,
    $nodeTypes,
    drag_function,
    drag_function_1,
    drag_function_2,
    div_binding,
    mouseenter_handler,
    mouseleave_handler,
    mousemove_handler,
    contextmenu_handler
  ];
}
var NodeWrapper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance20,
      create_fragment20,
      not_equal,
      {
        node: 0,
        id: 1,
        data: 2,
        selected: 3,
        draggable: 4,
        selectable: 5,
        connectable: 6,
        deletable: 7,
        hidden: 8,
        dragging: 9,
        resizeObserver: 35,
        style: 10,
        type: 36,
        isParent: 11,
        positionX: 12,
        positionY: 13,
        sourcePosition: 14,
        targetPosition: 15,
        zIndex: 16,
        measuredWidth: 37,
        measuredHeight: 38,
        initialWidth: 39,
        initialHeight: 40,
        width: 17,
        height: 18,
        dragHandle: 19,
        initialized: 20,
        parentId: 21,
        nodeClickDistance: 22,
        class: 23
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NodeWrapper",
      options,
      id: create_fragment20.name
    });
  }
  get node() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set node(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get draggable() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set draggable(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectable() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectable(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get connectable() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set connectable(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deletable() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set deletable(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hidden() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hidden(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dragging() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dragging(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resizeObserver() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resizeObserver(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isParent() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isParent(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get positionX() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positionX(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get positionY() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positionY(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get measuredWidth() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set measuredWidth(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get measuredHeight() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set measuredHeight(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialWidth() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialWidth(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialHeight() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialHeight(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dragHandle() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dragHandle(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialized() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialized(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parentId() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parentId(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeClickDistance() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeClickDistance(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<NodeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<NodeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NodeWrapper_default = NodeWrapper;

// node_modules/@xyflow/svelte/dist/lib/container/NodeRenderer/NodeRenderer.svelte
var { Map: Map_1 } = globals;
var file9 = "node_modules/@xyflow/svelte/dist/lib/container/NodeRenderer/NodeRenderer.svelte";
function add_css4(target) {
  append_styles(target, "svelte-tf4uy4", ".svelte-flow__nodes.svelte-tf4uy4{width:100%;height:100%;position:absolute;left:0;top:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTm9kZVJlbmRlcmVyLnN2ZWx0ZSIsInNvdXJjZXMiOlsiTm9kZVJlbmRlcmVyLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PmltcG9ydCB7IG9uRGVzdHJveSB9IGZyb20gJ3N2ZWx0ZSc7XG5pbXBvcnQgeyBub2RlSGFzRGltZW5zaW9ucyB9IGZyb20gJ0B4eWZsb3cvc3lzdGVtJztcbmltcG9ydCB7IE5vZGVXcmFwcGVyIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9Ob2RlV3JhcHBlcic7XG5pbXBvcnQgeyB1c2VTdG9yZSB9IGZyb20gJy4uLy4uL3N0b3JlJztcbmV4cG9ydCBsZXQgbm9kZUNsaWNrRGlzdGFuY2UgPSAwO1xuY29uc3QgeyB2aXNpYmxlTm9kZXMsIG5vZGVzRHJhZ2dhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlLCBlbGVtZW50c1NlbGVjdGFibGUsIHVwZGF0ZU5vZGVJbnRlcm5hbHMsIHBhcmVudExvb2t1cCB9ID0gdXNlU3RvcmUoKTtcbmNvbnN0IHJlc2l6ZU9ic2VydmVyID0gdHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSAndW5kZWZpbmVkJ1xuICAgID8gbnVsbFxuICAgIDogbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gZW50cnkudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1pZCcpO1xuICAgICAgICAgICAgdXBkYXRlcy5zZXQoaWQsIHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBub2RlRWxlbWVudDogZW50cnkudGFyZ2V0LFxuICAgICAgICAgICAgICAgIGZvcmNlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHVwZGF0ZU5vZGVJbnRlcm5hbHModXBkYXRlcyk7XG4gICAgfSk7XG5vbkRlc3Ryb3koKCkgPT4ge1xuICAgIHJlc2l6ZU9ic2VydmVyPy5kaXNjb25uZWN0KCk7XG59KTtcbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwic3ZlbHRlLWZsb3dfX25vZGVzXCI+XG4gIHsjZWFjaCAkdmlzaWJsZU5vZGVzIGFzIG5vZGUgKG5vZGUuaWQpfVxuICAgIDxOb2RlV3JhcHBlclxuICAgICAge25vZGV9XG4gICAgICBpZD17bm9kZS5pZH1cbiAgICAgIGRhdGE9e25vZGUuZGF0YX1cbiAgICAgIHNlbGVjdGVkPXshIW5vZGUuc2VsZWN0ZWR9XG4gICAgICBoaWRkZW49eyEhbm9kZS5oaWRkZW59XG4gICAgICBkcmFnZ2FibGU9eyEhKG5vZGUuZHJhZ2dhYmxlIHx8ICgkbm9kZXNEcmFnZ2FibGUgJiYgdHlwZW9mIG5vZGUuZHJhZ2dhYmxlID09PSAndW5kZWZpbmVkJykpfVxuICAgICAgc2VsZWN0YWJsZT17ISEoXG4gICAgICAgIG5vZGUuc2VsZWN0YWJsZSB8fFxuICAgICAgICAoJGVsZW1lbnRzU2VsZWN0YWJsZSAmJiB0eXBlb2Ygbm9kZS5zZWxlY3RhYmxlID09PSAndW5kZWZpbmVkJylcbiAgICAgICl9XG4gICAgICBjb25uZWN0YWJsZT17ISEoXG4gICAgICAgIG5vZGUuY29ubmVjdGFibGUgfHxcbiAgICAgICAgKCRub2Rlc0Nvbm5lY3RhYmxlICYmIHR5cGVvZiBub2RlLmNvbm5lY3RhYmxlID09PSAndW5kZWZpbmVkJylcbiAgICAgICl9XG4gICAgICBkZWxldGFibGU9e25vZGUuZGVsZXRhYmxlID8/IHRydWV9XG4gICAgICBwb3NpdGlvblg9e25vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueH1cbiAgICAgIHBvc2l0aW9uWT17bm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55fVxuICAgICAgaXNQYXJlbnQ9eyRwYXJlbnRMb29rdXAuaGFzKG5vZGUuaWQpfVxuICAgICAgc3R5bGU9e25vZGUuc3R5bGV9XG4gICAgICBjbGFzcz17bm9kZS5jbGFzc31cbiAgICAgIHR5cGU9e25vZGUudHlwZSA/PyAnZGVmYXVsdCd9XG4gICAgICBzb3VyY2VQb3NpdGlvbj17bm9kZS5zb3VyY2VQb3NpdGlvbn1cbiAgICAgIHRhcmdldFBvc2l0aW9uPXtub2RlLnRhcmdldFBvc2l0aW9ufVxuICAgICAgZHJhZ2dpbmc9e25vZGUuZHJhZ2dpbmd9XG4gICAgICB6SW5kZXg9e25vZGUuaW50ZXJuYWxzLnogPz8gMH1cbiAgICAgIGRyYWdIYW5kbGU9e25vZGUuZHJhZ0hhbmRsZX1cbiAgICAgIGluaXRpYWxpemVkPXtub2RlSGFzRGltZW5zaW9ucyhub2RlKX1cbiAgICAgIHdpZHRoPXtub2RlLndpZHRofVxuICAgICAgaGVpZ2h0PXtub2RlLmhlaWdodH1cbiAgICAgIGluaXRpYWxXaWR0aD17bm9kZS5pbml0aWFsV2lkdGh9XG4gICAgICBpbml0aWFsSGVpZ2h0PXtub2RlLmluaXRpYWxIZWlnaHR9XG4gICAgICBtZWFzdXJlZFdpZHRoPXtub2RlLm1lYXN1cmVkLndpZHRofVxuICAgICAgbWVhc3VyZWRIZWlnaHQ9e25vZGUubWVhc3VyZWQuaGVpZ2h0fVxuICAgICAgcGFyZW50SWQ9e25vZGUucGFyZW50SWR9XG4gICAgICB7cmVzaXplT2JzZXJ2ZXJ9XG4gICAgICB7bm9kZUNsaWNrRGlzdGFuY2V9XG4gICAgICBvbjpub2RlY2xpY2tcbiAgICAgIG9uOm5vZGVtb3VzZWVudGVyXG4gICAgICBvbjpub2RlbW91c2Vtb3ZlXG4gICAgICBvbjpub2RlbW91c2VsZWF2ZVxuICAgICAgb246bm9kZWRyYWdcbiAgICAgIG9uOm5vZGVkcmFnc3RhcnRcbiAgICAgIG9uOm5vZGVkcmFnc3RvcFxuICAgICAgb246bm9kZWNvbnRleHRtZW51XG4gICAgLz5cbiAgey9lYWNofVxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgLnN2ZWx0ZS1mbG93X19ub2RlcyB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBsZWZ0OiAwO1xuICAgIHRvcDogMDtcbiAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUE2RUUsaUNBQW9CLENBQ2xCLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQUksQ0FDWixRQUFRLENBQUUsUUFBUSxDQUNsQixJQUFJLENBQUUsQ0FBQyxDQUNQLEdBQUcsQ0FBRSxDQUNQIn0= */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i];
  return child_ctx;
}
function create_each_block(key_1, ctx) {
  let first;
  let nodewrapper;
  let current;
  nodewrapper = new NodeWrapper_default({
    props: {
      node: (
        /*node*/
        ctx[21]
      ),
      id: (
        /*node*/
        ctx[21].id
      ),
      data: (
        /*node*/
        ctx[21].data
      ),
      selected: !!/*node*/
      ctx[21].selected,
      hidden: !!/*node*/
      ctx[21].hidden,
      draggable: !!/*node*/
      (ctx[21].draggable || /*$nodesDraggable*/
      ctx[2] && typeof /*node*/
      ctx[21].draggable === "undefined"),
      selectable: !!/*node*/
      (ctx[21].selectable || /*$elementsSelectable*/
      ctx[3] && typeof /*node*/
      ctx[21].selectable === "undefined"),
      connectable: !!/*node*/
      (ctx[21].connectable || /*$nodesConnectable*/
      ctx[4] && typeof /*node*/
      ctx[21].connectable === "undefined"),
      deletable: (
        /*node*/
        ctx[21].deletable ?? true
      ),
      positionX: (
        /*node*/
        ctx[21].internals.positionAbsolute.x
      ),
      positionY: (
        /*node*/
        ctx[21].internals.positionAbsolute.y
      ),
      isParent: (
        /*$parentLookup*/
        ctx[5].has(
          /*node*/
          ctx[21].id
        )
      ),
      style: (
        /*node*/
        ctx[21].style
      ),
      class: (
        /*node*/
        ctx[21].class
      ),
      type: (
        /*node*/
        ctx[21].type ?? "default"
      ),
      sourcePosition: (
        /*node*/
        ctx[21].sourcePosition
      ),
      targetPosition: (
        /*node*/
        ctx[21].targetPosition
      ),
      dragging: (
        /*node*/
        ctx[21].dragging
      ),
      zIndex: (
        /*node*/
        ctx[21].internals.z ?? 0
      ),
      dragHandle: (
        /*node*/
        ctx[21].dragHandle
      ),
      initialized: nodeHasDimensions(
        /*node*/
        ctx[21]
      ),
      width: (
        /*node*/
        ctx[21].width
      ),
      height: (
        /*node*/
        ctx[21].height
      ),
      initialWidth: (
        /*node*/
        ctx[21].initialWidth
      ),
      initialHeight: (
        /*node*/
        ctx[21].initialHeight
      ),
      measuredWidth: (
        /*node*/
        ctx[21].measured.width
      ),
      measuredHeight: (
        /*node*/
        ctx[21].measured.height
      ),
      parentId: (
        /*node*/
        ctx[21].parentId
      ),
      resizeObserver: (
        /*resizeObserver*/
        ctx[11]
      ),
      nodeClickDistance: (
        /*nodeClickDistance*/
        ctx[0]
      )
    },
    $$inline: true
  });
  nodewrapper.$on(
    "nodeclick",
    /*nodeclick_handler*/
    ctx[12]
  );
  nodewrapper.$on(
    "nodemouseenter",
    /*nodemouseenter_handler*/
    ctx[13]
  );
  nodewrapper.$on(
    "nodemousemove",
    /*nodemousemove_handler*/
    ctx[14]
  );
  nodewrapper.$on(
    "nodemouseleave",
    /*nodemouseleave_handler*/
    ctx[15]
  );
  nodewrapper.$on(
    "nodedrag",
    /*nodedrag_handler*/
    ctx[16]
  );
  nodewrapper.$on(
    "nodedragstart",
    /*nodedragstart_handler*/
    ctx[17]
  );
  nodewrapper.$on(
    "nodedragstop",
    /*nodedragstop_handler*/
    ctx[18]
  );
  nodewrapper.$on(
    "nodecontextmenu",
    /*nodecontextmenu_handler*/
    ctx[19]
  );
  const block = {
    key: key_1,
    first: null,
    c: function create2() {
      first = empty();
      create_component(nodewrapper.$$.fragment);
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      mount_component(nodewrapper, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const nodewrapper_changes = {};
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.node = /*node*/
      ctx[21];
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.id = /*node*/
      ctx[21].id;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.data = /*node*/
      ctx[21].data;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.selected = !!/*node*/
      ctx[21].selected;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.hidden = !!/*node*/
      ctx[21].hidden;
      if (dirty & /*$visibleNodes, $nodesDraggable*/
      6) nodewrapper_changes.draggable = !!/*node*/
      (ctx[21].draggable || /*$nodesDraggable*/
      ctx[2] && typeof /*node*/
      ctx[21].draggable === "undefined");
      if (dirty & /*$visibleNodes, $elementsSelectable*/
      10) nodewrapper_changes.selectable = !!/*node*/
      (ctx[21].selectable || /*$elementsSelectable*/
      ctx[3] && typeof /*node*/
      ctx[21].selectable === "undefined");
      if (dirty & /*$visibleNodes, $nodesConnectable*/
      18) nodewrapper_changes.connectable = !!/*node*/
      (ctx[21].connectable || /*$nodesConnectable*/
      ctx[4] && typeof /*node*/
      ctx[21].connectable === "undefined");
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.deletable = /*node*/
      ctx[21].deletable ?? true;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.positionX = /*node*/
      ctx[21].internals.positionAbsolute.x;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.positionY = /*node*/
      ctx[21].internals.positionAbsolute.y;
      if (dirty & /*$parentLookup, $visibleNodes*/
      34) nodewrapper_changes.isParent = /*$parentLookup*/
      ctx[5].has(
        /*node*/
        ctx[21].id
      );
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.style = /*node*/
      ctx[21].style;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.class = /*node*/
      ctx[21].class;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.type = /*node*/
      ctx[21].type ?? "default";
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.sourcePosition = /*node*/
      ctx[21].sourcePosition;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.targetPosition = /*node*/
      ctx[21].targetPosition;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.dragging = /*node*/
      ctx[21].dragging;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.zIndex = /*node*/
      ctx[21].internals.z ?? 0;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.dragHandle = /*node*/
      ctx[21].dragHandle;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.initialized = nodeHasDimensions(
        /*node*/
        ctx[21]
      );
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.width = /*node*/
      ctx[21].width;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.height = /*node*/
      ctx[21].height;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.initialWidth = /*node*/
      ctx[21].initialWidth;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.initialHeight = /*node*/
      ctx[21].initialHeight;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.measuredWidth = /*node*/
      ctx[21].measured.width;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.measuredHeight = /*node*/
      ctx[21].measured.height;
      if (dirty & /*$visibleNodes*/
      2) nodewrapper_changes.parentId = /*node*/
      ctx[21].parentId;
      if (dirty & /*nodeClickDistance*/
      1) nodewrapper_changes.nodeClickDistance = /*nodeClickDistance*/
      ctx[0];
      nodewrapper.$set(nodewrapper_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(nodewrapper.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(nodewrapper.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(nodewrapper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(27:2) {#each $visibleNodes as node (node.id)}",
    ctx
  });
  return block;
}
function create_fragment21(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = new Map_1();
  let current;
  let each_value = ensure_array_like_dev(
    /*$visibleNodes*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*node*/
    ctx2[21].id
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key2 = get_key(child_ctx);
    each_1_lookup.set(key2, each_blocks[i] = create_each_block(key2, child_ctx));
  }
  const block = {
    c: function create2() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div, "class", "svelte-flow__nodes svelte-tf4uy4");
      add_location(div, file9, 25, 0, 863);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$visibleNodes, $nodesDraggable, $elementsSelectable, $nodesConnectable, $parentLookup, resizeObserver, nodeClickDistance*/
      2111) {
        each_value = ensure_array_like_dev(
          /*$visibleNodes*/
          ctx2[1]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block, null, get_each_context);
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local2) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  let $visibleNodes;
  let $nodesDraggable;
  let $elementsSelectable;
  let $nodesConnectable;
  let $parentLookup;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NodeRenderer", slots, []);
  let { nodeClickDistance = 0 } = $$props;
  const { visibleNodes, nodesDraggable, nodesConnectable, elementsSelectable, updateNodeInternals: updateNodeInternals2, parentLookup } = useStore();
  validate_store(visibleNodes, "visibleNodes");
  component_subscribe($$self, visibleNodes, (value) => $$invalidate(1, $visibleNodes = value));
  validate_store(nodesDraggable, "nodesDraggable");
  component_subscribe($$self, nodesDraggable, (value) => $$invalidate(2, $nodesDraggable = value));
  validate_store(nodesConnectable, "nodesConnectable");
  component_subscribe($$self, nodesConnectable, (value) => $$invalidate(4, $nodesConnectable = value));
  validate_store(elementsSelectable, "elementsSelectable");
  component_subscribe($$self, elementsSelectable, (value) => $$invalidate(3, $elementsSelectable = value));
  validate_store(parentLookup, "parentLookup");
  component_subscribe($$self, parentLookup, (value) => $$invalidate(5, $parentLookup = value));
  const resizeObserver = typeof ResizeObserver === "undefined" ? null : new ResizeObserver((entries) => {
    const updates = /* @__PURE__ */ new Map();
    entries.forEach((entry) => {
      const id2 = entry.target.getAttribute("data-id");
      updates.set(id2, {
        id: id2,
        nodeElement: entry.target,
        force: true
      });
    });
    updateNodeInternals2(updates);
  });
  onDestroy(() => {
    resizeObserver == null ? void 0 : resizeObserver.disconnect();
  });
  const writable_props = ["nodeClickDistance"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<NodeRenderer> was created with unknown prop '${key2}'`);
  });
  function nodeclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodemouseenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodemousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodemouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodedrag_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodedragstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodedragstop_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodecontextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("nodeClickDistance" in $$props2) $$invalidate(0, nodeClickDistance = $$props2.nodeClickDistance);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    nodeHasDimensions,
    NodeWrapper: NodeWrapper_default,
    useStore,
    nodeClickDistance,
    visibleNodes,
    nodesDraggable,
    nodesConnectable,
    elementsSelectable,
    updateNodeInternals: updateNodeInternals2,
    parentLookup,
    resizeObserver,
    $visibleNodes,
    $nodesDraggable,
    $elementsSelectable,
    $nodesConnectable,
    $parentLookup
  });
  $$self.$inject_state = ($$props2) => {
    if ("nodeClickDistance" in $$props2) $$invalidate(0, nodeClickDistance = $$props2.nodeClickDistance);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    nodeClickDistance,
    $visibleNodes,
    $nodesDraggable,
    $elementsSelectable,
    $nodesConnectable,
    $parentLookup,
    visibleNodes,
    nodesDraggable,
    nodesConnectable,
    elementsSelectable,
    parentLookup,
    resizeObserver,
    nodeclick_handler,
    nodemouseenter_handler,
    nodemousemove_handler,
    nodemouseleave_handler,
    nodedrag_handler,
    nodedragstart_handler,
    nodedragstop_handler,
    nodecontextmenu_handler
  ];
}
var NodeRenderer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, { nodeClickDistance: 0 }, add_css4);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NodeRenderer",
      options,
      id: create_fragment21.name
    });
  }
  get nodeClickDistance() {
    throw new Error("<NodeRenderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeClickDistance(value) {
    throw new Error("<NodeRenderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NodeRenderer_default = NodeRenderer;

// node_modules/@xyflow/svelte/dist/lib/components/EdgeWrapper/EdgeWrapper.svelte
var file10 = "node_modules/@xyflow/svelte/dist/lib/components/EdgeWrapper/EdgeWrapper.svelte";
function create_if_block3(ctx) {
  let svg;
  let g;
  let switch_instance;
  let g_class_value;
  let g_aria_label_value;
  let current;
  let mounted;
  let dispose;
  var switch_value = (
    /*edgeComponent*/
    ctx[27]
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        id: (
          /*id*/
          ctx2[0]
        ),
        source: (
          /*source*/
          ctx2[1]
        ),
        target: (
          /*target*/
          ctx2[2]
        ),
        sourceX: (
          /*sourceX*/
          ctx2[14]
        ),
        sourceY: (
          /*sourceY*/
          ctx2[15]
        ),
        targetX: (
          /*targetX*/
          ctx2[16]
        ),
        targetY: (
          /*targetY*/
          ctx2[17]
        ),
        sourcePosition: (
          /*sourcePosition*/
          ctx2[18]
        ),
        targetPosition: (
          /*targetPosition*/
          ctx2[19]
        ),
        animated: (
          /*animated*/
          ctx2[6]
        ),
        selected: (
          /*selected*/
          ctx2[7]
        ),
        label: (
          /*label*/
          ctx2[10]
        ),
        labelStyle: (
          /*labelStyle*/
          ctx2[11]
        ),
        data: (
          /*data*/
          ctx2[3]
        ),
        style: (
          /*style*/
          ctx2[4]
        ),
        interactionWidth: (
          /*interactionWidth*/
          ctx2[21]
        ),
        selectable: (
          /*isSelectable*/
          ctx2[24]
        ),
        deletable: (
          /*deletable*/
          ctx2[8] ?? true
        ),
        type: (
          /*edgeType*/
          ctx2[23]
        ),
        sourceHandleId: (
          /*sourceHandle*/
          ctx2[12]
        ),
        targetHandleId: (
          /*targetHandle*/
          ctx2[13]
        ),
        markerStart: (
          /*markerStartUrl*/
          ctx2[26]
        ),
        markerEnd: (
          /*markerEndUrl*/
          ctx2[25]
        )
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create2() {
      svg = svg_element("svg");
      g = svg_element("g");
      if (switch_instance) create_component(switch_instance.$$.fragment);
      attr_dev(g, "class", g_class_value = cc([
        "svelte-flow__edge",
        /*className*/
        ctx[22]
      ]));
      attr_dev(
        g,
        "data-id",
        /*id*/
        ctx[0]
      );
      attr_dev(g, "aria-label", g_aria_label_value = /*ariaLabel*/
      ctx[20] === null ? void 0 : (
        /*ariaLabel*/
        ctx[20] ? (
          /*ariaLabel*/
          ctx[20]
        ) : `Edge from ${/*source*/
        ctx[1]} to ${/*target*/
        ctx[2]}`
      ));
      attr_dev(g, "role", "img");
      toggle_class(
        g,
        "animated",
        /*animated*/
        ctx[6]
      );
      toggle_class(
        g,
        "selected",
        /*selected*/
        ctx[7]
      );
      toggle_class(
        g,
        "selectable",
        /*isSelectable*/
        ctx[24]
      );
      add_location(g, file10, 65, 4, 2183);
      set_style(
        svg,
        "z-index",
        /*zIndex*/
        ctx[5]
      );
      add_location(svg, file10, 64, 2, 2150);
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, g);
      if (switch_instance) mount_component(switch_instance, g, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            g,
            "click",
            /*onClick*/
            ctx[32],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            g,
            "contextmenu",
            /*contextmenu_handler*/
            ctx[41],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            g,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[42],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            g,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[43],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*edgeComponent*/
      134217728 && switch_value !== (switch_value = /*edgeComponent*/
      ctx2[27])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, g, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty[0] & /*id*/
        1) switch_instance_changes.id = /*id*/
        ctx2[0];
        if (dirty[0] & /*source*/
        2) switch_instance_changes.source = /*source*/
        ctx2[1];
        if (dirty[0] & /*target*/
        4) switch_instance_changes.target = /*target*/
        ctx2[2];
        if (dirty[0] & /*sourceX*/
        16384) switch_instance_changes.sourceX = /*sourceX*/
        ctx2[14];
        if (dirty[0] & /*sourceY*/
        32768) switch_instance_changes.sourceY = /*sourceY*/
        ctx2[15];
        if (dirty[0] & /*targetX*/
        65536) switch_instance_changes.targetX = /*targetX*/
        ctx2[16];
        if (dirty[0] & /*targetY*/
        131072) switch_instance_changes.targetY = /*targetY*/
        ctx2[17];
        if (dirty[0] & /*sourcePosition*/
        262144) switch_instance_changes.sourcePosition = /*sourcePosition*/
        ctx2[18];
        if (dirty[0] & /*targetPosition*/
        524288) switch_instance_changes.targetPosition = /*targetPosition*/
        ctx2[19];
        if (dirty[0] & /*animated*/
        64) switch_instance_changes.animated = /*animated*/
        ctx2[6];
        if (dirty[0] & /*selected*/
        128) switch_instance_changes.selected = /*selected*/
        ctx2[7];
        if (dirty[0] & /*label*/
        1024) switch_instance_changes.label = /*label*/
        ctx2[10];
        if (dirty[0] & /*labelStyle*/
        2048) switch_instance_changes.labelStyle = /*labelStyle*/
        ctx2[11];
        if (dirty[0] & /*data*/
        8) switch_instance_changes.data = /*data*/
        ctx2[3];
        if (dirty[0] & /*style*/
        16) switch_instance_changes.style = /*style*/
        ctx2[4];
        if (dirty[0] & /*interactionWidth*/
        2097152) switch_instance_changes.interactionWidth = /*interactionWidth*/
        ctx2[21];
        if (dirty[0] & /*isSelectable*/
        16777216) switch_instance_changes.selectable = /*isSelectable*/
        ctx2[24];
        if (dirty[0] & /*deletable*/
        256) switch_instance_changes.deletable = /*deletable*/
        ctx2[8] ?? true;
        if (dirty[0] & /*edgeType*/
        8388608) switch_instance_changes.type = /*edgeType*/
        ctx2[23];
        if (dirty[0] & /*sourceHandle*/
        4096) switch_instance_changes.sourceHandleId = /*sourceHandle*/
        ctx2[12];
        if (dirty[0] & /*targetHandle*/
        8192) switch_instance_changes.targetHandleId = /*targetHandle*/
        ctx2[13];
        if (dirty[0] & /*markerStartUrl*/
        67108864) switch_instance_changes.markerStart = /*markerStartUrl*/
        ctx2[26];
        if (dirty[0] & /*markerEndUrl*/
        33554432) switch_instance_changes.markerEnd = /*markerEndUrl*/
        ctx2[25];
        switch_instance.$set(switch_instance_changes);
      }
      if (!current || dirty[0] & /*className*/
      4194304 && g_class_value !== (g_class_value = cc([
        "svelte-flow__edge",
        /*className*/
        ctx2[22]
      ]))) {
        attr_dev(g, "class", g_class_value);
      }
      if (!current || dirty[0] & /*id*/
      1) {
        attr_dev(
          g,
          "data-id",
          /*id*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*ariaLabel, source, target*/
      1048582 && g_aria_label_value !== (g_aria_label_value = /*ariaLabel*/
      ctx2[20] === null ? void 0 : (
        /*ariaLabel*/
        ctx2[20] ? (
          /*ariaLabel*/
          ctx2[20]
        ) : `Edge from ${/*source*/
        ctx2[1]} to ${/*target*/
        ctx2[2]}`
      ))) {
        attr_dev(g, "aria-label", g_aria_label_value);
      }
      if (!current || dirty[0] & /*className, animated*/
      4194368) {
        toggle_class(
          g,
          "animated",
          /*animated*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*className, selected*/
      4194432) {
        toggle_class(
          g,
          "selected",
          /*selected*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*className, isSelectable*/
      20971520) {
        toggle_class(
          g,
          "selectable",
          /*isSelectable*/
          ctx2[24]
        );
      }
      if (dirty[0] & /*zIndex*/
      32) {
        set_style(
          svg,
          "z-index",
          /*zIndex*/
          ctx2[5]
        );
      }
    },
    i: function intro(local2) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (switch_instance) destroy_component(switch_instance);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(64:0) {#if !hidden}",
    ctx
  });
  return block;
}
function create_fragment22(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*hidden*/
  ctx[9] && create_if_block3(ctx);
  const block = {
    c: function create2() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!/*hidden*/
      ctx2[9]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*hidden*/
          512) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let edgeType;
  let edgeComponent;
  let markerStartUrl;
  let markerEndUrl;
  let isSelectable;
  let $edgeLookup;
  let $elementsSelectable;
  let $flowId;
  let $edgeTypes;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EdgeWrapper", slots, []);
  let { id: id2 } = $$props;
  let { type = "default" } = $$props;
  let { source = "" } = $$props;
  let { target = "" } = $$props;
  let { data = {} } = $$props;
  let { style = void 0 } = $$props;
  let { zIndex = void 0 } = $$props;
  let { animated = false } = $$props;
  let { selected = false } = $$props;
  let { selectable = void 0 } = $$props;
  let { deletable = void 0 } = $$props;
  let { hidden = false } = $$props;
  let { label = void 0 } = $$props;
  let { labelStyle = void 0 } = $$props;
  let { markerStart = void 0 } = $$props;
  let { markerEnd = void 0 } = $$props;
  let { sourceHandle = void 0 } = $$props;
  let { targetHandle = void 0 } = $$props;
  let { sourceX } = $$props;
  let { sourceY } = $$props;
  let { targetX } = $$props;
  let { targetY } = $$props;
  let { sourcePosition } = $$props;
  let { targetPosition } = $$props;
  let { ariaLabel = void 0 } = $$props;
  let { interactionWidth = void 0 } = $$props;
  let { class: className = "" } = $$props;
  setContext("svelteflow__edge_id", id2);
  const { edgeLookup, edgeTypes, flowId, elementsSelectable } = useStore();
  validate_store(edgeLookup, "edgeLookup");
  component_subscribe($$self, edgeLookup, (value) => $$invalidate(44, $edgeLookup = value));
  validate_store(edgeTypes, "edgeTypes");
  component_subscribe($$self, edgeTypes, (value) => $$invalidate(40, $edgeTypes = value));
  validate_store(flowId, "flowId");
  component_subscribe($$self, flowId, (value) => $$invalidate(39, $flowId = value));
  validate_store(elementsSelectable, "elementsSelectable");
  component_subscribe($$self, elementsSelectable, (value) => $$invalidate(38, $elementsSelectable = value));
  const dispatch2 = createEventDispatcher();
  const handleEdgeSelect = useHandleEdgeSelect();
  function onClick(event) {
    const edge = $edgeLookup.get(id2);
    if (edge) {
      handleEdgeSelect(id2);
      dispatch2("edgeclick", { event, edge });
    }
  }
  function onMouseEvent(event, type2) {
    const edge = $edgeLookup.get(id2);
    if (edge) {
      dispatch2(type2, { event, edge });
    }
  }
  $$self.$$.on_mount.push(function() {
    if (id2 === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console.warn("<EdgeWrapper> was created without expected prop 'id'");
    }
    if (sourceX === void 0 && !("sourceX" in $$props || $$self.$$.bound[$$self.$$.props["sourceX"]])) {
      console.warn("<EdgeWrapper> was created without expected prop 'sourceX'");
    }
    if (sourceY === void 0 && !("sourceY" in $$props || $$self.$$.bound[$$self.$$.props["sourceY"]])) {
      console.warn("<EdgeWrapper> was created without expected prop 'sourceY'");
    }
    if (targetX === void 0 && !("targetX" in $$props || $$self.$$.bound[$$self.$$.props["targetX"]])) {
      console.warn("<EdgeWrapper> was created without expected prop 'targetX'");
    }
    if (targetY === void 0 && !("targetY" in $$props || $$self.$$.bound[$$self.$$.props["targetY"]])) {
      console.warn("<EdgeWrapper> was created without expected prop 'targetY'");
    }
    if (sourcePosition === void 0 && !("sourcePosition" in $$props || $$self.$$.bound[$$self.$$.props["sourcePosition"]])) {
      console.warn("<EdgeWrapper> was created without expected prop 'sourcePosition'");
    }
    if (targetPosition === void 0 && !("targetPosition" in $$props || $$self.$$.bound[$$self.$$.props["targetPosition"]])) {
      console.warn("<EdgeWrapper> was created without expected prop 'targetPosition'");
    }
  });
  const writable_props = [
    "id",
    "type",
    "source",
    "target",
    "data",
    "style",
    "zIndex",
    "animated",
    "selected",
    "selectable",
    "deletable",
    "hidden",
    "label",
    "labelStyle",
    "markerStart",
    "markerEnd",
    "sourceHandle",
    "targetHandle",
    "sourceX",
    "sourceY",
    "targetX",
    "targetY",
    "sourcePosition",
    "targetPosition",
    "ariaLabel",
    "interactionWidth",
    "class"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<EdgeWrapper> was created with unknown prop '${key2}'`);
  });
  const contextmenu_handler = (e) => {
    onMouseEvent(e, "edgecontextmenu");
  };
  const mouseenter_handler = (e) => {
    onMouseEvent(e, "edgemouseenter");
  };
  const mouseleave_handler = (e) => {
    onMouseEvent(e, "edgemouseleave");
  };
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id2 = $$props2.id);
    if ("type" in $$props2) $$invalidate(34, type = $$props2.type);
    if ("source" in $$props2) $$invalidate(1, source = $$props2.source);
    if ("target" in $$props2) $$invalidate(2, target = $$props2.target);
    if ("data" in $$props2) $$invalidate(3, data = $$props2.data);
    if ("style" in $$props2) $$invalidate(4, style = $$props2.style);
    if ("zIndex" in $$props2) $$invalidate(5, zIndex = $$props2.zIndex);
    if ("animated" in $$props2) $$invalidate(6, animated = $$props2.animated);
    if ("selected" in $$props2) $$invalidate(7, selected = $$props2.selected);
    if ("selectable" in $$props2) $$invalidate(35, selectable = $$props2.selectable);
    if ("deletable" in $$props2) $$invalidate(8, deletable = $$props2.deletable);
    if ("hidden" in $$props2) $$invalidate(9, hidden = $$props2.hidden);
    if ("label" in $$props2) $$invalidate(10, label = $$props2.label);
    if ("labelStyle" in $$props2) $$invalidate(11, labelStyle = $$props2.labelStyle);
    if ("markerStart" in $$props2) $$invalidate(36, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2) $$invalidate(37, markerEnd = $$props2.markerEnd);
    if ("sourceHandle" in $$props2) $$invalidate(12, sourceHandle = $$props2.sourceHandle);
    if ("targetHandle" in $$props2) $$invalidate(13, targetHandle = $$props2.targetHandle);
    if ("sourceX" in $$props2) $$invalidate(14, sourceX = $$props2.sourceX);
    if ("sourceY" in $$props2) $$invalidate(15, sourceY = $$props2.sourceY);
    if ("targetX" in $$props2) $$invalidate(16, targetX = $$props2.targetX);
    if ("targetY" in $$props2) $$invalidate(17, targetY = $$props2.targetY);
    if ("sourcePosition" in $$props2) $$invalidate(18, sourcePosition = $$props2.sourcePosition);
    if ("targetPosition" in $$props2) $$invalidate(19, targetPosition = $$props2.targetPosition);
    if ("ariaLabel" in $$props2) $$invalidate(20, ariaLabel = $$props2.ariaLabel);
    if ("interactionWidth" in $$props2) $$invalidate(21, interactionWidth = $$props2.interactionWidth);
    if ("class" in $$props2) $$invalidate(22, className = $$props2.class);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    setContext,
    cc,
    getMarkerId,
    useStore,
    BezierEdgeInternal: BezierEdgeInternal_default,
    useHandleEdgeSelect,
    id: id2,
    type,
    source,
    target,
    data,
    style,
    zIndex,
    animated,
    selected,
    selectable,
    deletable,
    hidden,
    label,
    labelStyle,
    markerStart,
    markerEnd,
    sourceHandle,
    targetHandle,
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourcePosition,
    targetPosition,
    ariaLabel,
    interactionWidth,
    className,
    edgeLookup,
    edgeTypes,
    flowId,
    elementsSelectable,
    dispatch: dispatch2,
    handleEdgeSelect,
    onClick,
    onMouseEvent,
    isSelectable,
    markerEndUrl,
    markerStartUrl,
    edgeType,
    edgeComponent,
    $edgeLookup,
    $elementsSelectable,
    $flowId,
    $edgeTypes
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id2 = $$props2.id);
    if ("type" in $$props2) $$invalidate(34, type = $$props2.type);
    if ("source" in $$props2) $$invalidate(1, source = $$props2.source);
    if ("target" in $$props2) $$invalidate(2, target = $$props2.target);
    if ("data" in $$props2) $$invalidate(3, data = $$props2.data);
    if ("style" in $$props2) $$invalidate(4, style = $$props2.style);
    if ("zIndex" in $$props2) $$invalidate(5, zIndex = $$props2.zIndex);
    if ("animated" in $$props2) $$invalidate(6, animated = $$props2.animated);
    if ("selected" in $$props2) $$invalidate(7, selected = $$props2.selected);
    if ("selectable" in $$props2) $$invalidate(35, selectable = $$props2.selectable);
    if ("deletable" in $$props2) $$invalidate(8, deletable = $$props2.deletable);
    if ("hidden" in $$props2) $$invalidate(9, hidden = $$props2.hidden);
    if ("label" in $$props2) $$invalidate(10, label = $$props2.label);
    if ("labelStyle" in $$props2) $$invalidate(11, labelStyle = $$props2.labelStyle);
    if ("markerStart" in $$props2) $$invalidate(36, markerStart = $$props2.markerStart);
    if ("markerEnd" in $$props2) $$invalidate(37, markerEnd = $$props2.markerEnd);
    if ("sourceHandle" in $$props2) $$invalidate(12, sourceHandle = $$props2.sourceHandle);
    if ("targetHandle" in $$props2) $$invalidate(13, targetHandle = $$props2.targetHandle);
    if ("sourceX" in $$props2) $$invalidate(14, sourceX = $$props2.sourceX);
    if ("sourceY" in $$props2) $$invalidate(15, sourceY = $$props2.sourceY);
    if ("targetX" in $$props2) $$invalidate(16, targetX = $$props2.targetX);
    if ("targetY" in $$props2) $$invalidate(17, targetY = $$props2.targetY);
    if ("sourcePosition" in $$props2) $$invalidate(18, sourcePosition = $$props2.sourcePosition);
    if ("targetPosition" in $$props2) $$invalidate(19, targetPosition = $$props2.targetPosition);
    if ("ariaLabel" in $$props2) $$invalidate(20, ariaLabel = $$props2.ariaLabel);
    if ("interactionWidth" in $$props2) $$invalidate(21, interactionWidth = $$props2.interactionWidth);
    if ("className" in $$props2) $$invalidate(22, className = $$props2.className);
    if ("isSelectable" in $$props2) $$invalidate(24, isSelectable = $$props2.isSelectable);
    if ("markerEndUrl" in $$props2) $$invalidate(25, markerEndUrl = $$props2.markerEndUrl);
    if ("markerStartUrl" in $$props2) $$invalidate(26, markerStartUrl = $$props2.markerStartUrl);
    if ("edgeType" in $$props2) $$invalidate(23, edgeType = $$props2.edgeType);
    if ("edgeComponent" in $$props2) $$invalidate(27, edgeComponent = $$props2.edgeComponent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & /*type*/
    8) {
      $: $$invalidate(23, edgeType = type || "default");
    }
    if ($$self.$$.dirty[0] & /*edgeType*/
    8388608 | $$self.$$.dirty[1] & /*$edgeTypes*/
    512) {
      $: $$invalidate(27, edgeComponent = $edgeTypes[edgeType] || BezierEdgeInternal_default);
    }
    if ($$self.$$.dirty[1] & /*markerStart, $flowId*/
    288) {
      $: $$invalidate(26, markerStartUrl = markerStart ? `url('#${getMarkerId(markerStart, $flowId)}')` : void 0);
    }
    if ($$self.$$.dirty[1] & /*markerEnd, $flowId*/
    320) {
      $: $$invalidate(25, markerEndUrl = markerEnd ? `url('#${getMarkerId(markerEnd, $flowId)}')` : void 0);
    }
    if ($$self.$$.dirty[1] & /*selectable, $elementsSelectable*/
    144) {
      $: $$invalidate(24, isSelectable = selectable ?? $elementsSelectable);
    }
  };
  return [
    id2,
    source,
    target,
    data,
    style,
    zIndex,
    animated,
    selected,
    deletable,
    hidden,
    label,
    labelStyle,
    sourceHandle,
    targetHandle,
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourcePosition,
    targetPosition,
    ariaLabel,
    interactionWidth,
    className,
    edgeType,
    isSelectable,
    markerEndUrl,
    markerStartUrl,
    edgeComponent,
    edgeLookup,
    edgeTypes,
    flowId,
    elementsSelectable,
    onClick,
    onMouseEvent,
    type,
    selectable,
    markerStart,
    markerEnd,
    $elementsSelectable,
    $flowId,
    $edgeTypes,
    contextmenu_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var EdgeWrapper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance22,
      create_fragment22,
      not_equal,
      {
        id: 0,
        type: 34,
        source: 1,
        target: 2,
        data: 3,
        style: 4,
        zIndex: 5,
        animated: 6,
        selected: 7,
        selectable: 35,
        deletable: 8,
        hidden: 9,
        label: 10,
        labelStyle: 11,
        markerStart: 36,
        markerEnd: 37,
        sourceHandle: 12,
        targetHandle: 13,
        sourceX: 14,
        sourceY: 15,
        targetX: 16,
        targetY: 17,
        sourcePosition: 18,
        targetPosition: 19,
        ariaLabel: 20,
        interactionWidth: 21,
        class: 22
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EdgeWrapper",
      options,
      id: create_fragment22.name
    });
  }
  get id() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get source() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set source(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animated() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animated(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectable() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectable(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deletable() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set deletable(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hidden() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hidden(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelStyle() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelStyle(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerStart() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerStart(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerEnd() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerEnd(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceHandle() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceHandle(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetHandle() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetHandle(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceX() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceX(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourceY() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourceY(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetX() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetX(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetY() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetY(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sourcePosition() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sourcePosition(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetPosition() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetPosition(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabel() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactionWidth() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactionWidth(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<EdgeWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<EdgeWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var EdgeWrapper_default = EdgeWrapper;

// node_modules/@xyflow/svelte/dist/lib/components/CallOnMount/CallOnMount.svelte
function create_fragment23(ctx) {
  const block = {
    c: noop,
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CallOnMount", slots, []);
  let { onMount: _onMount = void 0 } = $$props;
  let { onDestroy: _onDestroy = void 0 } = $$props;
  onMount(() => {
    _onMount == null ? void 0 : _onMount();
    return _onDestroy;
  });
  const writable_props = ["onMount", "onDestroy"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<CallOnMount> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("onMount" in $$props2) $$invalidate(0, _onMount = $$props2.onMount);
    if ("onDestroy" in $$props2) $$invalidate(1, _onDestroy = $$props2.onDestroy);
  };
  $$self.$capture_state = () => ({ onMount, _onMount, _onDestroy });
  $$self.$inject_state = ($$props2) => {
    if ("_onMount" in $$props2) $$invalidate(0, _onMount = $$props2._onMount);
    if ("_onDestroy" in $$props2) $$invalidate(1, _onDestroy = $$props2._onDestroy);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [_onMount, _onDestroy];
}
var CallOnMount = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, { onMount: 0, onDestroy: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CallOnMount",
      options,
      id: create_fragment23.name
    });
  }
  get onMount() {
    throw new Error("<CallOnMount>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMount(value) {
    throw new Error("<CallOnMount>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDestroy() {
    throw new Error("<CallOnMount>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDestroy(value) {
    throw new Error("<CallOnMount>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CallOnMount_default = CallOnMount;

// node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/MarkerDefinition/MarkerDefinition.svelte
var file11 = "node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/MarkerDefinition/MarkerDefinition.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function create_each_block2(key_1, ctx) {
  let first;
  let marker_1;
  let current;
  const marker_1_spread_levels = [
    /*marker*/
    ctx[2]
  ];
  let marker_1_props = {};
  for (let i = 0; i < marker_1_spread_levels.length; i += 1) {
    marker_1_props = assign(marker_1_props, marker_1_spread_levels[i]);
  }
  marker_1 = new Marker_default({ props: marker_1_props, $$inline: true });
  const block = {
    key: key_1,
    first: null,
    c: function create2() {
      first = empty();
      create_component(marker_1.$$.fragment);
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      mount_component(marker_1, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const marker_1_changes = dirty & /*$markers*/
      1 ? get_spread_update(marker_1_spread_levels, [get_spread_object(
        /*marker*/
        ctx[2]
      )]) : {};
      marker_1.$set(marker_1_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(marker_1.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(marker_1.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(marker_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(7:2) {#each $markers as marker (marker.id)}",
    ctx
  });
  return block;
}
function create_fragment24(ctx) {
  let defs;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ensure_array_like_dev(
    /*$markers*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*marker*/
    ctx2[2].id
  );
  validate_each_keys(ctx, each_value, get_each_context2, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key2 = get_key(child_ctx);
    each_1_lookup.set(key2, each_blocks[i] = create_each_block2(key2, child_ctx));
  }
  const block = {
    c: function create2() {
      defs = svg_element("defs");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      add_location(defs, file11, 5, 0, 123);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, defs, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(defs, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$markers*/
      1) {
        each_value = ensure_array_like_dev(
          /*$markers*/
          ctx2[0]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context2, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, defs, outro_and_destroy_block, create_each_block2, null, get_each_context2);
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local2) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(defs);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance24($$self, $$props, $$invalidate) {
  let $markers;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MarkerDefinition", slots, []);
  const { markers } = useStore();
  validate_store(markers, "markers");
  component_subscribe($$self, markers, (value) => $$invalidate(0, $markers = value));
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<MarkerDefinition> was created with unknown prop '${key2}'`);
  });
  $$self.$capture_state = () => ({ useStore, Marker: Marker_default, markers, $markers });
  return [$markers, markers];
}
var MarkerDefinition = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MarkerDefinition",
      options,
      id: create_fragment24.name
    });
  }
};
var MarkerDefinition_default = MarkerDefinition;

// node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/MarkerDefinition/Marker.svelte
var file12 = "node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/MarkerDefinition/Marker.svelte";
function create_if_block_12(ctx) {
  let polyline;
  const block = {
    c: function create2() {
      polyline = svg_element("polyline");
      attr_dev(
        polyline,
        "stroke",
        /*color*/
        ctx[6]
      );
      attr_dev(polyline, "stroke-linecap", "round");
      attr_dev(polyline, "stroke-linejoin", "round");
      attr_dev(
        polyline,
        "stroke-width",
        /*strokeWidth*/
        ctx[7]
      );
      attr_dev(
        polyline,
        "fill",
        /*color*/
        ctx[6]
      );
      attr_dev(polyline, "points", "-5,-4 0,0 -5,4 -5,-4");
      add_location(polyline, file12, 32, 4, 741);
    },
    m: function mount(target, anchor) {
      insert_dev(target, polyline, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*color*/
      64) {
        attr_dev(
          polyline,
          "stroke",
          /*color*/
          ctx2[6]
        );
      }
      if (dirty & /*strokeWidth*/
      128) {
        attr_dev(
          polyline,
          "stroke-width",
          /*strokeWidth*/
          ctx2[7]
        );
      }
      if (dirty & /*color*/
      64) {
        attr_dev(
          polyline,
          "fill",
          /*color*/
          ctx2[6]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(polyline);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(32:44) ",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let polyline;
  const block = {
    c: function create2() {
      polyline = svg_element("polyline");
      attr_dev(
        polyline,
        "stroke",
        /*color*/
        ctx[6]
      );
      attr_dev(polyline, "stroke-linecap", "round");
      attr_dev(polyline, "stroke-linejoin", "round");
      attr_dev(
        polyline,
        "stroke-width",
        /*strokeWidth*/
        ctx[7]
      );
      attr_dev(polyline, "fill", "none");
      attr_dev(polyline, "points", "-5,-4 0,0 -5,4");
      add_location(polyline, file12, 23, 4, 514);
    },
    m: function mount(target, anchor) {
      insert_dev(target, polyline, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*color*/
      64) {
        attr_dev(
          polyline,
          "stroke",
          /*color*/
          ctx2[6]
        );
      }
      if (dirty & /*strokeWidth*/
      128) {
        attr_dev(
          polyline,
          "stroke-width",
          /*strokeWidth*/
          ctx2[7]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(polyline);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(23:2) {#if type === MarkerType.Arrow}",
    ctx
  });
  return block;
}
function create_fragment25(ctx) {
  let marker;
  let marker_markerWidth_value;
  let marker_markerHeight_value;
  function select_block_type(ctx2, dirty) {
    if (
      /*type*/
      ctx2[1] === MarkerType.Arrow
    ) return create_if_block4;
    if (
      /*type*/
      ctx2[1] === MarkerType.ArrowClosed
    ) return create_if_block_12;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type && current_block_type(ctx);
  const block = {
    c: function create2() {
      marker = svg_element("marker");
      if (if_block) if_block.c();
      attr_dev(marker, "class", "svelte-flow__arrowhead");
      attr_dev(
        marker,
        "id",
        /*id*/
        ctx[0]
      );
      attr_dev(marker, "markerWidth", marker_markerWidth_value = `${/*width*/
      ctx[2]}`);
      attr_dev(marker, "markerHeight", marker_markerHeight_value = `${/*height*/
      ctx[3]}`);
      attr_dev(marker, "viewBox", "-10 -10 20 20");
      attr_dev(
        marker,
        "markerUnits",
        /*markerUnits*/
        ctx[4]
      );
      attr_dev(
        marker,
        "orient",
        /*orient*/
        ctx[5]
      );
      attr_dev(marker, "refX", "0");
      attr_dev(marker, "refY", "0");
      add_location(marker, file12, 11, 0, 295);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, marker, anchor);
      if (if_block) if_block.m(marker, null);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block) if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(marker, null);
        }
      }
      if (dirty & /*id*/
      1) {
        attr_dev(
          marker,
          "id",
          /*id*/
          ctx2[0]
        );
      }
      if (dirty & /*width*/
      4 && marker_markerWidth_value !== (marker_markerWidth_value = `${/*width*/
      ctx2[2]}`)) {
        attr_dev(marker, "markerWidth", marker_markerWidth_value);
      }
      if (dirty & /*height*/
      8 && marker_markerHeight_value !== (marker_markerHeight_value = `${/*height*/
      ctx2[3]}`)) {
        attr_dev(marker, "markerHeight", marker_markerHeight_value);
      }
      if (dirty & /*markerUnits*/
      16) {
        attr_dev(
          marker,
          "markerUnits",
          /*markerUnits*/
          ctx2[4]
        );
      }
      if (dirty & /*orient*/
      32) {
        attr_dev(
          marker,
          "orient",
          /*orient*/
          ctx2[5]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(marker);
      }
      if (if_block) {
        if_block.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance25($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Marker", slots, []);
  let { id: id2 } = $$props;
  let { type } = $$props;
  let { width = 12.5 } = $$props;
  let { height = 12.5 } = $$props;
  let { markerUnits = "strokeWidth" } = $$props;
  let { orient = "auto-start-reverse" } = $$props;
  let { color: color2 = void 0 } = $$props;
  let { strokeWidth = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (id2 === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console.warn("<Marker> was created without expected prop 'id'");
    }
    if (type === void 0 && !("type" in $$props || $$self.$$.bound[$$self.$$.props["type"]])) {
      console.warn("<Marker> was created without expected prop 'type'");
    }
  });
  const writable_props = [
    "id",
    "type",
    "width",
    "height",
    "markerUnits",
    "orient",
    "color",
    "strokeWidth"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Marker> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id2 = $$props2.id);
    if ("type" in $$props2) $$invalidate(1, type = $$props2.type);
    if ("width" in $$props2) $$invalidate(2, width = $$props2.width);
    if ("height" in $$props2) $$invalidate(3, height = $$props2.height);
    if ("markerUnits" in $$props2) $$invalidate(4, markerUnits = $$props2.markerUnits);
    if ("orient" in $$props2) $$invalidate(5, orient = $$props2.orient);
    if ("color" in $$props2) $$invalidate(6, color2 = $$props2.color);
    if ("strokeWidth" in $$props2) $$invalidate(7, strokeWidth = $$props2.strokeWidth);
  };
  $$self.$capture_state = () => ({
    MarkerType,
    id: id2,
    type,
    width,
    height,
    markerUnits,
    orient,
    color: color2,
    strokeWidth
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id2 = $$props2.id);
    if ("type" in $$props2) $$invalidate(1, type = $$props2.type);
    if ("width" in $$props2) $$invalidate(2, width = $$props2.width);
    if ("height" in $$props2) $$invalidate(3, height = $$props2.height);
    if ("markerUnits" in $$props2) $$invalidate(4, markerUnits = $$props2.markerUnits);
    if ("orient" in $$props2) $$invalidate(5, orient = $$props2.orient);
    if ("color" in $$props2) $$invalidate(6, color2 = $$props2.color);
    if ("strokeWidth" in $$props2) $$invalidate(7, strokeWidth = $$props2.strokeWidth);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [id2, type, width, height, markerUnits, orient, color2, strokeWidth];
}
var Marker = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance25, create_fragment25, safe_not_equal, {
      id: 0,
      type: 1,
      width: 2,
      height: 3,
      markerUnits: 4,
      orient: 5,
      color: 6,
      strokeWidth: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Marker",
      options,
      id: create_fragment25.name
    });
  }
  get id() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerUnits() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerUnits(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orient() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orient(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Marker_default = Marker;

// node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/EdgeRenderer.svelte
var file13 = "node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/EdgeRenderer.svelte";
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  return child_ctx;
}
function create_each_block3(key_1, ctx) {
  let first;
  let edgewrapper;
  let current;
  edgewrapper = new EdgeWrapper_default({
    props: {
      id: (
        /*edge*/
        ctx[14].id
      ),
      source: (
        /*edge*/
        ctx[14].source
      ),
      target: (
        /*edge*/
        ctx[14].target
      ),
      data: (
        /*edge*/
        ctx[14].data
      ),
      style: (
        /*edge*/
        ctx[14].style
      ),
      animated: (
        /*edge*/
        ctx[14].animated
      ),
      selected: (
        /*edge*/
        ctx[14].selected
      ),
      selectable: (
        /*edge*/
        ctx[14].selectable ?? /*$elementsSelectable*/
        ctx[1]
      ),
      deletable: (
        /*edge*/
        ctx[14].deletable
      ),
      hidden: (
        /*edge*/
        ctx[14].hidden
      ),
      label: (
        /*edge*/
        ctx[14].label
      ),
      labelStyle: (
        /*edge*/
        ctx[14].labelStyle
      ),
      markerStart: (
        /*edge*/
        ctx[14].markerStart
      ),
      markerEnd: (
        /*edge*/
        ctx[14].markerEnd
      ),
      sourceHandle: (
        /*edge*/
        ctx[14].sourceHandle
      ),
      targetHandle: (
        /*edge*/
        ctx[14].targetHandle
      ),
      sourceX: (
        /*edge*/
        ctx[14].sourceX
      ),
      sourceY: (
        /*edge*/
        ctx[14].sourceY
      ),
      targetX: (
        /*edge*/
        ctx[14].targetX
      ),
      targetY: (
        /*edge*/
        ctx[14].targetY
      ),
      sourcePosition: (
        /*edge*/
        ctx[14].sourcePosition
      ),
      targetPosition: (
        /*edge*/
        ctx[14].targetPosition
      ),
      ariaLabel: (
        /*edge*/
        ctx[14].ariaLabel
      ),
      interactionWidth: (
        /*edge*/
        ctx[14].interactionWidth
      ),
      class: (
        /*edge*/
        ctx[14].class
      ),
      type: (
        /*edge*/
        ctx[14].type || "default"
      ),
      zIndex: (
        /*edge*/
        ctx[14].zIndex
      )
    },
    $$inline: true
  });
  edgewrapper.$on(
    "edgeclick",
    /*edgeclick_handler*/
    ctx[7]
  );
  edgewrapper.$on(
    "edgecontextmenu",
    /*edgecontextmenu_handler*/
    ctx[8]
  );
  edgewrapper.$on(
    "edgemouseenter",
    /*edgemouseenter_handler*/
    ctx[9]
  );
  edgewrapper.$on(
    "edgemouseleave",
    /*edgemouseleave_handler*/
    ctx[10]
  );
  const block = {
    key: key_1,
    first: null,
    c: function create2() {
      first = empty();
      create_component(edgewrapper.$$.fragment);
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      mount_component(edgewrapper, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const edgewrapper_changes = {};
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.id = /*edge*/
      ctx[14].id;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.source = /*edge*/
      ctx[14].source;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.target = /*edge*/
      ctx[14].target;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.data = /*edge*/
      ctx[14].data;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.style = /*edge*/
      ctx[14].style;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.animated = /*edge*/
      ctx[14].animated;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.selected = /*edge*/
      ctx[14].selected;
      if (dirty & /*$visibleEdges, $elementsSelectable*/
      3) edgewrapper_changes.selectable = /*edge*/
      ctx[14].selectable ?? /*$elementsSelectable*/
      ctx[1];
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.deletable = /*edge*/
      ctx[14].deletable;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.hidden = /*edge*/
      ctx[14].hidden;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.label = /*edge*/
      ctx[14].label;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.labelStyle = /*edge*/
      ctx[14].labelStyle;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.markerStart = /*edge*/
      ctx[14].markerStart;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.markerEnd = /*edge*/
      ctx[14].markerEnd;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.sourceHandle = /*edge*/
      ctx[14].sourceHandle;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.targetHandle = /*edge*/
      ctx[14].targetHandle;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.sourceX = /*edge*/
      ctx[14].sourceX;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.sourceY = /*edge*/
      ctx[14].sourceY;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.targetX = /*edge*/
      ctx[14].targetX;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.targetY = /*edge*/
      ctx[14].targetY;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.sourcePosition = /*edge*/
      ctx[14].sourcePosition;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.targetPosition = /*edge*/
      ctx[14].targetPosition;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.ariaLabel = /*edge*/
      ctx[14].ariaLabel;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.interactionWidth = /*edge*/
      ctx[14].interactionWidth;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.class = /*edge*/
      ctx[14].class;
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.type = /*edge*/
      ctx[14].type || "default";
      if (dirty & /*$visibleEdges*/
      1) edgewrapper_changes.zIndex = /*edge*/
      ctx[14].zIndex;
      edgewrapper.$set(edgewrapper_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(edgewrapper.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(edgewrapper.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(edgewrapper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(19:2) {#each $visibleEdges as edge (edge.id)}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let callonmount;
  let current;
  callonmount = new CallOnMount_default({
    props: {
      onMount: (
        /*func*/
        ctx[11]
      ),
      onDestroy: (
        /*func_1*/
        ctx[12]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(callonmount.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(callonmount, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const callonmount_changes = {};
      if (dirty & /*$edgesInitialized*/
      4) callonmount_changes.onMount = /*func*/
      ctx2[11];
      if (dirty & /*$edgesInitialized*/
      4) callonmount_changes.onDestroy = /*func_1*/
      ctx2[12];
      callonmount.$set(callonmount_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(callonmount.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(callonmount.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(callonmount, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(55:2) {#if $visibleEdges.length > 0}",
    ctx
  });
  return block;
}
function create_fragment26(ctx) {
  let div;
  let svg;
  let markerdefinition;
  let t02;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t12;
  let current;
  markerdefinition = new MarkerDefinition_default({ $$inline: true });
  let each_value = ensure_array_like_dev(
    /*$visibleEdges*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*edge*/
    ctx2[14].id
  );
  validate_each_keys(ctx, each_value, get_each_context3, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context3(ctx, each_value, i);
    let key2 = get_key(child_ctx);
    each_1_lookup.set(key2, each_blocks[i] = create_each_block3(key2, child_ctx));
  }
  let if_block = (
    /*$visibleEdges*/
    ctx[0].length > 0 && create_if_block5(ctx)
  );
  const block = {
    c: function create2() {
      div = element("div");
      svg = svg_element("svg");
      create_component(markerdefinition.$$.fragment);
      t02 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t12 = space();
      if (if_block) if_block.c();
      attr_dev(svg, "class", "svelte-flow__marker");
      add_location(svg, file13, 14, 2, 534);
      attr_dev(div, "class", "svelte-flow__edges");
      add_location(div, file13, 13, 0, 499);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, svg);
      mount_component(markerdefinition, svg, null);
      append_dev(div, t02);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append_dev(div, t12);
      if (if_block) if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$visibleEdges, $elementsSelectable*/
      3) {
        each_value = ensure_array_like_dev(
          /*$visibleEdges*/
          ctx2[0]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context3, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block3, t12, get_each_context3);
        check_outros();
      }
      if (
        /*$visibleEdges*/
        ctx2[0].length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$visibleEdges*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(markerdefinition.$$.fragment, local2);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block);
      current = true;
    },
    o: function outro(local2) {
      transition_out(markerdefinition.$$.fragment, local2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(markerdefinition);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let $visibleEdges;
  let $elementsSelectable;
  let $edgesInitialized;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EdgeRenderer", slots, []);
  let { defaultEdgeOptions } = $$props;
  const { visibleEdges, edgesInitialized, edges: { setDefaultOptions }, elementsSelectable } = useStore();
  validate_store(visibleEdges, "visibleEdges");
  component_subscribe($$self, visibleEdges, (value) => $$invalidate(0, $visibleEdges = value));
  validate_store(edgesInitialized, "edgesInitialized");
  component_subscribe($$self, edgesInitialized, (value) => $$invalidate(2, $edgesInitialized = value));
  validate_store(elementsSelectable, "elementsSelectable");
  component_subscribe($$self, elementsSelectable, (value) => $$invalidate(1, $elementsSelectable = value));
  onMount(() => {
    if (defaultEdgeOptions) setDefaultOptions(defaultEdgeOptions);
  });
  $$self.$$.on_mount.push(function() {
    if (defaultEdgeOptions === void 0 && !("defaultEdgeOptions" in $$props || $$self.$$.bound[$$self.$$.props["defaultEdgeOptions"]])) {
      console.warn("<EdgeRenderer> was created without expected prop 'defaultEdgeOptions'");
    }
  });
  const writable_props = ["defaultEdgeOptions"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<EdgeRenderer> was created with unknown prop '${key2}'`);
  });
  function edgeclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function edgecontextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function edgemouseenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function edgemouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  const func2 = () => {
    set_store_value(edgesInitialized, $edgesInitialized = true, $edgesInitialized);
  };
  const func_1 = () => {
    set_store_value(edgesInitialized, $edgesInitialized = false, $edgesInitialized);
  };
  $$self.$$set = ($$props2) => {
    if ("defaultEdgeOptions" in $$props2) $$invalidate(6, defaultEdgeOptions = $$props2.defaultEdgeOptions);
  };
  $$self.$capture_state = () => ({
    onMount,
    EdgeWrapper: EdgeWrapper_default,
    CallOnMount: CallOnMount_default,
    MarkerDefinition: MarkerDefinition_default,
    useStore,
    defaultEdgeOptions,
    visibleEdges,
    edgesInitialized,
    setDefaultOptions,
    elementsSelectable,
    $visibleEdges,
    $elementsSelectable,
    $edgesInitialized
  });
  $$self.$inject_state = ($$props2) => {
    if ("defaultEdgeOptions" in $$props2) $$invalidate(6, defaultEdgeOptions = $$props2.defaultEdgeOptions);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    $visibleEdges,
    $elementsSelectable,
    $edgesInitialized,
    visibleEdges,
    edgesInitialized,
    elementsSelectable,
    defaultEdgeOptions,
    edgeclick_handler,
    edgecontextmenu_handler,
    edgemouseenter_handler,
    edgemouseleave_handler,
    func2,
    func_1
  ];
}
var EdgeRenderer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, { defaultEdgeOptions: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EdgeRenderer",
      options,
      id: create_fragment26.name
    });
  }
  get defaultEdgeOptions() {
    throw new Error("<EdgeRenderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultEdgeOptions(value) {
    throw new Error("<EdgeRenderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var EdgeRenderer_default = EdgeRenderer;

// node_modules/@xyflow/svelte/dist/lib/components/Selection/Selection.svelte
var file14 = "node_modules/@xyflow/svelte/dist/lib/components/Selection/Selection.svelte";
function add_css5(target) {
  append_styles(target, "svelte-1iugwpu", ".svelte-flow__selection.svelte-1iugwpu{position:absolute;top:0;left:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VsZWN0aW9uLnN2ZWx0ZSIsInNvdXJjZXMiOlsiU2VsZWN0aW9uLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PmV4cG9ydCBsZXQgeCA9IDA7XG5leHBvcnQgbGV0IHkgPSAwO1xuZXhwb3J0IGxldCB3aWR0aCA9IDA7XG5leHBvcnQgbGV0IGhlaWdodCA9IDA7XG5leHBvcnQgbGV0IGlzVmlzaWJsZSA9IHRydWU7XG48L3NjcmlwdD5cblxueyNpZiBpc1Zpc2libGV9XG4gIDxkaXZcbiAgICBjbGFzcz1cInN2ZWx0ZS1mbG93X19zZWxlY3Rpb25cIlxuICAgIHN0eWxlOndpZHRoPXt0eXBlb2Ygd2lkdGggPT09ICdzdHJpbmcnID8gd2lkdGggOiBgJHt3aWR0aH1weGB9XG4gICAgc3R5bGU6aGVpZ2h0PXt0eXBlb2YgaGVpZ2h0ID09PSAnc3RyaW5nJyA/IGhlaWdodCA6IGAke2hlaWdodH1weGB9XG4gICAgc3R5bGU6dHJhbnNmb3JtPXtgdHJhbnNsYXRlKCR7eH1weCwgJHt5fXB4KWB9XG4gIC8+XG57L2lmfVxuXG48c3R5bGU+XG4gIC5zdmVsdGUtZmxvd19fc2VsZWN0aW9uIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gIH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBaUJFLHNDQUF3QixDQUN0QixRQUFRLENBQUUsUUFBUSxDQUNsQixHQUFHLENBQUUsQ0FBQyxDQUNOLElBQUksQ0FBRSxDQUNSIn0= */");
}
function create_if_block6(ctx) {
  let div;
  const block = {
    c: function create2() {
      div = element("div");
      attr_dev(div, "class", "svelte-flow__selection svelte-1iugwpu");
      set_style(div, "width", typeof /*width*/
      ctx[2] === "string" ? (
        /*width*/
        ctx[2]
      ) : `${/*width*/
      ctx[2]}px`);
      set_style(div, "height", typeof /*height*/
      ctx[3] === "string" ? (
        /*height*/
        ctx[3]
      ) : `${/*height*/
      ctx[3]}px`);
      set_style(div, "transform", `translate(${/*x*/
      ctx[0]}px, ${/*y*/
      ctx[1]}px)`);
      add_location(div, file14, 8, 2, 147);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*width*/
      4) {
        set_style(div, "width", typeof /*width*/
        ctx2[2] === "string" ? (
          /*width*/
          ctx2[2]
        ) : `${/*width*/
        ctx2[2]}px`);
      }
      if (dirty & /*height*/
      8) {
        set_style(div, "height", typeof /*height*/
        ctx2[3] === "string" ? (
          /*height*/
          ctx2[3]
        ) : `${/*height*/
        ctx2[3]}px`);
      }
      if (dirty & /*x, y*/
      3) {
        set_style(div, "transform", `translate(${/*x*/
        ctx2[0]}px, ${/*y*/
        ctx2[1]}px)`);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(8:0) {#if isVisible}",
    ctx
  });
  return block;
}
function create_fragment27(ctx) {
  let if_block_anchor;
  let if_block = (
    /*isVisible*/
    ctx[4] && create_if_block6(ctx)
  );
  const block = {
    c: function create2() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isVisible*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block6(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance27($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Selection", slots, []);
  let { x = 0 } = $$props;
  let { y = 0 } = $$props;
  let { width = 0 } = $$props;
  let { height = 0 } = $$props;
  let { isVisible = true } = $$props;
  const writable_props = ["x", "y", "width", "height", "isVisible"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Selection> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x" in $$props2) $$invalidate(0, x = $$props2.x);
    if ("y" in $$props2) $$invalidate(1, y = $$props2.y);
    if ("width" in $$props2) $$invalidate(2, width = $$props2.width);
    if ("height" in $$props2) $$invalidate(3, height = $$props2.height);
    if ("isVisible" in $$props2) $$invalidate(4, isVisible = $$props2.isVisible);
  };
  $$self.$capture_state = () => ({ x, y, width, height, isVisible });
  $$self.$inject_state = ($$props2) => {
    if ("x" in $$props2) $$invalidate(0, x = $$props2.x);
    if ("y" in $$props2) $$invalidate(1, y = $$props2.y);
    if ("width" in $$props2) $$invalidate(2, width = $$props2.width);
    if ("height" in $$props2) $$invalidate(3, height = $$props2.height);
    if ("isVisible" in $$props2) $$invalidate(4, isVisible = $$props2.isVisible);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [x, y, width, height, isVisible];
}
var Selection3 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance27,
      create_fragment27,
      safe_not_equal,
      {
        x: 0,
        y: 1,
        width: 2,
        height: 3,
        isVisible: 4
      },
      add_css5
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Selection",
      options,
      id: create_fragment27.name
    });
  }
  get x() {
    throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isVisible() {
    throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isVisible(value) {
    throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Selection_default = Selection3;

// node_modules/@xyflow/svelte/dist/lib/components/UserSelection/UserSelection.svelte
function create_fragment28(ctx) {
  var _a, _b, _c, _d;
  let selection2;
  let current;
  selection2 = new Selection_default({
    props: {
      isVisible: !!/*$selectionRect*/
      (ctx[0] && /*$selectionRectMode*/
      ctx[1] === "user"),
      width: (
        /*$selectionRect*/
        (_a = ctx[0]) == null ? void 0 : _a.width
      ),
      height: (
        /*$selectionRect*/
        (_b = ctx[0]) == null ? void 0 : _b.height
      ),
      x: (
        /*$selectionRect*/
        (_c = ctx[0]) == null ? void 0 : _c.x
      ),
      y: (
        /*$selectionRect*/
        (_d = ctx[0]) == null ? void 0 : _d.y
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(selection2.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(selection2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      var _a2, _b2, _c2, _d2;
      const selection_changes = {};
      if (dirty & /*$selectionRect, $selectionRectMode*/
      3) selection_changes.isVisible = !!/*$selectionRect*/
      (ctx2[0] && /*$selectionRectMode*/
      ctx2[1] === "user");
      if (dirty & /*$selectionRect*/
      1) selection_changes.width = /*$selectionRect*/
      (_a2 = ctx2[0]) == null ? void 0 : _a2.width;
      if (dirty & /*$selectionRect*/
      1) selection_changes.height = /*$selectionRect*/
      (_b2 = ctx2[0]) == null ? void 0 : _b2.height;
      if (dirty & /*$selectionRect*/
      1) selection_changes.x = /*$selectionRect*/
      (_c2 = ctx2[0]) == null ? void 0 : _c2.x;
      if (dirty & /*$selectionRect*/
      1) selection_changes.y = /*$selectionRect*/
      (_d2 = ctx2[0]) == null ? void 0 : _d2.y;
      selection2.$set(selection_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(selection2.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(selection2.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(selection2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  let $selectionRect;
  let $selectionRectMode;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UserSelection", slots, []);
  const { selectionRect, selectionRectMode } = useStore();
  validate_store(selectionRect, "selectionRect");
  component_subscribe($$self, selectionRect, (value) => $$invalidate(0, $selectionRect = value));
  validate_store(selectionRectMode, "selectionRectMode");
  component_subscribe($$self, selectionRectMode, (value) => $$invalidate(1, $selectionRectMode = value));
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<UserSelection> was created with unknown prop '${key2}'`);
  });
  $$self.$capture_state = () => ({
    useStore,
    Selection: Selection_default,
    selectionRect,
    selectionRectMode,
    $selectionRect,
    $selectionRectMode
  });
  return [$selectionRect, $selectionRectMode, selectionRect, selectionRectMode];
}
var UserSelection = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UserSelection",
      options,
      id: create_fragment28.name
    });
  }
};
var UserSelection_default = UserSelection;

// node_modules/@xyflow/svelte/dist/lib/components/NodeSelection/NodeSelection.svelte
var file15 = "node_modules/@xyflow/svelte/dist/lib/components/NodeSelection/NodeSelection.svelte";
function add_css6(target) {
  append_styles(target, "svelte-5pxri", ".selection-wrapper.svelte-5pxri{position:absolute;top:0;left:0;z-index:7;pointer-events:all}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTm9kZVNlbGVjdGlvbi5zdmVsdGUiLCJzb3VyY2VzIjpbIk5vZGVTZWxlY3Rpb24uc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+aW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnc3ZlbHRlJztcbmltcG9ydCB7IGdldEludGVybmFsTm9kZXNCb3VuZHMsIGlzTnVtZXJpYyB9IGZyb20gJ0B4eWZsb3cvc3lzdGVtJztcbmltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnLi4vLi4vc3RvcmUnO1xuaW1wb3J0IHsgU2VsZWN0aW9uIH0gZnJvbSAnLi4vU2VsZWN0aW9uJztcbmltcG9ydCBkcmFnIGZyb20gJy4uLy4uL2FjdGlvbnMvZHJhZyc7XG5jb25zdCBzdG9yZSA9IHVzZVN0b3JlKCk7XG5jb25zdCB7IHNlbGVjdGlvblJlY3RNb2RlLCBub2Rlcywgbm9kZUxvb2t1cCB9ID0gc3RvcmU7XG5jb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xubGV0IGJvdW5kcyA9IG51bGw7XG4kOiBpZiAoJHNlbGVjdGlvblJlY3RNb2RlID09PSAnbm9kZXMnKSB7XG4gICAgYm91bmRzID0gZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcygkbm9kZUxvb2t1cCwgeyBmaWx0ZXI6IChub2RlKSA9PiAhIW5vZGUuc2VsZWN0ZWQgfSk7XG4gICAgJG5vZGVzO1xufVxuZnVuY3Rpb24gb25Db250ZXh0TWVudShldmVudCkge1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSAkbm9kZXMuZmlsdGVyKChuKSA9PiBuLnNlbGVjdGVkKTtcbiAgICBkaXNwYXRjaCgnc2VsZWN0aW9uY29udGV4dG1lbnUnLCB7IG5vZGVzOiBzZWxlY3RlZE5vZGVzLCBldmVudCB9KTtcbn1cbmZ1bmN0aW9uIG9uQ2xpY2soZXZlbnQpIHtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gJG5vZGVzLmZpbHRlcigobikgPT4gbi5zZWxlY3RlZCk7XG4gICAgZGlzcGF0Y2goJ3NlbGVjdGlvbmNsaWNrJywgeyBub2Rlczogc2VsZWN0ZWROb2RlcywgZXZlbnQgfSk7XG59XG48L3NjcmlwdD5cblxueyNpZiAkc2VsZWN0aW9uUmVjdE1vZGUgPT09ICdub2RlcycgJiYgYm91bmRzICYmIGlzTnVtZXJpYyhib3VuZHMueCkgJiYgaXNOdW1lcmljKGJvdW5kcy55KX1cbiAgPGRpdlxuICAgIGNsYXNzPVwic2VsZWN0aW9uLXdyYXBwZXIgbm9wYW5cIlxuICAgIHN0eWxlPVwid2lkdGg6IHtib3VuZHMud2lkdGh9cHg7IGhlaWdodDoge2JvdW5kcy5oZWlnaHR9cHg7IHRyYW5zZm9ybTogdHJhbnNsYXRlKHtib3VuZHMueH1weCwge2JvdW5kcy55fXB4KVwiXG4gICAgdXNlOmRyYWc9e3tcbiAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgIHN0b3JlLFxuICAgICAgb25EcmFnOiAoZXZlbnQsIF8sIF9fLCBub2RlcykgPT4ge1xuICAgICAgICBkaXNwYXRjaCgnbm9kZWRyYWcnLCB7IGV2ZW50LCB0YXJnZXROb2RlOiBudWxsLCBub2RlcyB9KTtcbiAgICAgIH0sXG4gICAgICBvbkRyYWdTdGFydDogKGV2ZW50LCBfLCBfXywgbm9kZXMpID0+IHtcbiAgICAgICAgZGlzcGF0Y2goJ25vZGVkcmFnc3RhcnQnLCB7IGV2ZW50LCB0YXJnZXROb2RlOiBudWxsLCBub2RlcyB9KTtcbiAgICAgIH0sXG4gICAgICBvbkRyYWdTdG9wOiAoZXZlbnQsIF8sIF9fLCBub2RlcykgPT4ge1xuICAgICAgICBkaXNwYXRjaCgnbm9kZWRyYWdzdG9wJywgeyBldmVudCwgdGFyZ2V0Tm9kZTogbnVsbCwgbm9kZXMgfSk7XG4gICAgICB9XG4gICAgfX1cbiAgICBvbjpjb250ZXh0bWVudT17b25Db250ZXh0TWVudX1cbiAgICBvbjpjbGljaz17b25DbGlja31cbiAgICByb2xlPVwiYnV0dG9uXCJcbiAgICB0YWJpbmRleD1cIi0xXCJcbiAgICBvbjprZXl1cD17KCkgPT4ge319XG4gID5cbiAgICA8U2VsZWN0aW9uIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiB4PXswfSB5PXswfSAvPlxuICA8L2Rpdj5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgLnNlbGVjdGlvbi13cmFwcGVyIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgei1pbmRleDogNztcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xuICB9XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW1ERSwrQkFBbUIsQ0FDakIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLENBQUMsQ0FDTixJQUFJLENBQUUsQ0FBQyxDQUNQLE9BQU8sQ0FBRSxDQUFDLENBQ1YsY0FBYyxDQUFFLEdBQ2xCIn0= */");
}
function create_if_block7(ctx) {
  let div;
  let selection2;
  let drag_action;
  let current;
  let mounted;
  let dispose;
  selection2 = new Selection_default({
    props: {
      width: "100%",
      height: "100%",
      x: 0,
      y: 0
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      div = element("div");
      create_component(selection2.$$.fragment);
      attr_dev(div, "class", "selection-wrapper nopan svelte-5pxri");
      set_style(
        div,
        "width",
        /*bounds*/
        ctx[1].width + "px"
      );
      set_style(
        div,
        "height",
        /*bounds*/
        ctx[1].height + "px"
      );
      set_style(div, "transform", "translate(" + /*bounds*/
      ctx[1].x + "px, " + /*bounds*/
      ctx[1].y + "px)");
      attr_dev(div, "role", "button");
      attr_dev(div, "tabindex", "-1");
      add_location(div, file15, 24, 2, 956);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(selection2, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(drag_action = drag.call(null, div, {
            disabled: false,
            store: (
              /*store*/
              ctx[2]
            ),
            onDrag: (
              /*drag_function*/
              ctx[11]
            ),
            onDragStart: (
              /*drag_function_1*/
              ctx[12]
            ),
            onDragStop: (
              /*drag_function_2*/
              ctx[13]
            )
          })),
          listen_dev(
            div,
            "contextmenu",
            /*onContextMenu*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "click",
            /*onClick*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(div, "keyup", keyup_handler2, false, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*bounds*/
      2) {
        set_style(
          div,
          "width",
          /*bounds*/
          ctx2[1].width + "px"
        );
      }
      if (!current || dirty & /*bounds*/
      2) {
        set_style(
          div,
          "height",
          /*bounds*/
          ctx2[1].height + "px"
        );
      }
      if (!current || dirty & /*bounds*/
      2) {
        set_style(div, "transform", "translate(" + /*bounds*/
        ctx2[1].x + "px, " + /*bounds*/
        ctx2[1].y + "px)");
      }
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(selection2.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(selection2.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(selection2);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(24:0) {#if $selectionRectMode === 'nodes' && bounds && isNumeric(bounds.x) && isNumeric(bounds.y)}",
    ctx
  });
  return block;
}
function create_fragment29(ctx) {
  let show_if = (
    /*$selectionRectMode*/
    ctx[0] === "nodes" && /*bounds*/
    ctx[1] && isNumeric(
      /*bounds*/
      ctx[1].x
    ) && isNumeric(
      /*bounds*/
      ctx[1].y
    )
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block7(ctx);
  const block = {
    c: function create2() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$selectionRectMode, bounds*/
      3) show_if = /*$selectionRectMode*/
      ctx2[0] === "nodes" && /*bounds*/
      ctx2[1] && isNumeric(
        /*bounds*/
        ctx2[1].x
      ) && isNumeric(
        /*bounds*/
        ctx2[1].y
      );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$selectionRectMode, bounds*/
          3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var keyup_handler2 = () => {
};
function instance29($$self, $$props, $$invalidate) {
  let $nodes;
  let $nodeLookup;
  let $selectionRectMode;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NodeSelection", slots, []);
  const store = useStore();
  const { selectionRectMode, nodes, nodeLookup } = store;
  validate_store(selectionRectMode, "selectionRectMode");
  component_subscribe($$self, selectionRectMode, (value) => $$invalidate(0, $selectionRectMode = value));
  validate_store(nodes, "nodes");
  component_subscribe($$self, nodes, (value) => $$invalidate(9, $nodes = value));
  validate_store(nodeLookup, "nodeLookup");
  component_subscribe($$self, nodeLookup, (value) => $$invalidate(10, $nodeLookup = value));
  const dispatch2 = createEventDispatcher();
  let bounds = null;
  function onContextMenu(event) {
    const selectedNodes = $nodes.filter((n) => n.selected);
    dispatch2("selectioncontextmenu", { nodes: selectedNodes, event });
  }
  function onClick(event) {
    const selectedNodes = $nodes.filter((n) => n.selected);
    dispatch2("selectionclick", { nodes: selectedNodes, event });
  }
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<NodeSelection> was created with unknown prop '${key2}'`);
  });
  const drag_function = (event, _, __, nodes2) => {
    dispatch2("nodedrag", { event, targetNode: null, nodes: nodes2 });
  };
  const drag_function_1 = (event, _, __, nodes2) => {
    dispatch2("nodedragstart", { event, targetNode: null, nodes: nodes2 });
  };
  const drag_function_2 = (event, _, __, nodes2) => {
    dispatch2("nodedragstop", { event, targetNode: null, nodes: nodes2 });
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    getInternalNodesBounds,
    isNumeric,
    useStore,
    Selection: Selection_default,
    drag,
    store,
    selectionRectMode,
    nodes,
    nodeLookup,
    dispatch: dispatch2,
    bounds,
    onContextMenu,
    onClick,
    $nodes,
    $nodeLookup,
    $selectionRectMode
  });
  $$self.$inject_state = ($$props2) => {
    if ("bounds" in $$props2) $$invalidate(1, bounds = $$props2.bounds);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$selectionRectMode, $nodeLookup, $nodes*/
    1537) {
      $: if ($selectionRectMode === "nodes") {
        $$invalidate(1, bounds = getInternalNodesBounds($nodeLookup, { filter: (node) => !!node.selected }));
        $nodes;
      }
    }
  };
  return [
    $selectionRectMode,
    bounds,
    store,
    selectionRectMode,
    nodes,
    nodeLookup,
    dispatch2,
    onContextMenu,
    onClick,
    $nodes,
    $nodeLookup,
    drag_function,
    drag_function_1,
    drag_function_2
  ];
}
var NodeSelection = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, {}, add_css6);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NodeSelection",
      options,
      id: create_fragment29.name
    });
  }
};
var NodeSelection_default = NodeSelection;

// node_modules/@svelte-put/shortcut/src/shortcut.js
function shortcut(node, param) {
  let { enabled = true, trigger, type = "keydown" } = param;
  function handler(event) {
    const normalizedTriggers = Array.isArray(trigger) ? trigger : [trigger];
    const modifiedMap = {
      alt: event.altKey,
      ctrl: event.ctrlKey,
      shift: event.shiftKey,
      meta: event.metaKey
    };
    for (const trigger2 of normalizedTriggers) {
      const mergedTrigger = {
        modifier: [],
        preventDefault: false,
        enabled: true,
        ...trigger2
      };
      const { modifier, key: key2, callback, preventDefault, enabled: triggerEnabled } = mergedTrigger;
      if (triggerEnabled) {
        if (modifier.length) {
          const modifierDefs = (Array.isArray(modifier) ? modifier : [modifier]).map(
            (def) => typeof def === "string" ? [def] : def
          );
          const modified = modifierDefs.some(
            (def) => def.every((modifier2) => modifiedMap[modifier2])
          );
          if (!modified) continue;
        }
        if (event.key === key2) {
          if (preventDefault) event.preventDefault();
          const detail = {
            node,
            trigger: mergedTrigger,
            originalEvent: event
          };
          node.dispatchEvent(new CustomEvent("shortcut", { detail }));
          callback == null ? void 0 : callback(detail);
        }
      }
    }
  }
  if (enabled) node.addEventListener(type, handler);
  return {
    update: (update) => {
      const { enabled: newEnabled = true, type: newType = "keydown" } = update;
      if (enabled && (!newEnabled || type !== newType)) {
        node.removeEventListener(type, handler);
      } else if (!enabled && newEnabled) {
        node.addEventListener(newType, handler);
      }
      enabled = newEnabled;
      type = newType;
      trigger = update.trigger;
    },
    destroy: () => {
      node.removeEventListener(type, handler);
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/components/KeyHandler/KeyHandler.svelte
function create_fragment30(ctx) {
  let shortcut_action;
  let shortcut_action_1;
  let shortcut_action_2;
  let shortcut_action_3;
  let shortcut_action_4;
  let shortcut_action_5;
  let shortcut_action_6;
  let shortcut_action_7;
  let shortcut_action_8;
  let shortcut_action_9;
  let mounted;
  let dispose;
  const block = {
    c: noop,
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (!mounted) {
        dispose = [
          action_destroyer(shortcut_action = shortcut.call(null, window, {
            trigger: getShortcutTrigger(
              /*selectionKey*/
              ctx[0],
              /*shortcut_function*/
              ctx[11]
            ),
            type: "keydown"
          })),
          action_destroyer(shortcut_action_1 = shortcut.call(null, window, {
            trigger: getShortcutTrigger(
              /*selectionKey*/
              ctx[0],
              /*shortcut_function_1*/
              ctx[12]
            ),
            type: "keyup"
          })),
          action_destroyer(shortcut_action_2 = shortcut.call(null, window, {
            trigger: getShortcutTrigger(
              /*multiSelectionKey*/
              ctx[1],
              /*shortcut_function_2*/
              ctx[13]
            ),
            type: "keydown"
          })),
          action_destroyer(shortcut_action_3 = shortcut.call(null, window, {
            trigger: getShortcutTrigger(
              /*multiSelectionKey*/
              ctx[1],
              /*shortcut_function_3*/
              ctx[14]
            ),
            type: "keyup"
          })),
          action_destroyer(shortcut_action_4 = shortcut.call(null, window, {
            trigger: getShortcutTrigger(
              /*deleteKey*/
              ctx[2],
              /*shortcut_function_4*/
              ctx[15]
            ),
            type: "keydown"
          })),
          action_destroyer(shortcut_action_5 = shortcut.call(null, window, {
            trigger: getShortcutTrigger(
              /*deleteKey*/
              ctx[2],
              /*shortcut_function_5*/
              ctx[16]
            ),
            type: "keyup"
          })),
          action_destroyer(shortcut_action_6 = shortcut.call(null, window, {
            trigger: getShortcutTrigger(
              /*panActivationKey*/
              ctx[3],
              /*shortcut_function_6*/
              ctx[17]
            ),
            type: "keydown"
          })),
          action_destroyer(shortcut_action_7 = shortcut.call(null, window, {
            trigger: getShortcutTrigger(
              /*panActivationKey*/
              ctx[3],
              /*shortcut_function_7*/
              ctx[18]
            ),
            type: "keyup"
          })),
          action_destroyer(shortcut_action_8 = shortcut.call(null, window, {
            trigger: getShortcutTrigger(
              /*zoomActivationKey*/
              ctx[4],
              /*shortcut_function_8*/
              ctx[19]
            ),
            type: "keydown"
          })),
          action_destroyer(shortcut_action_9 = shortcut.call(null, window, {
            trigger: getShortcutTrigger(
              /*zoomActivationKey*/
              ctx[4],
              /*shortcut_function_9*/
              ctx[20]
            ),
            type: "keyup"
          })),
          listen_dev(
            window,
            "blur",
            /*resetKeysAndSelection*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "contextmenu",
            /*resetKeysAndSelection*/
            ctx[10],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (shortcut_action && is_function(shortcut_action.update) && dirty & /*selectionKey*/
      1) shortcut_action.update.call(null, {
        trigger: getShortcutTrigger(
          /*selectionKey*/
          ctx2[0],
          /*shortcut_function*/
          ctx2[11]
        ),
        type: "keydown"
      });
      if (shortcut_action_1 && is_function(shortcut_action_1.update) && dirty & /*selectionKey*/
      1) shortcut_action_1.update.call(null, {
        trigger: getShortcutTrigger(
          /*selectionKey*/
          ctx2[0],
          /*shortcut_function_1*/
          ctx2[12]
        ),
        type: "keyup"
      });
      if (shortcut_action_2 && is_function(shortcut_action_2.update) && dirty & /*multiSelectionKey*/
      2) shortcut_action_2.update.call(null, {
        trigger: getShortcutTrigger(
          /*multiSelectionKey*/
          ctx2[1],
          /*shortcut_function_2*/
          ctx2[13]
        ),
        type: "keydown"
      });
      if (shortcut_action_3 && is_function(shortcut_action_3.update) && dirty & /*multiSelectionKey*/
      2) shortcut_action_3.update.call(null, {
        trigger: getShortcutTrigger(
          /*multiSelectionKey*/
          ctx2[1],
          /*shortcut_function_3*/
          ctx2[14]
        ),
        type: "keyup"
      });
      if (shortcut_action_4 && is_function(shortcut_action_4.update) && dirty & /*deleteKey*/
      4) shortcut_action_4.update.call(null, {
        trigger: getShortcutTrigger(
          /*deleteKey*/
          ctx2[2],
          /*shortcut_function_4*/
          ctx2[15]
        ),
        type: "keydown"
      });
      if (shortcut_action_5 && is_function(shortcut_action_5.update) && dirty & /*deleteKey*/
      4) shortcut_action_5.update.call(null, {
        trigger: getShortcutTrigger(
          /*deleteKey*/
          ctx2[2],
          /*shortcut_function_5*/
          ctx2[16]
        ),
        type: "keyup"
      });
      if (shortcut_action_6 && is_function(shortcut_action_6.update) && dirty & /*panActivationKey*/
      8) shortcut_action_6.update.call(null, {
        trigger: getShortcutTrigger(
          /*panActivationKey*/
          ctx2[3],
          /*shortcut_function_6*/
          ctx2[17]
        ),
        type: "keydown"
      });
      if (shortcut_action_7 && is_function(shortcut_action_7.update) && dirty & /*panActivationKey*/
      8) shortcut_action_7.update.call(null, {
        trigger: getShortcutTrigger(
          /*panActivationKey*/
          ctx2[3],
          /*shortcut_function_7*/
          ctx2[18]
        ),
        type: "keyup"
      });
      if (shortcut_action_8 && is_function(shortcut_action_8.update) && dirty & /*zoomActivationKey*/
      16) shortcut_action_8.update.call(null, {
        trigger: getShortcutTrigger(
          /*zoomActivationKey*/
          ctx2[4],
          /*shortcut_function_8*/
          ctx2[19]
        ),
        type: "keydown"
      });
      if (shortcut_action_9 && is_function(shortcut_action_9.update) && dirty & /*zoomActivationKey*/
      16) shortcut_action_9.update.call(null, {
        trigger: getShortcutTrigger(
          /*zoomActivationKey*/
          ctx2[4],
          /*shortcut_function_9*/
          ctx2[20]
        ),
        type: "keyup"
      });
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function isKeyObject(key2) {
  return key2 !== null && typeof key2 === "object";
}
function getModifier(key2) {
  return isKeyObject(key2) ? key2.modifier || [] : [];
}
function getKeyString(key2) {
  if (key2 === null || key2 === void 0) {
    return "";
  }
  return isKeyObject(key2) ? key2.key : key2;
}
function getShortcutTrigger(key2, callback) {
  const keys = Array.isArray(key2) ? key2 : [key2];
  return keys.map((_key) => {
    const keyString = getKeyString(_key);
    return {
      key: keyString,
      modifier: getModifier(_key),
      enabled: keyString !== null,
      callback
    };
  });
}
function instance30($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("KeyHandler", slots, []);
  let { selectionKey = "Shift" } = $$props;
  let { multiSelectionKey = isMacOs() ? "Meta" : "Control" } = $$props;
  let { deleteKey = "Backspace" } = $$props;
  let { panActivationKey = " " } = $$props;
  let { zoomActivationKey = isMacOs() ? "Meta" : "Control" } = $$props;
  const { selectionKeyPressed, multiselectionKeyPressed, deleteKeyPressed, panActivationKeyPressed, zoomActivationKeyPressed, selectionRect } = useStore();
  function resetKeysAndSelection() {
    selectionRect.set(null);
    selectionKeyPressed.set(false);
    multiselectionKeyPressed.set(false);
    deleteKeyPressed.set(false);
    panActivationKeyPressed.set(false);
    zoomActivationKeyPressed.set(false);
  }
  const writable_props = [
    "selectionKey",
    "multiSelectionKey",
    "deleteKey",
    "panActivationKey",
    "zoomActivationKey"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<KeyHandler> was created with unknown prop '${key2}'`);
  });
  const shortcut_function = () => selectionKeyPressed.set(true);
  const shortcut_function_1 = () => selectionKeyPressed.set(false);
  const shortcut_function_2 = () => multiselectionKeyPressed.set(true);
  const shortcut_function_3 = () => multiselectionKeyPressed.set(false);
  const shortcut_function_4 = (detail) => {
    const isModifierKey = detail.originalEvent.ctrlKey || detail.originalEvent.metaKey || detail.originalEvent.shiftKey;
    if (!isModifierKey && !isInputDOMNode(detail.originalEvent)) {
      deleteKeyPressed.set(true);
    }
  };
  const shortcut_function_5 = () => deleteKeyPressed.set(false);
  const shortcut_function_6 = () => panActivationKeyPressed.set(true);
  const shortcut_function_7 = () => panActivationKeyPressed.set(false);
  const shortcut_function_8 = () => zoomActivationKeyPressed.set(true);
  const shortcut_function_9 = () => zoomActivationKeyPressed.set(false);
  $$self.$$set = ($$props2) => {
    if ("selectionKey" in $$props2) $$invalidate(0, selectionKey = $$props2.selectionKey);
    if ("multiSelectionKey" in $$props2) $$invalidate(1, multiSelectionKey = $$props2.multiSelectionKey);
    if ("deleteKey" in $$props2) $$invalidate(2, deleteKey = $$props2.deleteKey);
    if ("panActivationKey" in $$props2) $$invalidate(3, panActivationKey = $$props2.panActivationKey);
    if ("zoomActivationKey" in $$props2) $$invalidate(4, zoomActivationKey = $$props2.zoomActivationKey);
  };
  $$self.$capture_state = () => ({
    shortcut,
    isInputDOMNode,
    isMacOs,
    useStore,
    selectionKey,
    multiSelectionKey,
    deleteKey,
    panActivationKey,
    zoomActivationKey,
    selectionKeyPressed,
    multiselectionKeyPressed,
    deleteKeyPressed,
    panActivationKeyPressed,
    zoomActivationKeyPressed,
    selectionRect,
    isKeyObject,
    getModifier,
    getKeyString,
    getShortcutTrigger,
    resetKeysAndSelection
  });
  $$self.$inject_state = ($$props2) => {
    if ("selectionKey" in $$props2) $$invalidate(0, selectionKey = $$props2.selectionKey);
    if ("multiSelectionKey" in $$props2) $$invalidate(1, multiSelectionKey = $$props2.multiSelectionKey);
    if ("deleteKey" in $$props2) $$invalidate(2, deleteKey = $$props2.deleteKey);
    if ("panActivationKey" in $$props2) $$invalidate(3, panActivationKey = $$props2.panActivationKey);
    if ("zoomActivationKey" in $$props2) $$invalidate(4, zoomActivationKey = $$props2.zoomActivationKey);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    selectionKey,
    multiSelectionKey,
    deleteKey,
    panActivationKey,
    zoomActivationKey,
    selectionKeyPressed,
    multiselectionKeyPressed,
    deleteKeyPressed,
    panActivationKeyPressed,
    zoomActivationKeyPressed,
    resetKeysAndSelection,
    shortcut_function,
    shortcut_function_1,
    shortcut_function_2,
    shortcut_function_3,
    shortcut_function_4,
    shortcut_function_5,
    shortcut_function_6,
    shortcut_function_7,
    shortcut_function_8,
    shortcut_function_9
  ];
}
var KeyHandler = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, {
      selectionKey: 0,
      multiSelectionKey: 1,
      deleteKey: 2,
      panActivationKey: 3,
      zoomActivationKey: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "KeyHandler",
      options,
      id: create_fragment30.name
    });
  }
  get selectionKey() {
    throw new Error("<KeyHandler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectionKey(value) {
    throw new Error("<KeyHandler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiSelectionKey() {
    throw new Error("<KeyHandler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiSelectionKey(value) {
    throw new Error("<KeyHandler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deleteKey() {
    throw new Error("<KeyHandler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set deleteKey(value) {
    throw new Error("<KeyHandler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panActivationKey() {
    throw new Error("<KeyHandler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panActivationKey(value) {
    throw new Error("<KeyHandler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomActivationKey() {
    throw new Error("<KeyHandler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomActivationKey(value) {
    throw new Error("<KeyHandler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var KeyHandler_default = KeyHandler;

// node_modules/@xyflow/svelte/dist/lib/components/ConnectionLine/ConnectionLine.svelte
var file16 = "node_modules/@xyflow/svelte/dist/lib/components/ConnectionLine/ConnectionLine.svelte";
var get_connectionLine_slot_changes = (dirty) => ({});
var get_connectionLine_slot_context = (ctx) => ({});
function create_if_block8(ctx) {
  let svg;
  let g;
  let g_class_value;
  let current;
  const connectionLine_slot_template = (
    /*#slots*/
    ctx[13].connectionLine
  );
  const connectionLine_slot = create_slot(
    connectionLine_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_connectionLine_slot_context
  );
  let if_block = !/*isCustomComponent*/
  ctx[2] && create_if_block_13(ctx);
  const block = {
    c: function create2() {
      svg = svg_element("svg");
      g = svg_element("g");
      if (connectionLine_slot) connectionLine_slot.c();
      if (if_block) if_block.c();
      attr_dev(g, "class", g_class_value = cc([
        "svelte-flow__connection",
        getConnectionStatus(
          /*$connection*/
          ctx[3].isValid
        )
      ]));
      add_location(g, file16, 39, 4, 1352);
      attr_dev(
        svg,
        "width",
        /*$width*/
        ctx[5]
      );
      attr_dev(
        svg,
        "height",
        /*$height*/
        ctx[6]
      );
      attr_dev(svg, "class", "svelte-flow__connectionline");
      attr_dev(
        svg,
        "style",
        /*containerStyle*/
        ctx[0]
      );
      add_location(svg, file16, 38, 2, 1251);
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, g);
      if (connectionLine_slot) {
        connectionLine_slot.m(g, null);
      }
      if (if_block) if_block.m(g, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (connectionLine_slot) {
        if (connectionLine_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            connectionLine_slot,
            connectionLine_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              connectionLine_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_connectionLine_slot_changes
            ),
            get_connectionLine_slot_context
          );
        }
      }
      if (!/*isCustomComponent*/
      ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_13(ctx2);
          if_block.c();
          if_block.m(g, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & /*$connection*/
      8 && g_class_value !== (g_class_value = cc([
        "svelte-flow__connection",
        getConnectionStatus(
          /*$connection*/
          ctx2[3].isValid
        )
      ]))) {
        attr_dev(g, "class", g_class_value);
      }
      if (!current || dirty & /*$width*/
      32) {
        attr_dev(
          svg,
          "width",
          /*$width*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*$height*/
      64) {
        attr_dev(
          svg,
          "height",
          /*$height*/
          ctx2[6]
        );
      }
      if (!current || dirty & /*containerStyle*/
      1) {
        attr_dev(
          svg,
          "style",
          /*containerStyle*/
          ctx2[0]
        );
      }
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(connectionLine_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(connectionLine_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (connectionLine_slot) connectionLine_slot.d(detaching);
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(38:0) {#if $connection.inProgress}",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let path_1;
  const block = {
    c: function create2() {
      path_1 = svg_element("path");
      attr_dev(
        path_1,
        "d",
        /*path*/
        ctx[4]
      );
      attr_dev(
        path_1,
        "style",
        /*style*/
        ctx[1]
      );
      attr_dev(path_1, "fill", "none");
      attr_dev(path_1, "class", "svelte-flow__connection-path");
      add_location(path_1, file16, 43, 8, 1589);
    },
    m: function mount(target, anchor) {
      insert_dev(target, path_1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*path*/
      16) {
        attr_dev(
          path_1,
          "d",
          /*path*/
          ctx2[4]
        );
      }
      if (dirty & /*style*/
      2) {
        attr_dev(
          path_1,
          "style",
          /*style*/
          ctx2[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(43:6) {#if !isCustomComponent}",
    ctx
  });
  return block;
}
function create_fragment31(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$connection*/
    ctx[3].inProgress && create_if_block8(ctx)
  );
  const block = {
    c: function create2() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$connection*/
        ctx2[3].inProgress
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$connection*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block8(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance31($$self, $$props, $$invalidate) {
  let $connectionLineType;
  let $connection;
  let $width;
  let $height;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ConnectionLine", slots, ["connectionLine"]);
  let { containerStyle = "" } = $$props;
  let { style = "" } = $$props;
  let { isCustomComponent = false } = $$props;
  const { width, height, connection, connectionLineType } = useStore();
  validate_store(width, "width");
  component_subscribe($$self, width, (value) => $$invalidate(5, $width = value));
  validate_store(height, "height");
  component_subscribe($$self, height, (value) => $$invalidate(6, $height = value));
  validate_store(connection, "connection");
  component_subscribe($$self, connection, (value) => $$invalidate(3, $connection = value));
  validate_store(connectionLineType, "connectionLineType");
  component_subscribe($$self, connectionLineType, (value) => $$invalidate(11, $connectionLineType = value));
  let path = null;
  const writable_props = ["containerStyle", "style", "isCustomComponent"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<ConnectionLine> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("containerStyle" in $$props2) $$invalidate(0, containerStyle = $$props2.containerStyle);
    if ("style" in $$props2) $$invalidate(1, style = $$props2.style);
    if ("isCustomComponent" in $$props2) $$invalidate(2, isCustomComponent = $$props2.isCustomComponent);
    if ("$$scope" in $$props2) $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    cc,
    useStore,
    ConnectionLineType,
    getBezierPath,
    getConnectionStatus,
    getSmoothStepPath,
    getStraightPath,
    containerStyle,
    style,
    isCustomComponent,
    width,
    height,
    connection,
    connectionLineType,
    path,
    $connectionLineType,
    $connection,
    $width,
    $height
  });
  $$self.$inject_state = ($$props2) => {
    if ("containerStyle" in $$props2) $$invalidate(0, containerStyle = $$props2.containerStyle);
    if ("style" in $$props2) $$invalidate(1, style = $$props2.style);
    if ("isCustomComponent" in $$props2) $$invalidate(2, isCustomComponent = $$props2.isCustomComponent);
    if ("path" in $$props2) $$invalidate(4, path = $$props2.path);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$connection, isCustomComponent, $connectionLineType*/
    2060) {
      $: if ($connection.inProgress && !isCustomComponent) {
        const { from, to, fromPosition, toPosition } = $connection;
        const pathParams = {
          sourceX: from.x,
          sourceY: from.y,
          sourcePosition: fromPosition,
          targetX: to.x,
          targetY: to.y,
          targetPosition: toPosition
        };
        switch ($connectionLineType) {
          case ConnectionLineType.Bezier:
            $$invalidate(4, [path] = getBezierPath(pathParams), path);
            break;
          case ConnectionLineType.Step:
            $$invalidate(4, [path] = getSmoothStepPath({ ...pathParams, borderRadius: 0 }), path);
            break;
          case ConnectionLineType.SmoothStep:
            $$invalidate(4, [path] = getSmoothStepPath(pathParams), path);
            break;
          default:
            $$invalidate(4, [path] = getStraightPath(pathParams), path);
        }
      }
    }
  };
  return [
    containerStyle,
    style,
    isCustomComponent,
    $connection,
    path,
    $width,
    $height,
    width,
    height,
    connection,
    connectionLineType,
    $connectionLineType,
    $$scope,
    slots
  ];
}
var ConnectionLine = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment31, safe_not_equal, {
      containerStyle: 0,
      style: 1,
      isCustomComponent: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ConnectionLine",
      options,
      id: create_fragment31.name
    });
  }
  get containerStyle() {
    throw new Error("<ConnectionLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerStyle(value) {
    throw new Error("<ConnectionLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<ConnectionLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<ConnectionLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustomComponent() {
    throw new Error("<ConnectionLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustomComponent(value) {
    throw new Error("<ConnectionLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ConnectionLine_default = ConnectionLine;

// node_modules/@xyflow/svelte/dist/lib/container/Panel/Panel.svelte
var file17 = "node_modules/@xyflow/svelte/dist/lib/container/Panel/Panel.svelte";
function create_fragment32(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let div_levels = [
    {
      class: div_class_value = cc([
        "svelte-flow__panel",
        /*className*/
        ctx[1],
        .../*positionClasses*/
        ctx[2]
      ])
    },
    { style: (
      /*style*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[5]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create2() {
      div = element("div");
      if (default_slot) default_slot.c();
      set_attributes(div, div_data);
      set_style(
        div,
        "pointer-events",
        /*$selectionRectMode*/
        ctx[3] ? "none" : ""
      );
      add_location(div, file17, 10, 0, 298);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*className, positionClasses*/
        6 && div_class_value !== (div_class_value = cc([
          "svelte-flow__panel",
          /*className*/
          ctx2[1],
          .../*positionClasses*/
          ctx2[2]
        ]))) && { class: div_class_value },
        (!current || dirty & /*style*/
        1) && { style: (
          /*style*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]));
      set_style(
        div,
        "pointer-events",
        /*$selectionRectMode*/
        ctx2[3] ? "none" : ""
      );
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(default_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(default_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self, $$props, $$invalidate) {
  let positionClasses;
  const omit_props_names = ["position", "style", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectionRectMode;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Panel", slots, ["default"]);
  let { position = "top-right" } = $$props;
  let { style = void 0 } = $$props;
  let { class: className = void 0 } = $$props;
  const { selectionRectMode } = useStore();
  validate_store(selectionRectMode, "selectionRectMode");
  component_subscribe($$self, selectionRectMode, (value) => $$invalidate(3, $selectionRectMode = value));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("position" in $$new_props) $$invalidate(6, position = $$new_props.position);
    if ("style" in $$new_props) $$invalidate(0, style = $$new_props.style);
    if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    cc,
    useStore,
    position,
    style,
    className,
    selectionRectMode,
    positionClasses,
    $selectionRectMode
  });
  $$self.$inject_state = ($$new_props) => {
    if ("position" in $$props) $$invalidate(6, position = $$new_props.position);
    if ("style" in $$props) $$invalidate(0, style = $$new_props.style);
    if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
    if ("positionClasses" in $$props) $$invalidate(2, positionClasses = $$new_props.positionClasses);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*position*/
    64) {
      $: $$invalidate(2, positionClasses = `${position}`.split("-"));
    }
  };
  return [
    style,
    className,
    positionClasses,
    $selectionRectMode,
    selectionRectMode,
    $$restProps,
    position,
    $$scope,
    slots
  ];
}
var Panel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, { position: 6, style: 0, class: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Panel",
      options,
      id: create_fragment32.name
    });
  }
  get position() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Panel_default = Panel;

// node_modules/@xyflow/svelte/dist/lib/components/Attribution/Attribution.svelte
var file18 = "node_modules/@xyflow/svelte/dist/lib/components/Attribution/Attribution.svelte";
function create_if_block9(ctx) {
  let panel;
  let current;
  panel = new Panel_default({
    props: {
      position: (
        /*position*/
        ctx[1]
      ),
      class: "svelte-flow__attribution",
      "data-message": "Feel free to remove the attribution or check out how you could support us: https://svelteflow.dev/support-us",
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(panel.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(panel, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const panel_changes = {};
      if (dirty & /*position*/
      2) panel_changes.position = /*position*/
      ctx2[1];
      if (dirty & /*$$scope*/
      4) {
        panel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel.$set(panel_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(panel.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(panel.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(panel, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(6:0) {#if !proOptions?.hideAttribution}",
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let a;
  const block = {
    c: function create2() {
      a = element("a");
      a.textContent = "Svelte Flow";
      attr_dev(a, "href", "https://svelteflow.dev");
      attr_dev(a, "target", "_blank");
      attr_dev(a, "rel", "noopener noreferrer");
      attr_dev(a, "aria-label", "Svelte Flow attribution");
      add_location(a, file18, 11, 4, 371);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: '(7:2) <Panel     {position}     class=\\"svelte-flow__attribution\\"     data-message=\\"Feel free to remove the attribution or check out how you could support us: https://svelteflow.dev/support-us\\"   >',
    ctx
  });
  return block;
}
function create_fragment33(ctx) {
  var _a;
  let if_block_anchor;
  let current;
  let if_block = !/*proOptions*/
  ((_a = ctx[0]) == null ? void 0 : _a.hideAttribution) && create_if_block9(ctx);
  const block = {
    c: function create2() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      var _a2;
      if (!/*proOptions*/
      ((_a2 = ctx2[0]) == null ? void 0 : _a2.hideAttribution)) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*proOptions*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block9(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance33($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Attribution", slots, []);
  let { proOptions = void 0 } = $$props;
  let { position = "bottom-right" } = $$props;
  const writable_props = ["proOptions", "position"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Attribution> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("proOptions" in $$props2) $$invalidate(0, proOptions = $$props2.proOptions);
    if ("position" in $$props2) $$invalidate(1, position = $$props2.position);
  };
  $$self.$capture_state = () => ({ Panel: Panel_default, proOptions, position });
  $$self.$inject_state = ($$props2) => {
    if ("proOptions" in $$props2) $$invalidate(0, proOptions = $$props2.proOptions);
    if ("position" in $$props2) $$invalidate(1, position = $$props2.position);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [proOptions, position];
}
var Attribution = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment33, safe_not_equal, { proOptions: 0, position: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Attribution",
      options,
      id: create_fragment33.name
    });
  }
  get proOptions() {
    throw new Error("<Attribution>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set proOptions(value) {
    throw new Error("<Attribution>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Attribution>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Attribution>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Attribution_default = Attribution;

// node_modules/@xyflow/svelte/dist/lib/container/SvelteFlow/utils.js
function updateStore(store, { nodeTypes, edgeTypes, minZoom, maxZoom, translateExtent, paneClickDistance }) {
  if (nodeTypes !== void 0) {
    store.setNodeTypes(nodeTypes);
  }
  if (edgeTypes !== void 0) {
    store.setEdgeTypes(edgeTypes);
  }
  if (minZoom !== void 0) {
    store.setMinZoom(minZoom);
  }
  if (maxZoom !== void 0) {
    store.setMaxZoom(maxZoom);
  }
  if (translateExtent !== void 0) {
    store.setTranslateExtent(translateExtent);
  }
  if (paneClickDistance !== void 0) {
    store.setPaneClickDistance(paneClickDistance);
  }
}
var getKeys = (obj) => Object.keys(obj);
function updateStoreByKeys(store, keys) {
  getKeys(keys).forEach((prop) => {
    const update = keys[prop];
    if (update !== void 0) {
      store[prop].set(update);
    }
  });
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useColorModeClass.js
function getMediaQuery() {
  if (typeof window === "undefined" || !window.matchMedia) {
    return null;
  }
  return window.matchMedia("(prefers-color-scheme: dark)");
}
function useColorModeClass(colorMode = "light") {
  const colorModeClass = readable("light", (set3) => {
    if (colorMode !== "system") {
      set3(colorMode);
      return;
    }
    const mediaQuery = getMediaQuery();
    const updateColorModeClass = () => set3((mediaQuery == null ? void 0 : mediaQuery.matches) ? "dark" : "light");
    set3((mediaQuery == null ? void 0 : mediaQuery.matches) ? "dark" : "light");
    mediaQuery == null ? void 0 : mediaQuery.addEventListener("change", updateColorModeClass);
    return () => {
      mediaQuery == null ? void 0 : mediaQuery.removeEventListener("change", updateColorModeClass);
    };
  });
  return colorModeClass;
}

// node_modules/@xyflow/svelte/dist/lib/container/SvelteFlow/SvelteFlow.svelte
var file19 = "node_modules/@xyflow/svelte/dist/lib/container/SvelteFlow/SvelteFlow.svelte";
function add_css7(target) {
  append_styles(target, "svelte-12wlba6", ".svelte-flow.svelte-12wlba6{width:100%;height:100%;overflow:hidden;position:relative;z-index:0;background-color:var(--background-color, var(--background-color-default))}:root{--background-color-default:#fff;--background-pattern-color-default:#ddd;--minimap-mask-color-default:rgb(240, 240, 240, 0.6);--minimap-mask-stroke-color-default:none;--minimap-mask-stroke-width-default:1;--controls-button-background-color-default:#fefefe;--controls-button-background-color-hover-default:#f4f4f4;--controls-button-color-default:inherit;--controls-button-color-hover-default:inherit;--controls-button-border-color-default:#eee}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3ZlbHRlRmxvdy5zdmVsdGUiLCJzb3VyY2VzIjpbIlN2ZWx0ZUZsb3cuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+aW1wb3J0IHsgb25Nb3VudCwgaGFzQ29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5pbXBvcnQgeyBnZXQgfSBmcm9tICdzdmVsdGUvc3RvcmUnO1xuaW1wb3J0IGNjIGZyb20gJ2NsYXNzY2F0JztcbmltcG9ydCB7IENvbm5lY3Rpb25Nb2RlLCBQYW5PblNjcm9sbE1vZGUgfSBmcm9tICdAeHlmbG93L3N5c3RlbSc7XG5pbXBvcnQgeyBab29tIH0gZnJvbSAnLi4vWm9vbSc7XG5pbXBvcnQgeyBQYW5lIH0gZnJvbSAnLi4vUGFuZSc7XG5pbXBvcnQgeyBWaWV3cG9ydCBhcyBWaWV3cG9ydENvbXBvbmVudCB9IGZyb20gJy4uL1ZpZXdwb3J0JztcbmltcG9ydCB7IE5vZGVSZW5kZXJlciB9IGZyb20gJy4uL05vZGVSZW5kZXJlcic7XG5pbXBvcnQgeyBFZGdlUmVuZGVyZXIgfSBmcm9tICcuLi9FZGdlUmVuZGVyZXInO1xuaW1wb3J0IHsgVXNlclNlbGVjdGlvbiB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvVXNlclNlbGVjdGlvbic7XG5pbXBvcnQgeyBOb2RlU2VsZWN0aW9uIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9Ob2RlU2VsZWN0aW9uJztcbmltcG9ydCB7IEtleUhhbmRsZXIgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL0tleUhhbmRsZXInO1xuaW1wb3J0IHsgQ29ubmVjdGlvbkxpbmUgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL0Nvbm5lY3Rpb25MaW5lJztcbmltcG9ydCB7IEF0dHJpYnV0aW9uIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9BdHRyaWJ1dGlvbic7XG5pbXBvcnQgeyBrZXksIHVzZVN0b3JlLCBjcmVhdGVTdG9yZUNvbnRleHQgfSBmcm9tICcuLi8uLi9zdG9yZSc7XG5pbXBvcnQgeyB1cGRhdGVTdG9yZSwgdXBkYXRlU3RvcmVCeUtleXMgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IHVzZUNvbG9yTW9kZUNsYXNzIH0gZnJvbSAnLi4vLi4vaG9va3MvdXNlQ29sb3JNb2RlQ2xhc3MnO1xuZXhwb3J0IGxldCBpZCA9ICcxJztcbmV4cG9ydCBsZXQgbm9kZXM7XG5leHBvcnQgbGV0IGVkZ2VzO1xuZXhwb3J0IGxldCBmaXRWaWV3ID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBmaXRWaWV3T3B0aW9ucyA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgbWluWm9vbSA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgbWF4Wm9vbSA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgaW5pdGlhbFZpZXdwb3J0ID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCB2aWV3cG9ydCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgbm9kZVR5cGVzID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBlZGdlVHlwZXMgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IHNlbGVjdGlvbktleSA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgc2VsZWN0aW9uTW9kZSA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgcGFuQWN0aXZhdGlvbktleSA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgbXVsdGlTZWxlY3Rpb25LZXkgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IHpvb21BY3RpdmF0aW9uS2V5ID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBub2Rlc0RyYWdnYWJsZSA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgbm9kZXNDb25uZWN0YWJsZSA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgbm9kZURyYWdUaHJlc2hvbGQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IGVsZW1lbnRzU2VsZWN0YWJsZSA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgc25hcEdyaWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IGRlbGV0ZUtleSA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgY29ubmVjdGlvblJhZGl1cyA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgY29ubmVjdGlvbkxpbmVUeXBlID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBjb25uZWN0aW9uTW9kZSA9IENvbm5lY3Rpb25Nb2RlLlN0cmljdDtcbmV4cG9ydCBsZXQgY29ubmVjdGlvbkxpbmVTdHlsZSA9ICcnO1xuZXhwb3J0IGxldCBjb25uZWN0aW9uTGluZUNvbnRhaW5lclN0eWxlID0gJyc7XG5leHBvcnQgbGV0IG9uTW92ZVN0YXJ0ID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBvbk1vdmUgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IG9uTW92ZUVuZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgaXNWYWxpZENvbm5lY3Rpb24gPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IHRyYW5zbGF0ZUV4dGVudCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgb25seVJlbmRlclZpc2libGVFbGVtZW50cyA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgcGFuT25TY3JvbGxNb2RlID0gUGFuT25TY3JvbGxNb2RlLkZyZWU7XG5leHBvcnQgbGV0IHByZXZlbnRTY3JvbGxpbmcgPSB0cnVlO1xuZXhwb3J0IGxldCB6b29tT25TY3JvbGwgPSB0cnVlO1xuZXhwb3J0IGxldCB6b29tT25Eb3VibGVDbGljayA9IHRydWU7XG5leHBvcnQgbGV0IHpvb21PblBpbmNoID0gdHJ1ZTtcbmV4cG9ydCBsZXQgcGFuT25TY3JvbGwgPSBmYWxzZTtcbmV4cG9ydCBsZXQgcGFuT25EcmFnID0gdHJ1ZTtcbmV4cG9ydCBsZXQgc2VsZWN0aW9uT25EcmFnID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBhdXRvUGFuT25Db25uZWN0ID0gdHJ1ZTtcbmV4cG9ydCBsZXQgYXV0b1Bhbk9uTm9kZURyYWcgPSB0cnVlO1xuZXhwb3J0IGxldCBvbmVycm9yID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBvbmRlbGV0ZSA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgb25lZGdlY3JlYXRlID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBhdHRyaWJ1dGlvblBvc2l0aW9uID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBwcm9PcHRpb25zID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBkZWZhdWx0RWRnZU9wdGlvbnMgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IHdpZHRoID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBoZWlnaHQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IGNvbG9yTW9kZSA9ICdsaWdodCc7XG5leHBvcnQgbGV0IG9uY29ubmVjdCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgb25jb25uZWN0c3RhcnQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IG9uY29ubmVjdGVuZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgb25iZWZvcmVkZWxldGUgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IG9uaW5pdCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgbm9kZU9yaWdpbiA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgcGFuZUNsaWNrRGlzdGFuY2UgPSAwO1xuZXhwb3J0IGxldCBub2RlQ2xpY2tEaXN0YW5jZSA9IDA7XG5leHBvcnQgbGV0IGRlZmF1bHRNYXJrZXJDb2xvciA9ICcjYjFiMWI3JztcbmV4cG9ydCBsZXQgc3R5bGUgPSB1bmRlZmluZWQ7XG5sZXQgY2xhc3NOYW1lID0gdW5kZWZpbmVkO1xuZXhwb3J0IHsgY2xhc3NOYW1lIGFzIGNsYXNzIH07XG5sZXQgZG9tTm9kZTtcbmxldCBjbGllbnRXaWR0aDtcbmxldCBjbGllbnRIZWlnaHQ7XG5jb25zdCBpbml0Vmlld3BvcnQgPSAkdmlld3BvcnQgfHwgaW5pdGlhbFZpZXdwb3J0O1xuY29uc3Qgc3RvcmUgPSBoYXNDb250ZXh0KGtleSlcbiAgICA/IHVzZVN0b3JlKClcbiAgICA6IGNyZWF0ZVN0b3JlQ29udGV4dCh7XG4gICAgICAgIG5vZGVzOiBnZXQobm9kZXMpLFxuICAgICAgICBlZGdlczogZ2V0KGVkZ2VzKSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgZml0VmlldyxcbiAgICAgICAgbm9kZU9yaWdpblxuICAgIH0pO1xub25Nb3VudCgoKSA9PiB7XG4gICAgc3RvcmUud2lkdGguc2V0KGNsaWVudFdpZHRoKTtcbiAgICBzdG9yZS5oZWlnaHQuc2V0KGNsaWVudEhlaWdodCk7XG4gICAgc3RvcmUuZG9tTm9kZS5zZXQoZG9tTm9kZSk7XG4gICAgc3RvcmUuc3luY05vZGVTdG9yZXMobm9kZXMpO1xuICAgIHN0b3JlLnN5bmNFZGdlU3RvcmVzKGVkZ2VzKTtcbiAgICBzdG9yZS5zeW5jVmlld3BvcnQodmlld3BvcnQpO1xuICAgIGlmIChmaXRWaWV3ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3RvcmUuZml0Vmlld09uSW5pdC5zZXQoZml0Vmlldyk7XG4gICAgfVxuICAgIGlmIChmaXRWaWV3T3B0aW9ucykge1xuICAgICAgICBzdG9yZS5maXRWaWV3T3B0aW9ucy5zZXQoZml0Vmlld09wdGlvbnMpO1xuICAgIH1cbiAgICB1cGRhdGVTdG9yZShzdG9yZSwge1xuICAgICAgICBub2RlVHlwZXMsXG4gICAgICAgIGVkZ2VUeXBlcyxcbiAgICAgICAgbWluWm9vbSxcbiAgICAgICAgbWF4Wm9vbSxcbiAgICAgICAgdHJhbnNsYXRlRXh0ZW50LFxuICAgICAgICBwYW5lQ2xpY2tEaXN0YW5jZVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHN0b3JlLnJlc2V0KCk7XG4gICAgfTtcbn0pO1xuLy8gVXBkYXRlIHdpZHRoICYgaGVpZ2h0IG9uIHJlc2l6ZVxuJDoge1xuICAgIGlmIChjbGllbnRXaWR0aCAhPT0gdW5kZWZpbmVkICYmIGNsaWVudEhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0b3JlLndpZHRoLnNldChjbGllbnRXaWR0aCk7XG4gICAgICAgIHN0b3JlLmhlaWdodC5zZXQoY2xpZW50SGVpZ2h0KTtcbiAgICB9XG59XG4vLyBDYWxsIG9uaW5pdCBvbmNlIHdoZW4gZmxvdyBpcyBpbnRpYWxpemVkXG5jb25zdCB7IGluaXRpYWxpemVkIH0gPSBzdG9yZTtcbmxldCBvbkluaXRDYWxsZWQgPSBmYWxzZTtcbiQ6IHtcbiAgICBpZiAoIW9uSW5pdENhbGxlZCAmJiAkaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgb25pbml0Py4oKTtcbiAgICAgICAgb25Jbml0Q2FsbGVkID0gdHJ1ZTtcbiAgICB9XG59XG4vLyB0aGlzIHVwZGF0ZXMgdGhlIHN0b3JlIGZvciBzaW1wbGUgY2hhbmdlc1xuLy8gd2hlcmUgdGhlIHByb3AgbmFtZXMgZXF1YWxzIHRoZSBzdG9yZSBuYW1lXG4kOiB7XG4gICAgY29uc3QgdXBkYXRhYmxlUHJvcHMgPSB7XG4gICAgICAgIGZsb3dJZDogaWQsXG4gICAgICAgIGNvbm5lY3Rpb25MaW5lVHlwZSxcbiAgICAgICAgY29ubmVjdGlvblJhZGl1cyxcbiAgICAgICAgc2VsZWN0aW9uTW9kZSxcbiAgICAgICAgc25hcEdyaWQsXG4gICAgICAgIGRlZmF1bHRNYXJrZXJDb2xvcixcbiAgICAgICAgbm9kZXNEcmFnZ2FibGUsXG4gICAgICAgIG5vZGVzQ29ubmVjdGFibGUsXG4gICAgICAgIGVsZW1lbnRzU2VsZWN0YWJsZSxcbiAgICAgICAgb25seVJlbmRlclZpc2libGVFbGVtZW50cyxcbiAgICAgICAgaXNWYWxpZENvbm5lY3Rpb24sXG4gICAgICAgIGF1dG9QYW5PbkNvbm5lY3QsXG4gICAgICAgIGF1dG9QYW5Pbk5vZGVEcmFnLFxuICAgICAgICBvbmVycm9yLFxuICAgICAgICBvbmRlbGV0ZSxcbiAgICAgICAgb25lZGdlY3JlYXRlLFxuICAgICAgICBjb25uZWN0aW9uTW9kZSxcbiAgICAgICAgbm9kZURyYWdUaHJlc2hvbGQsXG4gICAgICAgIG9uY29ubmVjdCxcbiAgICAgICAgb25jb25uZWN0c3RhcnQsXG4gICAgICAgIG9uY29ubmVjdGVuZCxcbiAgICAgICAgb25iZWZvcmVkZWxldGUsXG4gICAgICAgIG5vZGVPcmlnaW5cbiAgICB9O1xuICAgIHVwZGF0ZVN0b3JlQnlLZXlzKHN0b3JlLCB1cGRhdGFibGVQcm9wcyk7XG59XG4kOiB1cGRhdGVTdG9yZShzdG9yZSwge1xuICAgIG5vZGVUeXBlcyxcbiAgICBlZGdlVHlwZXMsXG4gICAgbWluWm9vbSxcbiAgICBtYXhab29tLFxuICAgIHRyYW5zbGF0ZUV4dGVudCxcbiAgICBwYW5lQ2xpY2tEaXN0YW5jZVxufSk7XG4kOiBjb2xvck1vZGVDbGFzcyA9IHVzZUNvbG9yTW9kZUNsYXNzKGNvbG9yTW9kZSk7XG48L3NjcmlwdD5cblxuPGRpdlxuICBiaW5kOnRoaXM9e2RvbU5vZGV9XG4gIGJpbmQ6Y2xpZW50V2lkdGhcbiAgYmluZDpjbGllbnRIZWlnaHRcbiAge3N0eWxlfVxuICBjbGFzcz17Y2MoWydzdmVsdGUtZmxvdycsIGNsYXNzTmFtZSwgJGNvbG9yTW9kZUNsYXNzXSl9XG4gIGRhdGEtdGVzdGlkPVwic3ZlbHRlLWZsb3dfX3dyYXBwZXJcIlxuICBvbjpkcmFnb3ZlclxuICBvbjpkcm9wXG4gIHsuLi4kJHJlc3RQcm9wc31cbiAgcm9sZT1cImFwcGxpY2F0aW9uXCJcbj5cbiAgPEtleUhhbmRsZXJcbiAgICB7c2VsZWN0aW9uS2V5fVxuICAgIHtkZWxldGVLZXl9XG4gICAge3BhbkFjdGl2YXRpb25LZXl9XG4gICAge211bHRpU2VsZWN0aW9uS2V5fVxuICAgIHt6b29tQWN0aXZhdGlvbktleX1cbiAgLz5cbiAgPFpvb21cbiAgICBpbml0aWFsVmlld3BvcnQ9e2luaXRWaWV3cG9ydH1cbiAgICB7b25Nb3ZlU3RhcnR9XG4gICAge29uTW92ZX1cbiAgICB7b25Nb3ZlRW5kfVxuICAgIHBhbk9uU2Nyb2xsTW9kZT17cGFuT25TY3JvbGxNb2RlID09PSB1bmRlZmluZWQgPyBQYW5PblNjcm9sbE1vZGUuRnJlZSA6IHBhbk9uU2Nyb2xsTW9kZX1cbiAgICBwcmV2ZW50U2Nyb2xsaW5nPXtwcmV2ZW50U2Nyb2xsaW5nID09PSB1bmRlZmluZWQgPyB0cnVlIDogcHJldmVudFNjcm9sbGluZ31cbiAgICB6b29tT25TY3JvbGw9e3pvb21PblNjcm9sbCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHpvb21PblNjcm9sbH1cbiAgICB6b29tT25Eb3VibGVDbGljaz17em9vbU9uRG91YmxlQ2xpY2sgPT09IHVuZGVmaW5lZCA/IHRydWUgOiB6b29tT25Eb3VibGVDbGlja31cbiAgICB6b29tT25QaW5jaD17em9vbU9uUGluY2ggPT09IHVuZGVmaW5lZCA/IHRydWUgOiB6b29tT25QaW5jaH1cbiAgICBwYW5PblNjcm9sbD17cGFuT25TY3JvbGwgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogcGFuT25TY3JvbGx9XG4gICAgcGFuT25EcmFnPXtwYW5PbkRyYWcgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBwYW5PbkRyYWd9XG4gICAgcGFuZUNsaWNrRGlzdGFuY2U9e3BhbmVDbGlja0Rpc3RhbmNlID09PSB1bmRlZmluZWQgPyAwIDogcGFuZUNsaWNrRGlzdGFuY2V9XG4gID5cbiAgICA8UGFuZVxuICAgICAgb246cGFuZWNsaWNrXG4gICAgICBvbjpwYW5lY29udGV4dG1lbnVcbiAgICAgIHBhbk9uRHJhZz17cGFuT25EcmFnID09PSB1bmRlZmluZWQgPyB0cnVlIDogcGFuT25EcmFnfVxuICAgICAge3NlbGVjdGlvbk9uRHJhZ31cbiAgICA+XG4gICAgICA8Vmlld3BvcnRDb21wb25lbnQ+XG4gICAgICAgIDxFZGdlUmVuZGVyZXJcbiAgICAgICAgICBvbjplZGdlY2xpY2tcbiAgICAgICAgICBvbjplZGdlY29udGV4dG1lbnVcbiAgICAgICAgICBvbjplZGdlbW91c2VlbnRlclxuICAgICAgICAgIG9uOmVkZ2Vtb3VzZWxlYXZlXG4gICAgICAgICAge2RlZmF1bHRFZGdlT3B0aW9uc31cbiAgICAgICAgLz5cbiAgICAgICAgPENvbm5lY3Rpb25MaW5lXG4gICAgICAgICAgY29udGFpbmVyU3R5bGU9e2Nvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGV9XG4gICAgICAgICAgc3R5bGU9e2Nvbm5lY3Rpb25MaW5lU3R5bGV9XG4gICAgICAgICAgaXNDdXN0b21Db21wb25lbnQ9eyQkc2xvdHMuY29ubmVjdGlvbkxpbmV9XG4gICAgICAgID5cbiAgICAgICAgICA8c2xvdCBuYW1lPVwiY29ubmVjdGlvbkxpbmVcIiBzbG90PVwiY29ubmVjdGlvbkxpbmVcIiAvPlxuICAgICAgICA8L0Nvbm5lY3Rpb25MaW5lPlxuICAgICAgICA8ZGl2IGNsYXNzPVwic3ZlbHRlLWZsb3dfX2VkZ2VsYWJlbC1yZW5kZXJlclwiIC8+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzdmVsdGUtZmxvd19fdmlld3BvcnQtcG9ydGFsXCIgLz5cbiAgICAgICAgPE5vZGVSZW5kZXJlclxuICAgICAgICAgIHtub2RlQ2xpY2tEaXN0YW5jZX1cbiAgICAgICAgICBvbjpub2RlY2xpY2tcbiAgICAgICAgICBvbjpub2RlbW91c2VlbnRlclxuICAgICAgICAgIG9uOm5vZGVtb3VzZW1vdmVcbiAgICAgICAgICBvbjpub2RlbW91c2VsZWF2ZVxuICAgICAgICAgIG9uOm5vZGVkcmFnc3RhcnRcbiAgICAgICAgICBvbjpub2RlZHJhZ1xuICAgICAgICAgIG9uOm5vZGVkcmFnc3RvcFxuICAgICAgICAgIG9uOm5vZGVjb250ZXh0bWVudVxuICAgICAgICAvPlxuICAgICAgICA8Tm9kZVNlbGVjdGlvblxuICAgICAgICAgIG9uOnNlbGVjdGlvbmNsaWNrXG4gICAgICAgICAgb246c2VsZWN0aW9uY29udGV4dG1lbnVcbiAgICAgICAgICBvbjpub2RlZHJhZ3N0YXJ0XG4gICAgICAgICAgb246bm9kZWRyYWdcbiAgICAgICAgICBvbjpub2RlZHJhZ3N0b3BcbiAgICAgICAgLz5cbiAgICAgIDwvVmlld3BvcnRDb21wb25lbnQ+XG4gICAgICA8VXNlclNlbGVjdGlvbiAvPlxuICAgIDwvUGFuZT5cbiAgPC9ab29tPlxuICA8QXR0cmlidXRpb24ge3Byb09wdGlvbnN9IHBvc2l0aW9uPXthdHRyaWJ1dGlvblBvc2l0aW9ufSAvPlxuICA8c2xvdCAvPlxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgLnN2ZWx0ZS1mbG93IHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgei1pbmRleDogMDtcblxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWJhY2tncm91bmQtY29sb3IsIHZhcigtLWJhY2tncm91bmQtY29sb3ItZGVmYXVsdCkpO1xuICB9XG5cbiAgOnJvb3Qge1xuICAgIC0tYmFja2dyb3VuZC1jb2xvci1kZWZhdWx0OiAjZmZmO1xuICAgIC0tYmFja2dyb3VuZC1wYXR0ZXJuLWNvbG9yLWRlZmF1bHQ6ICNkZGQ7XG5cbiAgICAtLW1pbmltYXAtbWFzay1jb2xvci1kZWZhdWx0OiByZ2IoMjQwLCAyNDAsIDI0MCwgMC42KTtcbiAgICAtLW1pbmltYXAtbWFzay1zdHJva2UtY29sb3ItZGVmYXVsdDogbm9uZTtcbiAgICAtLW1pbmltYXAtbWFzay1zdHJva2Utd2lkdGgtZGVmYXVsdDogMTtcblxuICAgIC0tY29udHJvbHMtYnV0dG9uLWJhY2tncm91bmQtY29sb3ItZGVmYXVsdDogI2ZlZmVmZTtcbiAgICAtLWNvbnRyb2xzLWJ1dHRvbi1iYWNrZ3JvdW5kLWNvbG9yLWhvdmVyLWRlZmF1bHQ6ICNmNGY0ZjQ7XG4gICAgLS1jb250cm9scy1idXR0b24tY29sb3ItZGVmYXVsdDogaW5oZXJpdDtcbiAgICAtLWNvbnRyb2xzLWJ1dHRvbi1jb2xvci1ob3Zlci1kZWZhdWx0OiBpbmhlcml0O1xuICAgIC0tY29udHJvbHMtYnV0dG9uLWJvcmRlci1jb2xvci1kZWZhdWx0OiAjZWVlO1xuICB9XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW9RRSwyQkFBYSxDQUNYLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQUksQ0FDWixRQUFRLENBQUUsTUFBTSxDQUNoQixRQUFRLENBQUUsUUFBUSxDQUNsQixPQUFPLENBQUUsQ0FBQyxDQUVWLGdCQUFnQixDQUFFLElBQUksa0JBQWtCLENBQUMsZ0NBQWdDLENBQzNFLENBRUEsS0FBTSxDQUNKLDBCQUEwQixDQUFFLElBQUksQ0FDaEMsa0NBQWtDLENBQUUsSUFBSSxDQUV4Qyw0QkFBNEIsQ0FBRSx1QkFBdUIsQ0FDckQsbUNBQW1DLENBQUUsSUFBSSxDQUN6QyxtQ0FBbUMsQ0FBRSxDQUFDLENBRXRDLDBDQUEwQyxDQUFFLE9BQU8sQ0FDbkQsZ0RBQWdELENBQUUsT0FBTyxDQUN6RCwrQkFBK0IsQ0FBRSxPQUFPLENBQ3hDLHFDQUFxQyxDQUFFLE9BQU8sQ0FDOUMsc0NBQXNDLENBQUUsSUFDMUMifQ== */");
}
var get_connectionLine_slot_changes2 = (dirty) => ({});
var get_connectionLine_slot_context2 = (ctx) => ({ slot: "connectionLine" });
function create_connectionLine_slot(ctx) {
  let current;
  const connectionLine_slot_template = (
    /*#slots*/
    ctx[74].connectionLine
  );
  const connectionLine_slot = create_slot(
    connectionLine_slot_template,
    ctx,
    /*$$scope*/
    ctx[98],
    get_connectionLine_slot_context2
  );
  const block = {
    c: function create2() {
      if (connectionLine_slot) connectionLine_slot.c();
    },
    m: function mount(target, anchor) {
      if (connectionLine_slot) {
        connectionLine_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (connectionLine_slot) {
        if (connectionLine_slot.p && (!current || dirty[3] & /*$$scope*/
        32)) {
          update_slot_base(
            connectionLine_slot,
            connectionLine_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[98],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[98]
            ) : get_slot_changes(
              connectionLine_slot_template,
              /*$$scope*/
              ctx2[98],
              dirty,
              get_connectionLine_slot_changes2
            ),
            get_connectionLine_slot_context2
          );
        }
      }
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(connectionLine_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(connectionLine_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (connectionLine_slot) connectionLine_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_connectionLine_slot.name,
    type: "slot",
    source: "(230:10) ",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let edgerenderer;
  let t02;
  let connectionline;
  let t12;
  let div0;
  let t22;
  let div1;
  let t32;
  let noderenderer;
  let t4;
  let nodeselection;
  let current;
  edgerenderer = new EdgeRenderer_default({
    props: {
      defaultEdgeOptions: (
        /*defaultEdgeOptions*/
        ctx[21]
      )
    },
    $$inline: true
  });
  edgerenderer.$on(
    "edgeclick",
    /*edgeclick_handler*/
    ctx[77]
  );
  edgerenderer.$on(
    "edgecontextmenu",
    /*edgecontextmenu_handler*/
    ctx[78]
  );
  edgerenderer.$on(
    "edgemouseenter",
    /*edgemouseenter_handler*/
    ctx[79]
  );
  edgerenderer.$on(
    "edgemouseleave",
    /*edgemouseleave_handler*/
    ctx[80]
  );
  connectionline = new ConnectionLine_default({
    props: {
      containerStyle: (
        /*connectionLineContainerStyle*/
        ctx[7]
      ),
      style: (
        /*connectionLineStyle*/
        ctx[6]
      ),
      isCustomComponent: (
        /*$$slots*/
        ctx[34].connectionLine
      ),
      $$slots: {
        connectionLine: [create_connectionLine_slot]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  noderenderer = new NodeRenderer_default({
    props: {
      nodeClickDistance: (
        /*nodeClickDistance*/
        ctx[23]
      )
    },
    $$inline: true
  });
  noderenderer.$on(
    "nodeclick",
    /*nodeclick_handler*/
    ctx[81]
  );
  noderenderer.$on(
    "nodemouseenter",
    /*nodemouseenter_handler*/
    ctx[82]
  );
  noderenderer.$on(
    "nodemousemove",
    /*nodemousemove_handler*/
    ctx[83]
  );
  noderenderer.$on(
    "nodemouseleave",
    /*nodemouseleave_handler*/
    ctx[84]
  );
  noderenderer.$on(
    "nodedragstart",
    /*nodedragstart_handler*/
    ctx[85]
  );
  noderenderer.$on(
    "nodedrag",
    /*nodedrag_handler*/
    ctx[86]
  );
  noderenderer.$on(
    "nodedragstop",
    /*nodedragstop_handler*/
    ctx[87]
  );
  noderenderer.$on(
    "nodecontextmenu",
    /*nodecontextmenu_handler*/
    ctx[88]
  );
  nodeselection = new NodeSelection_default({ $$inline: true });
  nodeselection.$on(
    "selectionclick",
    /*selectionclick_handler*/
    ctx[89]
  );
  nodeselection.$on(
    "selectioncontextmenu",
    /*selectioncontextmenu_handler*/
    ctx[90]
  );
  nodeselection.$on(
    "nodedragstart",
    /*nodedragstart_handler_1*/
    ctx[91]
  );
  nodeselection.$on(
    "nodedrag",
    /*nodedrag_handler_1*/
    ctx[92]
  );
  nodeselection.$on(
    "nodedragstop",
    /*nodedragstop_handler_1*/
    ctx[93]
  );
  const block = {
    c: function create2() {
      create_component(edgerenderer.$$.fragment);
      t02 = space();
      create_component(connectionline.$$.fragment);
      t12 = space();
      div0 = element("div");
      t22 = space();
      div1 = element("div");
      t32 = space();
      create_component(noderenderer.$$.fragment);
      t4 = space();
      create_component(nodeselection.$$.fragment);
      attr_dev(div0, "class", "svelte-flow__edgelabel-renderer");
      add_location(div0, file19, 231, 8, 7094);
      attr_dev(div1, "class", "svelte-flow__viewport-portal");
      add_location(div1, file19, 232, 8, 7150);
    },
    m: function mount(target, anchor) {
      mount_component(edgerenderer, target, anchor);
      insert_dev(target, t02, anchor);
      mount_component(connectionline, target, anchor);
      insert_dev(target, t12, anchor);
      insert_dev(target, div0, anchor);
      insert_dev(target, t22, anchor);
      insert_dev(target, div1, anchor);
      insert_dev(target, t32, anchor);
      mount_component(noderenderer, target, anchor);
      insert_dev(target, t4, anchor);
      mount_component(nodeselection, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const edgerenderer_changes = {};
      if (dirty[0] & /*defaultEdgeOptions*/
      2097152) edgerenderer_changes.defaultEdgeOptions = /*defaultEdgeOptions*/
      ctx2[21];
      edgerenderer.$set(edgerenderer_changes);
      const connectionline_changes = {};
      if (dirty[0] & /*connectionLineContainerStyle*/
      128) connectionline_changes.containerStyle = /*connectionLineContainerStyle*/
      ctx2[7];
      if (dirty[0] & /*connectionLineStyle*/
      64) connectionline_changes.style = /*connectionLineStyle*/
      ctx2[6];
      if (dirty[1] & /*$$slots*/
      8) connectionline_changes.isCustomComponent = /*$$slots*/
      ctx2[34].connectionLine;
      if (dirty[3] & /*$$scope*/
      32) {
        connectionline_changes.$$scope = { dirty, ctx: ctx2 };
      }
      connectionline.$set(connectionline_changes);
      const noderenderer_changes = {};
      if (dirty[0] & /*nodeClickDistance*/
      8388608) noderenderer_changes.nodeClickDistance = /*nodeClickDistance*/
      ctx2[23];
      noderenderer.$set(noderenderer_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(edgerenderer.$$.fragment, local2);
      transition_in(connectionline.$$.fragment, local2);
      transition_in(noderenderer.$$.fragment, local2);
      transition_in(nodeselection.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(edgerenderer.$$.fragment, local2);
      transition_out(connectionline.$$.fragment, local2);
      transition_out(noderenderer.$$.fragment, local2);
      transition_out(nodeselection.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t02);
        detach_dev(t12);
        detach_dev(div0);
        detach_dev(t22);
        detach_dev(div1);
        detach_dev(t32);
        detach_dev(t4);
      }
      destroy_component(edgerenderer, detaching);
      destroy_component(connectionline, detaching);
      destroy_component(noderenderer, detaching);
      destroy_component(nodeselection, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(217:6) <ViewportComponent>",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let viewportcomponent;
  let t;
  let userselection;
  let current;
  viewportcomponent = new Viewport_default({
    props: {
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  userselection = new UserSelection_default({ $$inline: true });
  const block = {
    c: function create2() {
      create_component(viewportcomponent.$$.fragment);
      t = space();
      create_component(userselection.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(viewportcomponent, target, anchor);
      insert_dev(target, t, anchor);
      mount_component(userselection, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const viewportcomponent_changes = {};
      if (dirty[0] & /*nodeClickDistance, connectionLineContainerStyle, connectionLineStyle, defaultEdgeOptions*/
      10485952 | dirty[1] & /*$$slots*/
      8 | dirty[3] & /*$$scope*/
      32) {
        viewportcomponent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      viewportcomponent.$set(viewportcomponent_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(viewportcomponent.$$.fragment, local2);
      transition_in(userselection.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(viewportcomponent.$$.fragment, local2);
      transition_out(userselection.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(viewportcomponent, detaching);
      destroy_component(userselection, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(211:4) <Pane       on:paneclick       on:panecontextmenu       panOnDrag={panOnDrag === undefined ? true : panOnDrag}       {selectionOnDrag}     >",
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let pane;
  let current;
  pane = new Pane_default({
    props: {
      panOnDrag: (
        /*panOnDrag*/
        ctx[17] === void 0 ? true : (
          /*panOnDrag*/
          ctx[17]
        )
      ),
      selectionOnDrag: (
        /*selectionOnDrag*/
        ctx[18]
      ),
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  pane.$on(
    "paneclick",
    /*paneclick_handler*/
    ctx[94]
  );
  pane.$on(
    "panecontextmenu",
    /*panecontextmenu_handler*/
    ctx[95]
  );
  const block = {
    c: function create2() {
      create_component(pane.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(pane, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const pane_changes = {};
      if (dirty[0] & /*panOnDrag*/
      131072) pane_changes.panOnDrag = /*panOnDrag*/
      ctx2[17] === void 0 ? true : (
        /*panOnDrag*/
        ctx2[17]
      );
      if (dirty[0] & /*selectionOnDrag*/
      262144) pane_changes.selectionOnDrag = /*selectionOnDrag*/
      ctx2[18];
      if (dirty[0] & /*nodeClickDistance, connectionLineContainerStyle, connectionLineStyle, defaultEdgeOptions*/
      10485952 | dirty[1] & /*$$slots*/
      8 | dirty[3] & /*$$scope*/
      32) {
        pane_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pane.$set(pane_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(pane.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(pane.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(pane, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: "(197:2) <Zoom     initialViewport={initViewport}     {onMoveStart}     {onMove}     {onMoveEnd}     panOnScrollMode={panOnScrollMode === undefined ? PanOnScrollMode.Free : panOnScrollMode}     preventScrolling={preventScrolling === undefined ? true : preventScrolling}     zoomOnScroll={zoomOnScroll === undefined ? true : zoomOnScroll}     zoomOnDoubleClick={zoomOnDoubleClick === undefined ? true : zoomOnDoubleClick}     zoomOnPinch={zoomOnPinch === undefined ? true : zoomOnPinch}     panOnScroll={panOnScroll === undefined ? false : panOnScroll}     panOnDrag={panOnDrag === undefined ? true : panOnDrag}     paneClickDistance={paneClickDistance === undefined ? 0 : paneClickDistance}   >",
    ctx
  });
  return block;
}
function create_fragment34(ctx) {
  let div;
  let keyhandler;
  let t02;
  let zoom2;
  let t12;
  let attribution;
  let t22;
  let div_class_value;
  let div_resize_listener;
  let current;
  let mounted;
  let dispose;
  keyhandler = new KeyHandler_default({
    props: {
      selectionKey: (
        /*selectionKey*/
        ctx[1]
      ),
      deleteKey: (
        /*deleteKey*/
        ctx[5]
      ),
      panActivationKey: (
        /*panActivationKey*/
        ctx[2]
      ),
      multiSelectionKey: (
        /*multiSelectionKey*/
        ctx[3]
      ),
      zoomActivationKey: (
        /*zoomActivationKey*/
        ctx[4]
      )
    },
    $$inline: true
  });
  zoom2 = new Zoom_default({
    props: {
      initialViewport: (
        /*initViewport*/
        ctx[31]
      ),
      onMoveStart: (
        /*onMoveStart*/
        ctx[8]
      ),
      onMove: (
        /*onMove*/
        ctx[9]
      ),
      onMoveEnd: (
        /*onMoveEnd*/
        ctx[10]
      ),
      panOnScrollMode: (
        /*panOnScrollMode*/
        ctx[11] === void 0 ? PanOnScrollMode.Free : (
          /*panOnScrollMode*/
          ctx[11]
        )
      ),
      preventScrolling: (
        /*preventScrolling*/
        ctx[12] === void 0 ? true : (
          /*preventScrolling*/
          ctx[12]
        )
      ),
      zoomOnScroll: (
        /*zoomOnScroll*/
        ctx[13] === void 0 ? true : (
          /*zoomOnScroll*/
          ctx[13]
        )
      ),
      zoomOnDoubleClick: (
        /*zoomOnDoubleClick*/
        ctx[14] === void 0 ? true : (
          /*zoomOnDoubleClick*/
          ctx[14]
        )
      ),
      zoomOnPinch: (
        /*zoomOnPinch*/
        ctx[15] === void 0 ? true : (
          /*zoomOnPinch*/
          ctx[15]
        )
      ),
      panOnScroll: (
        /*panOnScroll*/
        ctx[16] === void 0 ? false : (
          /*panOnScroll*/
          ctx[16]
        )
      ),
      panOnDrag: (
        /*panOnDrag*/
        ctx[17] === void 0 ? true : (
          /*panOnDrag*/
          ctx[17]
        )
      ),
      paneClickDistance: (
        /*paneClickDistance*/
        ctx[22] === void 0 ? 0 : (
          /*paneClickDistance*/
          ctx[22]
        )
      ),
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  attribution = new Attribution_default({
    props: {
      proOptions: (
        /*proOptions*/
        ctx[20]
      ),
      position: (
        /*attributionPosition*/
        ctx[19]
      )
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[74].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[98],
    null
  );
  let div_levels = [
    { style: (
      /*style*/
      ctx[24]
    ) },
    {
      class: div_class_value = cc([
        "svelte-flow",
        /*className*/
        ctx[25],
        /*$colorModeClass*/
        ctx[30]
      ])
    },
    { "data-testid": "svelte-flow__wrapper" },
    /*$$restProps*/
    ctx[33],
    { role: "application" }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create2() {
      div = element("div");
      create_component(keyhandler.$$.fragment);
      t02 = space();
      create_component(zoom2.$$.fragment);
      t12 = space();
      create_component(attribution.$$.fragment);
      t22 = space();
      if (default_slot) default_slot.c();
      set_attributes(div, div_data);
      add_render_callback(() => (
        /*div_elementresize_handler*/
        ctx[97].call(div)
      ));
      toggle_class(div, "svelte-12wlba6", true);
      add_location(div, file19, 177, 0, 5423);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(keyhandler, div, null);
      append_dev(div, t02);
      mount_component(zoom2, div, null);
      append_dev(div, t12);
      mount_component(attribution, div, null);
      append_dev(div, t22);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[96](div);
      div_resize_listener = add_iframe_resize_listener(
        div,
        /*div_elementresize_handler*/
        ctx[97].bind(div)
      );
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "dragover",
            /*dragover_handler*/
            ctx[75],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "drop",
            /*drop_handler*/
            ctx[76],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      const keyhandler_changes = {};
      if (dirty[0] & /*selectionKey*/
      2) keyhandler_changes.selectionKey = /*selectionKey*/
      ctx2[1];
      if (dirty[0] & /*deleteKey*/
      32) keyhandler_changes.deleteKey = /*deleteKey*/
      ctx2[5];
      if (dirty[0] & /*panActivationKey*/
      4) keyhandler_changes.panActivationKey = /*panActivationKey*/
      ctx2[2];
      if (dirty[0] & /*multiSelectionKey*/
      8) keyhandler_changes.multiSelectionKey = /*multiSelectionKey*/
      ctx2[3];
      if (dirty[0] & /*zoomActivationKey*/
      16) keyhandler_changes.zoomActivationKey = /*zoomActivationKey*/
      ctx2[4];
      keyhandler.$set(keyhandler_changes);
      const zoom_changes = {};
      if (dirty[0] & /*onMoveStart*/
      256) zoom_changes.onMoveStart = /*onMoveStart*/
      ctx2[8];
      if (dirty[0] & /*onMove*/
      512) zoom_changes.onMove = /*onMove*/
      ctx2[9];
      if (dirty[0] & /*onMoveEnd*/
      1024) zoom_changes.onMoveEnd = /*onMoveEnd*/
      ctx2[10];
      if (dirty[0] & /*panOnScrollMode*/
      2048) zoom_changes.panOnScrollMode = /*panOnScrollMode*/
      ctx2[11] === void 0 ? PanOnScrollMode.Free : (
        /*panOnScrollMode*/
        ctx2[11]
      );
      if (dirty[0] & /*preventScrolling*/
      4096) zoom_changes.preventScrolling = /*preventScrolling*/
      ctx2[12] === void 0 ? true : (
        /*preventScrolling*/
        ctx2[12]
      );
      if (dirty[0] & /*zoomOnScroll*/
      8192) zoom_changes.zoomOnScroll = /*zoomOnScroll*/
      ctx2[13] === void 0 ? true : (
        /*zoomOnScroll*/
        ctx2[13]
      );
      if (dirty[0] & /*zoomOnDoubleClick*/
      16384) zoom_changes.zoomOnDoubleClick = /*zoomOnDoubleClick*/
      ctx2[14] === void 0 ? true : (
        /*zoomOnDoubleClick*/
        ctx2[14]
      );
      if (dirty[0] & /*zoomOnPinch*/
      32768) zoom_changes.zoomOnPinch = /*zoomOnPinch*/
      ctx2[15] === void 0 ? true : (
        /*zoomOnPinch*/
        ctx2[15]
      );
      if (dirty[0] & /*panOnScroll*/
      65536) zoom_changes.panOnScroll = /*panOnScroll*/
      ctx2[16] === void 0 ? false : (
        /*panOnScroll*/
        ctx2[16]
      );
      if (dirty[0] & /*panOnDrag*/
      131072) zoom_changes.panOnDrag = /*panOnDrag*/
      ctx2[17] === void 0 ? true : (
        /*panOnDrag*/
        ctx2[17]
      );
      if (dirty[0] & /*paneClickDistance*/
      4194304) zoom_changes.paneClickDistance = /*paneClickDistance*/
      ctx2[22] === void 0 ? 0 : (
        /*paneClickDistance*/
        ctx2[22]
      );
      if (dirty[0] & /*panOnDrag, selectionOnDrag, nodeClickDistance, connectionLineContainerStyle, connectionLineStyle, defaultEdgeOptions*/
      10879168 | dirty[1] & /*$$slots*/
      8 | dirty[3] & /*$$scope*/
      32) {
        zoom_changes.$$scope = { dirty, ctx: ctx2 };
      }
      zoom2.$set(zoom_changes);
      const attribution_changes = {};
      if (dirty[0] & /*proOptions*/
      1048576) attribution_changes.proOptions = /*proOptions*/
      ctx2[20];
      if (dirty[0] & /*attributionPosition*/
      524288) attribution_changes.position = /*attributionPosition*/
      ctx2[19];
      attribution.$set(attribution_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[3] & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[98],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[98]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[98],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*style*/
        16777216) && { style: (
          /*style*/
          ctx2[24]
        ) },
        (!current || dirty[0] & /*className, $colorModeClass*/
        1107296256 && div_class_value !== (div_class_value = cc([
          "svelte-flow",
          /*className*/
          ctx2[25],
          /*$colorModeClass*/
          ctx2[30]
        ]))) && { class: div_class_value },
        { "data-testid": "svelte-flow__wrapper" },
        dirty[1] & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[33],
        { role: "application" }
      ]));
      toggle_class(div, "svelte-12wlba6", true);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(keyhandler.$$.fragment, local2);
      transition_in(zoom2.$$.fragment, local2);
      transition_in(attribution.$$.fragment, local2);
      transition_in(default_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(keyhandler.$$.fragment, local2);
      transition_out(zoom2.$$.fragment, local2);
      transition_out(attribution.$$.fragment, local2);
      transition_out(default_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(keyhandler);
      destroy_component(zoom2);
      destroy_component(attribution);
      if (default_slot) default_slot.d(detaching);
      ctx[96](null);
      div_resize_listener();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance34($$self, $$props, $$invalidate) {
  let colorModeClass;
  const omit_props_names = [
    "id",
    "nodes",
    "edges",
    "fitView",
    "fitViewOptions",
    "minZoom",
    "maxZoom",
    "initialViewport",
    "viewport",
    "nodeTypes",
    "edgeTypes",
    "selectionKey",
    "selectionMode",
    "panActivationKey",
    "multiSelectionKey",
    "zoomActivationKey",
    "nodesDraggable",
    "nodesConnectable",
    "nodeDragThreshold",
    "elementsSelectable",
    "snapGrid",
    "deleteKey",
    "connectionRadius",
    "connectionLineType",
    "connectionMode",
    "connectionLineStyle",
    "connectionLineContainerStyle",
    "onMoveStart",
    "onMove",
    "onMoveEnd",
    "isValidConnection",
    "translateExtent",
    "onlyRenderVisibleElements",
    "panOnScrollMode",
    "preventScrolling",
    "zoomOnScroll",
    "zoomOnDoubleClick",
    "zoomOnPinch",
    "panOnScroll",
    "panOnDrag",
    "selectionOnDrag",
    "autoPanOnConnect",
    "autoPanOnNodeDrag",
    "onerror",
    "ondelete",
    "onedgecreate",
    "attributionPosition",
    "proOptions",
    "defaultEdgeOptions",
    "width",
    "height",
    "colorMode",
    "onconnect",
    "onconnectstart",
    "onconnectend",
    "onbeforedelete",
    "oninit",
    "nodeOrigin",
    "paneClickDistance",
    "nodeClickDistance",
    "defaultMarkerColor",
    "style",
    "class"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $initialized;
  let $viewport, $$unsubscribe_viewport = noop, $$subscribe_viewport = () => ($$unsubscribe_viewport(), $$unsubscribe_viewport = subscribe(viewport, ($$value) => $$invalidate(99, $viewport = $$value)), viewport);
  let $colorModeClass, $$unsubscribe_colorModeClass = noop, $$subscribe_colorModeClass = () => ($$unsubscribe_colorModeClass(), $$unsubscribe_colorModeClass = subscribe(colorModeClass, ($$value) => $$invalidate(30, $colorModeClass = $$value)), colorModeClass);
  $$self.$$.on_destroy.push(() => $$unsubscribe_viewport());
  $$self.$$.on_destroy.push(() => $$unsubscribe_colorModeClass());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SvelteFlow", slots, ["connectionLine", "default"]);
  const $$slots = compute_slots(slots);
  let { id: id2 = "1" } = $$props;
  let { nodes } = $$props;
  let { edges } = $$props;
  let { fitView: fitView2 = void 0 } = $$props;
  let { fitViewOptions = void 0 } = $$props;
  let { minZoom = void 0 } = $$props;
  let { maxZoom = void 0 } = $$props;
  let { initialViewport = void 0 } = $$props;
  let { viewport = void 0 } = $$props;
  validate_store(viewport, "viewport");
  $$subscribe_viewport();
  let { nodeTypes = void 0 } = $$props;
  let { edgeTypes = void 0 } = $$props;
  let { selectionKey = void 0 } = $$props;
  let { selectionMode = void 0 } = $$props;
  let { panActivationKey = void 0 } = $$props;
  let { multiSelectionKey = void 0 } = $$props;
  let { zoomActivationKey = void 0 } = $$props;
  let { nodesDraggable = void 0 } = $$props;
  let { nodesConnectable = void 0 } = $$props;
  let { nodeDragThreshold = void 0 } = $$props;
  let { elementsSelectable = void 0 } = $$props;
  let { snapGrid = void 0 } = $$props;
  let { deleteKey = void 0 } = $$props;
  let { connectionRadius = void 0 } = $$props;
  let { connectionLineType = void 0 } = $$props;
  let { connectionMode = ConnectionMode.Strict } = $$props;
  let { connectionLineStyle = "" } = $$props;
  let { connectionLineContainerStyle = "" } = $$props;
  let { onMoveStart = void 0 } = $$props;
  let { onMove = void 0 } = $$props;
  let { onMoveEnd = void 0 } = $$props;
  let { isValidConnection = void 0 } = $$props;
  let { translateExtent = void 0 } = $$props;
  let { onlyRenderVisibleElements = void 0 } = $$props;
  let { panOnScrollMode = PanOnScrollMode.Free } = $$props;
  let { preventScrolling = true } = $$props;
  let { zoomOnScroll = true } = $$props;
  let { zoomOnDoubleClick = true } = $$props;
  let { zoomOnPinch = true } = $$props;
  let { panOnScroll = false } = $$props;
  let { panOnDrag = true } = $$props;
  let { selectionOnDrag = void 0 } = $$props;
  let { autoPanOnConnect = true } = $$props;
  let { autoPanOnNodeDrag = true } = $$props;
  let { onerror = void 0 } = $$props;
  let { ondelete = void 0 } = $$props;
  let { onedgecreate = void 0 } = $$props;
  let { attributionPosition = void 0 } = $$props;
  let { proOptions = void 0 } = $$props;
  let { defaultEdgeOptions = void 0 } = $$props;
  let { width = void 0 } = $$props;
  let { height = void 0 } = $$props;
  let { colorMode = "light" } = $$props;
  let { onconnect = void 0 } = $$props;
  let { onconnectstart = void 0 } = $$props;
  let { onconnectend = void 0 } = $$props;
  let { onbeforedelete = void 0 } = $$props;
  let { oninit = void 0 } = $$props;
  let { nodeOrigin = void 0 } = $$props;
  let { paneClickDistance = 0 } = $$props;
  let { nodeClickDistance = 0 } = $$props;
  let { defaultMarkerColor = "#b1b1b7" } = $$props;
  let { style = void 0 } = $$props;
  let { class: className = void 0 } = $$props;
  let domNode;
  let clientWidth;
  let clientHeight;
  const initViewport = $viewport || initialViewport;
  const store = hasContext(key) ? useStore() : createStoreContext({
    nodes: get_store_value(nodes),
    edges: get_store_value(edges),
    width,
    height,
    fitView: fitView2,
    nodeOrigin
  });
  onMount(() => {
    store.width.set(clientWidth);
    store.height.set(clientHeight);
    store.domNode.set(domNode);
    store.syncNodeStores(nodes);
    store.syncEdgeStores(edges);
    store.syncViewport(viewport);
    if (fitView2 !== void 0) {
      store.fitViewOnInit.set(fitView2);
    }
    if (fitViewOptions) {
      store.fitViewOptions.set(fitViewOptions);
    }
    updateStore(store, {
      nodeTypes,
      edgeTypes,
      minZoom,
      maxZoom,
      translateExtent,
      paneClickDistance
    });
    return () => {
      store.reset();
    };
  });
  const { initialized } = store;
  validate_store(initialized, "initialized");
  component_subscribe($$self, initialized, (value) => $$invalidate(73, $initialized = value));
  let onInitCalled = false;
  $$self.$$.on_mount.push(function() {
    if (nodes === void 0 && !("nodes" in $$props || $$self.$$.bound[$$self.$$.props["nodes"]])) {
      console.warn("<SvelteFlow> was created without expected prop 'nodes'");
    }
    if (edges === void 0 && !("edges" in $$props || $$self.$$.bound[$$self.$$.props["edges"]])) {
      console.warn("<SvelteFlow> was created without expected prop 'edges'");
    }
  });
  function dragover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function drop_handler(event) {
    bubble.call(this, $$self, event);
  }
  function edgeclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function edgecontextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function edgemouseenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function edgemouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodeclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodemouseenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodemousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodemouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodedragstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodedrag_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodedragstop_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodecontextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function selectionclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function selectioncontextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function nodedragstart_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function nodedrag_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function nodedragstop_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function paneclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function panecontextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      domNode = $$value;
      $$invalidate(28, domNode);
    });
  }
  function div_elementresize_handler() {
    clientWidth = this.clientWidth;
    clientHeight = this.clientHeight;
    $$invalidate(26, clientWidth);
    $$invalidate(27, clientHeight);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(33, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props) $$invalidate(35, id2 = $$new_props.id);
    if ("nodes" in $$new_props) $$invalidate(36, nodes = $$new_props.nodes);
    if ("edges" in $$new_props) $$invalidate(37, edges = $$new_props.edges);
    if ("fitView" in $$new_props) $$invalidate(38, fitView2 = $$new_props.fitView);
    if ("fitViewOptions" in $$new_props) $$invalidate(39, fitViewOptions = $$new_props.fitViewOptions);
    if ("minZoom" in $$new_props) $$invalidate(40, minZoom = $$new_props.minZoom);
    if ("maxZoom" in $$new_props) $$invalidate(41, maxZoom = $$new_props.maxZoom);
    if ("initialViewport" in $$new_props) $$invalidate(42, initialViewport = $$new_props.initialViewport);
    if ("viewport" in $$new_props) $$subscribe_viewport($$invalidate(0, viewport = $$new_props.viewport));
    if ("nodeTypes" in $$new_props) $$invalidate(43, nodeTypes = $$new_props.nodeTypes);
    if ("edgeTypes" in $$new_props) $$invalidate(44, edgeTypes = $$new_props.edgeTypes);
    if ("selectionKey" in $$new_props) $$invalidate(1, selectionKey = $$new_props.selectionKey);
    if ("selectionMode" in $$new_props) $$invalidate(45, selectionMode = $$new_props.selectionMode);
    if ("panActivationKey" in $$new_props) $$invalidate(2, panActivationKey = $$new_props.panActivationKey);
    if ("multiSelectionKey" in $$new_props) $$invalidate(3, multiSelectionKey = $$new_props.multiSelectionKey);
    if ("zoomActivationKey" in $$new_props) $$invalidate(4, zoomActivationKey = $$new_props.zoomActivationKey);
    if ("nodesDraggable" in $$new_props) $$invalidate(46, nodesDraggable = $$new_props.nodesDraggable);
    if ("nodesConnectable" in $$new_props) $$invalidate(47, nodesConnectable = $$new_props.nodesConnectable);
    if ("nodeDragThreshold" in $$new_props) $$invalidate(48, nodeDragThreshold = $$new_props.nodeDragThreshold);
    if ("elementsSelectable" in $$new_props) $$invalidate(49, elementsSelectable = $$new_props.elementsSelectable);
    if ("snapGrid" in $$new_props) $$invalidate(50, snapGrid = $$new_props.snapGrid);
    if ("deleteKey" in $$new_props) $$invalidate(5, deleteKey = $$new_props.deleteKey);
    if ("connectionRadius" in $$new_props) $$invalidate(51, connectionRadius = $$new_props.connectionRadius);
    if ("connectionLineType" in $$new_props) $$invalidate(52, connectionLineType = $$new_props.connectionLineType);
    if ("connectionMode" in $$new_props) $$invalidate(53, connectionMode = $$new_props.connectionMode);
    if ("connectionLineStyle" in $$new_props) $$invalidate(6, connectionLineStyle = $$new_props.connectionLineStyle);
    if ("connectionLineContainerStyle" in $$new_props) $$invalidate(7, connectionLineContainerStyle = $$new_props.connectionLineContainerStyle);
    if ("onMoveStart" in $$new_props) $$invalidate(8, onMoveStart = $$new_props.onMoveStart);
    if ("onMove" in $$new_props) $$invalidate(9, onMove = $$new_props.onMove);
    if ("onMoveEnd" in $$new_props) $$invalidate(10, onMoveEnd = $$new_props.onMoveEnd);
    if ("isValidConnection" in $$new_props) $$invalidate(54, isValidConnection = $$new_props.isValidConnection);
    if ("translateExtent" in $$new_props) $$invalidate(55, translateExtent = $$new_props.translateExtent);
    if ("onlyRenderVisibleElements" in $$new_props) $$invalidate(56, onlyRenderVisibleElements = $$new_props.onlyRenderVisibleElements);
    if ("panOnScrollMode" in $$new_props) $$invalidate(11, panOnScrollMode = $$new_props.panOnScrollMode);
    if ("preventScrolling" in $$new_props) $$invalidate(12, preventScrolling = $$new_props.preventScrolling);
    if ("zoomOnScroll" in $$new_props) $$invalidate(13, zoomOnScroll = $$new_props.zoomOnScroll);
    if ("zoomOnDoubleClick" in $$new_props) $$invalidate(14, zoomOnDoubleClick = $$new_props.zoomOnDoubleClick);
    if ("zoomOnPinch" in $$new_props) $$invalidate(15, zoomOnPinch = $$new_props.zoomOnPinch);
    if ("panOnScroll" in $$new_props) $$invalidate(16, panOnScroll = $$new_props.panOnScroll);
    if ("panOnDrag" in $$new_props) $$invalidate(17, panOnDrag = $$new_props.panOnDrag);
    if ("selectionOnDrag" in $$new_props) $$invalidate(18, selectionOnDrag = $$new_props.selectionOnDrag);
    if ("autoPanOnConnect" in $$new_props) $$invalidate(57, autoPanOnConnect = $$new_props.autoPanOnConnect);
    if ("autoPanOnNodeDrag" in $$new_props) $$invalidate(58, autoPanOnNodeDrag = $$new_props.autoPanOnNodeDrag);
    if ("onerror" in $$new_props) $$invalidate(59, onerror = $$new_props.onerror);
    if ("ondelete" in $$new_props) $$invalidate(60, ondelete = $$new_props.ondelete);
    if ("onedgecreate" in $$new_props) $$invalidate(61, onedgecreate = $$new_props.onedgecreate);
    if ("attributionPosition" in $$new_props) $$invalidate(19, attributionPosition = $$new_props.attributionPosition);
    if ("proOptions" in $$new_props) $$invalidate(20, proOptions = $$new_props.proOptions);
    if ("defaultEdgeOptions" in $$new_props) $$invalidate(21, defaultEdgeOptions = $$new_props.defaultEdgeOptions);
    if ("width" in $$new_props) $$invalidate(62, width = $$new_props.width);
    if ("height" in $$new_props) $$invalidate(63, height = $$new_props.height);
    if ("colorMode" in $$new_props) $$invalidate(64, colorMode = $$new_props.colorMode);
    if ("onconnect" in $$new_props) $$invalidate(65, onconnect = $$new_props.onconnect);
    if ("onconnectstart" in $$new_props) $$invalidate(66, onconnectstart = $$new_props.onconnectstart);
    if ("onconnectend" in $$new_props) $$invalidate(67, onconnectend = $$new_props.onconnectend);
    if ("onbeforedelete" in $$new_props) $$invalidate(68, onbeforedelete = $$new_props.onbeforedelete);
    if ("oninit" in $$new_props) $$invalidate(69, oninit = $$new_props.oninit);
    if ("nodeOrigin" in $$new_props) $$invalidate(70, nodeOrigin = $$new_props.nodeOrigin);
    if ("paneClickDistance" in $$new_props) $$invalidate(22, paneClickDistance = $$new_props.paneClickDistance);
    if ("nodeClickDistance" in $$new_props) $$invalidate(23, nodeClickDistance = $$new_props.nodeClickDistance);
    if ("defaultMarkerColor" in $$new_props) $$invalidate(71, defaultMarkerColor = $$new_props.defaultMarkerColor);
    if ("style" in $$new_props) $$invalidate(24, style = $$new_props.style);
    if ("class" in $$new_props) $$invalidate(25, className = $$new_props.class);
    if ("$$scope" in $$new_props) $$invalidate(98, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    hasContext,
    get: get_store_value,
    cc,
    ConnectionMode,
    PanOnScrollMode,
    Zoom: Zoom_default,
    Pane: Pane_default,
    ViewportComponent: Viewport_default,
    NodeRenderer: NodeRenderer_default,
    EdgeRenderer: EdgeRenderer_default,
    UserSelection: UserSelection_default,
    NodeSelection: NodeSelection_default,
    KeyHandler: KeyHandler_default,
    ConnectionLine: ConnectionLine_default,
    Attribution: Attribution_default,
    key,
    useStore,
    createStoreContext,
    updateStore,
    updateStoreByKeys,
    useColorModeClass,
    id: id2,
    nodes,
    edges,
    fitView: fitView2,
    fitViewOptions,
    minZoom,
    maxZoom,
    initialViewport,
    viewport,
    nodeTypes,
    edgeTypes,
    selectionKey,
    selectionMode,
    panActivationKey,
    multiSelectionKey,
    zoomActivationKey,
    nodesDraggable,
    nodesConnectable,
    nodeDragThreshold,
    elementsSelectable,
    snapGrid,
    deleteKey,
    connectionRadius,
    connectionLineType,
    connectionMode,
    connectionLineStyle,
    connectionLineContainerStyle,
    onMoveStart,
    onMove,
    onMoveEnd,
    isValidConnection,
    translateExtent,
    onlyRenderVisibleElements,
    panOnScrollMode,
    preventScrolling,
    zoomOnScroll,
    zoomOnDoubleClick,
    zoomOnPinch,
    panOnScroll,
    panOnDrag,
    selectionOnDrag,
    autoPanOnConnect,
    autoPanOnNodeDrag,
    onerror,
    ondelete,
    onedgecreate,
    attributionPosition,
    proOptions,
    defaultEdgeOptions,
    width,
    height,
    colorMode,
    onconnect,
    onconnectstart,
    onconnectend,
    onbeforedelete,
    oninit,
    nodeOrigin,
    paneClickDistance,
    nodeClickDistance,
    defaultMarkerColor,
    style,
    className,
    domNode,
    clientWidth,
    clientHeight,
    initViewport,
    store,
    initialized,
    onInitCalled,
    colorModeClass,
    $initialized,
    $viewport,
    $colorModeClass
  });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props) $$invalidate(35, id2 = $$new_props.id);
    if ("nodes" in $$props) $$invalidate(36, nodes = $$new_props.nodes);
    if ("edges" in $$props) $$invalidate(37, edges = $$new_props.edges);
    if ("fitView" in $$props) $$invalidate(38, fitView2 = $$new_props.fitView);
    if ("fitViewOptions" in $$props) $$invalidate(39, fitViewOptions = $$new_props.fitViewOptions);
    if ("minZoom" in $$props) $$invalidate(40, minZoom = $$new_props.minZoom);
    if ("maxZoom" in $$props) $$invalidate(41, maxZoom = $$new_props.maxZoom);
    if ("initialViewport" in $$props) $$invalidate(42, initialViewport = $$new_props.initialViewport);
    if ("viewport" in $$props) $$subscribe_viewport($$invalidate(0, viewport = $$new_props.viewport));
    if ("nodeTypes" in $$props) $$invalidate(43, nodeTypes = $$new_props.nodeTypes);
    if ("edgeTypes" in $$props) $$invalidate(44, edgeTypes = $$new_props.edgeTypes);
    if ("selectionKey" in $$props) $$invalidate(1, selectionKey = $$new_props.selectionKey);
    if ("selectionMode" in $$props) $$invalidate(45, selectionMode = $$new_props.selectionMode);
    if ("panActivationKey" in $$props) $$invalidate(2, panActivationKey = $$new_props.panActivationKey);
    if ("multiSelectionKey" in $$props) $$invalidate(3, multiSelectionKey = $$new_props.multiSelectionKey);
    if ("zoomActivationKey" in $$props) $$invalidate(4, zoomActivationKey = $$new_props.zoomActivationKey);
    if ("nodesDraggable" in $$props) $$invalidate(46, nodesDraggable = $$new_props.nodesDraggable);
    if ("nodesConnectable" in $$props) $$invalidate(47, nodesConnectable = $$new_props.nodesConnectable);
    if ("nodeDragThreshold" in $$props) $$invalidate(48, nodeDragThreshold = $$new_props.nodeDragThreshold);
    if ("elementsSelectable" in $$props) $$invalidate(49, elementsSelectable = $$new_props.elementsSelectable);
    if ("snapGrid" in $$props) $$invalidate(50, snapGrid = $$new_props.snapGrid);
    if ("deleteKey" in $$props) $$invalidate(5, deleteKey = $$new_props.deleteKey);
    if ("connectionRadius" in $$props) $$invalidate(51, connectionRadius = $$new_props.connectionRadius);
    if ("connectionLineType" in $$props) $$invalidate(52, connectionLineType = $$new_props.connectionLineType);
    if ("connectionMode" in $$props) $$invalidate(53, connectionMode = $$new_props.connectionMode);
    if ("connectionLineStyle" in $$props) $$invalidate(6, connectionLineStyle = $$new_props.connectionLineStyle);
    if ("connectionLineContainerStyle" in $$props) $$invalidate(7, connectionLineContainerStyle = $$new_props.connectionLineContainerStyle);
    if ("onMoveStart" in $$props) $$invalidate(8, onMoveStart = $$new_props.onMoveStart);
    if ("onMove" in $$props) $$invalidate(9, onMove = $$new_props.onMove);
    if ("onMoveEnd" in $$props) $$invalidate(10, onMoveEnd = $$new_props.onMoveEnd);
    if ("isValidConnection" in $$props) $$invalidate(54, isValidConnection = $$new_props.isValidConnection);
    if ("translateExtent" in $$props) $$invalidate(55, translateExtent = $$new_props.translateExtent);
    if ("onlyRenderVisibleElements" in $$props) $$invalidate(56, onlyRenderVisibleElements = $$new_props.onlyRenderVisibleElements);
    if ("panOnScrollMode" in $$props) $$invalidate(11, panOnScrollMode = $$new_props.panOnScrollMode);
    if ("preventScrolling" in $$props) $$invalidate(12, preventScrolling = $$new_props.preventScrolling);
    if ("zoomOnScroll" in $$props) $$invalidate(13, zoomOnScroll = $$new_props.zoomOnScroll);
    if ("zoomOnDoubleClick" in $$props) $$invalidate(14, zoomOnDoubleClick = $$new_props.zoomOnDoubleClick);
    if ("zoomOnPinch" in $$props) $$invalidate(15, zoomOnPinch = $$new_props.zoomOnPinch);
    if ("panOnScroll" in $$props) $$invalidate(16, panOnScroll = $$new_props.panOnScroll);
    if ("panOnDrag" in $$props) $$invalidate(17, panOnDrag = $$new_props.panOnDrag);
    if ("selectionOnDrag" in $$props) $$invalidate(18, selectionOnDrag = $$new_props.selectionOnDrag);
    if ("autoPanOnConnect" in $$props) $$invalidate(57, autoPanOnConnect = $$new_props.autoPanOnConnect);
    if ("autoPanOnNodeDrag" in $$props) $$invalidate(58, autoPanOnNodeDrag = $$new_props.autoPanOnNodeDrag);
    if ("onerror" in $$props) $$invalidate(59, onerror = $$new_props.onerror);
    if ("ondelete" in $$props) $$invalidate(60, ondelete = $$new_props.ondelete);
    if ("onedgecreate" in $$props) $$invalidate(61, onedgecreate = $$new_props.onedgecreate);
    if ("attributionPosition" in $$props) $$invalidate(19, attributionPosition = $$new_props.attributionPosition);
    if ("proOptions" in $$props) $$invalidate(20, proOptions = $$new_props.proOptions);
    if ("defaultEdgeOptions" in $$props) $$invalidate(21, defaultEdgeOptions = $$new_props.defaultEdgeOptions);
    if ("width" in $$props) $$invalidate(62, width = $$new_props.width);
    if ("height" in $$props) $$invalidate(63, height = $$new_props.height);
    if ("colorMode" in $$props) $$invalidate(64, colorMode = $$new_props.colorMode);
    if ("onconnect" in $$props) $$invalidate(65, onconnect = $$new_props.onconnect);
    if ("onconnectstart" in $$props) $$invalidate(66, onconnectstart = $$new_props.onconnectstart);
    if ("onconnectend" in $$props) $$invalidate(67, onconnectend = $$new_props.onconnectend);
    if ("onbeforedelete" in $$props) $$invalidate(68, onbeforedelete = $$new_props.onbeforedelete);
    if ("oninit" in $$props) $$invalidate(69, oninit = $$new_props.oninit);
    if ("nodeOrigin" in $$props) $$invalidate(70, nodeOrigin = $$new_props.nodeOrigin);
    if ("paneClickDistance" in $$props) $$invalidate(22, paneClickDistance = $$new_props.paneClickDistance);
    if ("nodeClickDistance" in $$props) $$invalidate(23, nodeClickDistance = $$new_props.nodeClickDistance);
    if ("defaultMarkerColor" in $$props) $$invalidate(71, defaultMarkerColor = $$new_props.defaultMarkerColor);
    if ("style" in $$props) $$invalidate(24, style = $$new_props.style);
    if ("className" in $$props) $$invalidate(25, className = $$new_props.className);
    if ("domNode" in $$props) $$invalidate(28, domNode = $$new_props.domNode);
    if ("clientWidth" in $$props) $$invalidate(26, clientWidth = $$new_props.clientWidth);
    if ("clientHeight" in $$props) $$invalidate(27, clientHeight = $$new_props.clientHeight);
    if ("onInitCalled" in $$props) $$invalidate(72, onInitCalled = $$new_props.onInitCalled);
    if ("colorModeClass" in $$props) $$subscribe_colorModeClass($$invalidate(29, colorModeClass = $$new_props.colorModeClass));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*clientWidth, clientHeight*/
    201326592) {
      $: {
        if (clientWidth !== void 0 && clientHeight !== void 0) {
          store.width.set(clientWidth);
          store.height.set(clientHeight);
        }
      }
    }
    if ($$self.$$.dirty[2] & /*onInitCalled, $initialized, oninit*/
    3200) {
      $: {
        if (!onInitCalled && $initialized) {
          oninit == null ? void 0 : oninit();
          $$invalidate(72, onInitCalled = true);
        }
      }
    }
    if ($$self.$$.dirty[1] & /*id, connectionLineType, connectionRadius, selectionMode, snapGrid, nodesDraggable, nodesConnectable, elementsSelectable, onlyRenderVisibleElements, isValidConnection, autoPanOnConnect, autoPanOnNodeDrag, onerror, ondelete, onedgecreate, connectionMode, nodeDragThreshold*/
    2130690064 | $$self.$$.dirty[2] & /*defaultMarkerColor, onconnect, onconnectstart, onconnectend, onbeforedelete, nodeOrigin*/
    888) {
      $: {
        const updatableProps = {
          flowId: id2,
          connectionLineType,
          connectionRadius,
          selectionMode,
          snapGrid,
          defaultMarkerColor,
          nodesDraggable,
          nodesConnectable,
          elementsSelectable,
          onlyRenderVisibleElements,
          isValidConnection,
          autoPanOnConnect,
          autoPanOnNodeDrag,
          onerror,
          ondelete,
          onedgecreate,
          connectionMode,
          nodeDragThreshold,
          onconnect,
          onconnectstart,
          onconnectend,
          onbeforedelete,
          nodeOrigin
        };
        updateStoreByKeys(store, updatableProps);
      }
    }
    if ($$self.$$.dirty[0] & /*paneClickDistance*/
    4194304 | $$self.$$.dirty[1] & /*nodeTypes, edgeTypes, minZoom, maxZoom, translateExtent*/
    16791040) {
      $: updateStore(store, {
        nodeTypes,
        edgeTypes,
        minZoom,
        maxZoom,
        translateExtent,
        paneClickDistance
      });
    }
    if ($$self.$$.dirty[2] & /*colorMode*/
    4) {
      $: $$subscribe_colorModeClass($$invalidate(29, colorModeClass = useColorModeClass(colorMode)));
    }
  };
  return [
    viewport,
    selectionKey,
    panActivationKey,
    multiSelectionKey,
    zoomActivationKey,
    deleteKey,
    connectionLineStyle,
    connectionLineContainerStyle,
    onMoveStart,
    onMove,
    onMoveEnd,
    panOnScrollMode,
    preventScrolling,
    zoomOnScroll,
    zoomOnDoubleClick,
    zoomOnPinch,
    panOnScroll,
    panOnDrag,
    selectionOnDrag,
    attributionPosition,
    proOptions,
    defaultEdgeOptions,
    paneClickDistance,
    nodeClickDistance,
    style,
    className,
    clientWidth,
    clientHeight,
    domNode,
    colorModeClass,
    $colorModeClass,
    initViewport,
    initialized,
    $$restProps,
    $$slots,
    id2,
    nodes,
    edges,
    fitView2,
    fitViewOptions,
    minZoom,
    maxZoom,
    initialViewport,
    nodeTypes,
    edgeTypes,
    selectionMode,
    nodesDraggable,
    nodesConnectable,
    nodeDragThreshold,
    elementsSelectable,
    snapGrid,
    connectionRadius,
    connectionLineType,
    connectionMode,
    isValidConnection,
    translateExtent,
    onlyRenderVisibleElements,
    autoPanOnConnect,
    autoPanOnNodeDrag,
    onerror,
    ondelete,
    onedgecreate,
    width,
    height,
    colorMode,
    onconnect,
    onconnectstart,
    onconnectend,
    onbeforedelete,
    oninit,
    nodeOrigin,
    defaultMarkerColor,
    onInitCalled,
    $initialized,
    slots,
    dragover_handler,
    drop_handler,
    edgeclick_handler,
    edgecontextmenu_handler,
    edgemouseenter_handler,
    edgemouseleave_handler,
    nodeclick_handler,
    nodemouseenter_handler,
    nodemousemove_handler,
    nodemouseleave_handler,
    nodedragstart_handler,
    nodedrag_handler,
    nodedragstop_handler,
    nodecontextmenu_handler,
    selectionclick_handler,
    selectioncontextmenu_handler,
    nodedragstart_handler_1,
    nodedrag_handler_1,
    nodedragstop_handler_1,
    paneclick_handler,
    panecontextmenu_handler,
    div_binding,
    div_elementresize_handler,
    $$scope
  ];
}
var SvelteFlow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance34,
      create_fragment34,
      safe_not_equal,
      {
        id: 35,
        nodes: 36,
        edges: 37,
        fitView: 38,
        fitViewOptions: 39,
        minZoom: 40,
        maxZoom: 41,
        initialViewport: 42,
        viewport: 0,
        nodeTypes: 43,
        edgeTypes: 44,
        selectionKey: 1,
        selectionMode: 45,
        panActivationKey: 2,
        multiSelectionKey: 3,
        zoomActivationKey: 4,
        nodesDraggable: 46,
        nodesConnectable: 47,
        nodeDragThreshold: 48,
        elementsSelectable: 49,
        snapGrid: 50,
        deleteKey: 5,
        connectionRadius: 51,
        connectionLineType: 52,
        connectionMode: 53,
        connectionLineStyle: 6,
        connectionLineContainerStyle: 7,
        onMoveStart: 8,
        onMove: 9,
        onMoveEnd: 10,
        isValidConnection: 54,
        translateExtent: 55,
        onlyRenderVisibleElements: 56,
        panOnScrollMode: 11,
        preventScrolling: 12,
        zoomOnScroll: 13,
        zoomOnDoubleClick: 14,
        zoomOnPinch: 15,
        panOnScroll: 16,
        panOnDrag: 17,
        selectionOnDrag: 18,
        autoPanOnConnect: 57,
        autoPanOnNodeDrag: 58,
        onerror: 59,
        ondelete: 60,
        onedgecreate: 61,
        attributionPosition: 19,
        proOptions: 20,
        defaultEdgeOptions: 21,
        width: 62,
        height: 63,
        colorMode: 64,
        onconnect: 65,
        onconnectstart: 66,
        onconnectend: 67,
        onbeforedelete: 68,
        oninit: 69,
        nodeOrigin: 70,
        paneClickDistance: 22,
        nodeClickDistance: 23,
        defaultMarkerColor: 71,
        style: 24,
        class: 25
      },
      add_css7,
      [-1, -1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SvelteFlow",
      options,
      id: create_fragment34.name
    });
  }
  get id() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodes() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodes(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get edges() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set edges(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fitView() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fitView(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fitViewOptions() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fitViewOptions(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minZoom() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minZoom(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxZoom() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxZoom(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialViewport() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialViewport(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewport() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewport(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeTypes() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeTypes(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get edgeTypes() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set edgeTypes(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectionKey() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectionKey(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectionMode() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectionMode(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panActivationKey() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panActivationKey(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiSelectionKey() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiSelectionKey(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomActivationKey() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomActivationKey(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodesDraggable() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodesDraggable(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodesConnectable() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodesConnectable(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeDragThreshold() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeDragThreshold(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get elementsSelectable() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set elementsSelectable(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get snapGrid() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set snapGrid(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deleteKey() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set deleteKey(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get connectionRadius() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set connectionRadius(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get connectionLineType() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set connectionLineType(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get connectionMode() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set connectionMode(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get connectionLineStyle() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set connectionLineStyle(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get connectionLineContainerStyle() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set connectionLineContainerStyle(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMoveStart() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMoveStart(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMove() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMove(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMoveEnd() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMoveEnd(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isValidConnection() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isValidConnection(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateExtent() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateExtent(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onlyRenderVisibleElements() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onlyRenderVisibleElements(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panOnScrollMode() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panOnScrollMode(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get preventScrolling() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preventScrolling(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomOnScroll() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomOnScroll(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomOnDoubleClick() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomOnDoubleClick(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomOnPinch() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomOnPinch(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panOnScroll() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panOnScroll(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panOnDrag() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panOnDrag(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectionOnDrag() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectionOnDrag(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoPanOnConnect() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoPanOnConnect(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoPanOnNodeDrag() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoPanOnNodeDrag(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onerror() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onerror(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ondelete() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ondelete(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onedgecreate() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onedgecreate(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get attributionPosition() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set attributionPosition(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get proOptions() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set proOptions(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultEdgeOptions() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultEdgeOptions(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colorMode() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colorMode(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onconnect() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onconnect(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onconnectstart() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onconnectstart(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onconnectend() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onconnectend(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onbeforedelete() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onbeforedelete(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get oninit() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set oninit(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeOrigin() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeOrigin(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get paneClickDistance() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set paneClickDistance(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeClickDistance() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeClickDistance(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultMarkerColor() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultMarkerColor(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SvelteFlow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SvelteFlow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SvelteFlow_default = SvelteFlow;

// node_modules/@xyflow/svelte/dist/lib/components/SvelteFlowProvider/SvelteFlowProvider.svelte
function create_fragment35(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create2() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(default_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(default_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance35($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SvelteFlowProvider", slots, ["default"]);
  let { initialNodes = void 0 } = $$props;
  let { initialEdges = void 0 } = $$props;
  let { initialWidth = void 0 } = $$props;
  let { initialHeight = void 0 } = $$props;
  let { fitView: fitView2 = void 0 } = $$props;
  let { nodeOrigin = void 0 } = $$props;
  const store = createStore({
    nodes: initialNodes,
    edges: initialEdges,
    width: initialWidth,
    height: initialHeight,
    nodeOrigin,
    fitView: fitView2
  });
  setContext(key, { getStore: () => store });
  onDestroy(() => {
    store.reset();
  });
  const writable_props = [
    "initialNodes",
    "initialEdges",
    "initialWidth",
    "initialHeight",
    "fitView",
    "nodeOrigin"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<SvelteFlowProvider> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("initialNodes" in $$props2) $$invalidate(0, initialNodes = $$props2.initialNodes);
    if ("initialEdges" in $$props2) $$invalidate(1, initialEdges = $$props2.initialEdges);
    if ("initialWidth" in $$props2) $$invalidate(2, initialWidth = $$props2.initialWidth);
    if ("initialHeight" in $$props2) $$invalidate(3, initialHeight = $$props2.initialHeight);
    if ("fitView" in $$props2) $$invalidate(4, fitView2 = $$props2.fitView);
    if ("nodeOrigin" in $$props2) $$invalidate(5, nodeOrigin = $$props2.nodeOrigin);
    if ("$$scope" in $$props2) $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    setContext,
    createStore,
    key,
    initialNodes,
    initialEdges,
    initialWidth,
    initialHeight,
    fitView: fitView2,
    nodeOrigin,
    store
  });
  $$self.$inject_state = ($$props2) => {
    if ("initialNodes" in $$props2) $$invalidate(0, initialNodes = $$props2.initialNodes);
    if ("initialEdges" in $$props2) $$invalidate(1, initialEdges = $$props2.initialEdges);
    if ("initialWidth" in $$props2) $$invalidate(2, initialWidth = $$props2.initialWidth);
    if ("initialHeight" in $$props2) $$invalidate(3, initialHeight = $$props2.initialHeight);
    if ("fitView" in $$props2) $$invalidate(4, fitView2 = $$props2.fitView);
    if ("nodeOrigin" in $$props2) $$invalidate(5, nodeOrigin = $$props2.nodeOrigin);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    initialNodes,
    initialEdges,
    initialWidth,
    initialHeight,
    fitView2,
    nodeOrigin,
    $$scope,
    slots
  ];
}
var SvelteFlowProvider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment35, safe_not_equal, {
      initialNodes: 0,
      initialEdges: 1,
      initialWidth: 2,
      initialHeight: 3,
      fitView: 4,
      nodeOrigin: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SvelteFlowProvider",
      options,
      id: create_fragment35.name
    });
  }
  get initialNodes() {
    throw new Error("<SvelteFlowProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialNodes(value) {
    throw new Error("<SvelteFlowProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialEdges() {
    throw new Error("<SvelteFlowProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialEdges(value) {
    throw new Error("<SvelteFlowProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialWidth() {
    throw new Error("<SvelteFlowProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialWidth(value) {
    throw new Error("<SvelteFlowProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialHeight() {
    throw new Error("<SvelteFlowProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialHeight(value) {
    throw new Error("<SvelteFlowProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fitView() {
    throw new Error("<SvelteFlowProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fitView(value) {
    throw new Error("<SvelteFlowProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeOrigin() {
    throw new Error("<SvelteFlowProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeOrigin(value) {
    throw new Error("<SvelteFlowProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SvelteFlowProvider_default = SvelteFlowProvider;

// node_modules/@xyflow/svelte/dist/lib/components/ViewportPortal/ViewportPortal.svelte
var file20 = "node_modules/@xyflow/svelte/dist/lib/components/ViewportPortal/ViewportPortal.svelte";
function create_fragment36(ctx) {
  let div;
  let portal_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create2() {
      div = element("div");
      if (default_slot) default_slot.c();
      add_location(div, file20, 5, 0, 134);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(portal_action = portal_default.call(null, div, {
          target: ".svelte-flow__viewport-portal",
          domNode: (
            /*$domNode*/
            ctx[0]
          )
        }));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (portal_action && is_function(portal_action.update) && dirty & /*$domNode*/
      1) portal_action.update.call(null, {
        target: ".svelte-flow__viewport-portal",
        domNode: (
          /*$domNode*/
          ctx2[0]
        )
      });
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(default_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(default_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance36($$self, $$props, $$invalidate) {
  let $domNode;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ViewportPortal", slots, ["default"]);
  const { domNode } = useStore();
  validate_store(domNode, "domNode");
  component_subscribe($$self, domNode, (value) => $$invalidate(0, $domNode = value));
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<ViewportPortal> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ portal: portal_default, useStore, domNode, $domNode });
  return [$domNode, domNode, $$scope, slots];
}
var ViewportPortal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance36, create_fragment36, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ViewportPortal",
      options,
      id: create_fragment36.name
    });
  }
};
var ViewportPortal_default = ViewportPortal;

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/ControlButton.svelte
var file21 = "node_modules/@xyflow/svelte/dist/lib/plugins/Controls/ControlButton.svelte";
var get_default_slot_changes = (dirty) => ({});
var get_default_slot_context = (ctx) => ({ class: "button-svg" });
function create_fragment37(ctx) {
  let button;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context
  );
  let button_levels = [
    { type: "button" },
    {
      class: button_class_value = cc([
        "svelte-flow__controls-button",
        /*className*/
        ctx[0]
      ])
    },
    /*$$restProps*/
    ctx[6]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create2() {
      button = element("button");
      if (default_slot) default_slot.c();
      set_attributes(button, button_data);
      set_style(
        button,
        "--xy-controls-button-background-color-props",
        /*bgColor*/
        ctx[1]
      );
      set_style(
        button,
        "--xy-controls-button-background-color-hover-props",
        /*bgColorHover*/
        ctx[2]
      );
      set_style(
        button,
        "--xy-controls-button-color-props",
        /*color*/
        ctx[3]
      );
      set_style(
        button,
        "--xy-controls-button-color-hover-props",
        /*colorHover*/
        ctx[4]
      );
      set_style(
        button,
        "--xy-controls-button-border-color-props",
        /*borderColor*/
        ctx[5]
      );
      add_location(button, file21, 10, 0, 239);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus) button.focus();
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[9],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        (!current || dirty & /*className*/
        1 && button_class_value !== (button_class_value = cc([
          "svelte-flow__controls-button",
          /*className*/
          ctx2[0]
        ]))) && { class: button_class_value },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6]
      ]));
      set_style(
        button,
        "--xy-controls-button-background-color-props",
        /*bgColor*/
        ctx2[1]
      );
      set_style(
        button,
        "--xy-controls-button-background-color-hover-props",
        /*bgColorHover*/
        ctx2[2]
      );
      set_style(
        button,
        "--xy-controls-button-color-props",
        /*color*/
        ctx2[3]
      );
      set_style(
        button,
        "--xy-controls-button-color-hover-props",
        /*colorHover*/
        ctx2[4]
      );
      set_style(
        button,
        "--xy-controls-button-border-color-props",
        /*borderColor*/
        ctx2[5]
      );
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(default_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(default_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance37($$self, $$props, $$invalidate) {
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ControlButton", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let bgColor = void 0;
  let bgColorHover = void 0;
  let color2 = void 0;
  let colorHover = void 0;
  let borderColor = void 0;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    cc,
    className,
    bgColor,
    bgColorHover,
    color: color2,
    colorHover,
    borderColor
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
    if ("bgColor" in $$props) $$invalidate(1, bgColor = $$new_props.bgColor);
    if ("bgColorHover" in $$props) $$invalidate(2, bgColorHover = $$new_props.bgColorHover);
    if ("color" in $$props) $$invalidate(3, color2 = $$new_props.color);
    if ("colorHover" in $$props) $$invalidate(4, colorHover = $$new_props.colorHover);
    if ("borderColor" in $$props) $$invalidate(5, borderColor = $$new_props.borderColor);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    className,
    bgColor,
    bgColorHover,
    color2,
    colorHover,
    borderColor,
    $$restProps,
    $$scope,
    slots,
    click_handler
  ];
}
var ControlButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance37, create_fragment37, safe_not_equal, { class: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ControlButton",
      options,
      id: create_fragment37.name
    });
  }
  get class() {
    throw new Error("<ControlButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ControlButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ControlButton_default = ControlButton;

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Plus.svelte
var file22 = "node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Plus.svelte";
function create_fragment38(ctx) {
  let svg;
  let path;
  const block = {
    c: function create2() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr_dev(path, "d", "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z");
      add_location(path, file22, 1, 2, 63);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 32 32");
      add_location(svg, file22, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance38($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Plus", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Plus> was created with unknown prop '${key2}'`);
  });
  return [];
}
var Plus = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance38, create_fragment38, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Plus",
      options,
      id: create_fragment38.name
    });
  }
};
var Plus_default = Plus;

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Minus.svelte
var file23 = "node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Minus.svelte";
function create_fragment39(ctx) {
  let svg;
  let path;
  const block = {
    c: function create2() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr_dev(path, "d", "M0 0h32v4.2H0z");
      add_location(path, file23, 1, 2, 62);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 32 5");
      add_location(svg, file23, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance39($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Minus", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Minus> was created with unknown prop '${key2}'`);
  });
  return [];
}
var Minus = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance39, create_fragment39, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Minus",
      options,
      id: create_fragment39.name
    });
  }
};
var Minus_default = Minus;

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Fit.svelte
var file24 = "node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Fit.svelte";
function create_fragment40(ctx) {
  let svg;
  let path;
  const block = {
    c: function create2() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr_dev(path, "d", "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z");
      add_location(path, file24, 1, 2, 63);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 32 30");
      add_location(svg, file24, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance40($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Fit", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Fit> was created with unknown prop '${key2}'`);
  });
  return [];
}
var Fit = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance40, create_fragment40, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fit",
      options,
      id: create_fragment40.name
    });
  }
};
var Fit_default = Fit;

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Lock.svelte
var file25 = "node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Lock.svelte";
function create_fragment41(ctx) {
  let svg;
  let path;
  const block = {
    c: function create2() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr_dev(path, "d", "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z");
      add_location(path, file25, 1, 2, 63);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 25 32");
      add_location(svg, file25, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance41($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Lock", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Lock> was created with unknown prop '${key2}'`);
  });
  return [];
}
var Lock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance41, create_fragment41, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Lock",
      options,
      id: create_fragment41.name
    });
  }
};
var Lock_default = Lock;

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Unlock.svelte
var file26 = "node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Unlock.svelte";
function create_fragment42(ctx) {
  let svg;
  let path;
  const block = {
    c: function create2() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr_dev(path, "d", "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z");
      add_location(path, file26, 1, 2, 63);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 25 32");
      add_location(svg, file26, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance42($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Unlock", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Unlock> was created with unknown prop '${key2}'`);
  });
  return [];
}
var Unlock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance42, create_fragment42, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Unlock",
      options,
      id: create_fragment42.name
    });
  }
};
var Unlock_default = Unlock;

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Controls.svelte
var get_after_slot_changes = (dirty) => ({});
var get_after_slot_context = (ctx) => ({});
var get_before_slot_changes = (dirty) => ({});
var get_before_slot_context = (ctx) => ({});
function create_if_block_3(ctx) {
  let controlbutton0;
  let t;
  let controlbutton1;
  let current;
  const controlbutton0_spread_levels = [
    { class: "svelte-flow__controls-zoomin" },
    { title: "zoom in" },
    { "aria-label": "zoom in" },
    { disabled: (
      /*maxZoomReached*/
      ctx[9]
    ) },
    /*buttonProps*/
    ctx[17]
  ];
  let controlbutton0_props = {
    $$slots: { default: [create_default_slot_4] },
    $$scope: { ctx }
  };
  for (let i = 0; i < controlbutton0_spread_levels.length; i += 1) {
    controlbutton0_props = assign(controlbutton0_props, controlbutton0_spread_levels[i]);
  }
  controlbutton0 = new ControlButton_default({
    props: controlbutton0_props,
    $$inline: true
  });
  controlbutton0.$on(
    "click",
    /*onZoomInHandler*/
    ctx[18]
  );
  const controlbutton1_spread_levels = [
    { class: "svelte-flow__controls-zoomout" },
    { title: "zoom out" },
    { "aria-label": "zoom out" },
    { disabled: (
      /*minZoomReached*/
      ctx[10]
    ) },
    /*buttonProps*/
    ctx[17]
  ];
  let controlbutton1_props = {
    $$slots: { default: [create_default_slot_3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < controlbutton1_spread_levels.length; i += 1) {
    controlbutton1_props = assign(controlbutton1_props, controlbutton1_spread_levels[i]);
  }
  controlbutton1 = new ControlButton_default({
    props: controlbutton1_props,
    $$inline: true
  });
  controlbutton1.$on(
    "click",
    /*onZoomOutHandler*/
    ctx[19]
  );
  const block = {
    c: function create2() {
      create_component(controlbutton0.$$.fragment);
      t = space();
      create_component(controlbutton1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(controlbutton0, target, anchor);
      insert_dev(target, t, anchor);
      mount_component(controlbutton1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const controlbutton0_changes = dirty[0] & /*maxZoomReached, buttonProps*/
      131584 ? get_spread_update(controlbutton0_spread_levels, [
        controlbutton0_spread_levels[0],
        controlbutton0_spread_levels[1],
        controlbutton0_spread_levels[2],
        dirty[0] & /*maxZoomReached*/
        512 && { disabled: (
          /*maxZoomReached*/
          ctx2[9]
        ) },
        dirty[0] & /*buttonProps*/
        131072 && get_spread_object(
          /*buttonProps*/
          ctx2[17]
        )
      ]) : {};
      if (dirty[1] & /*$$scope*/
      32) {
        controlbutton0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      controlbutton0.$set(controlbutton0_changes);
      const controlbutton1_changes = dirty[0] & /*minZoomReached, buttonProps*/
      132096 ? get_spread_update(controlbutton1_spread_levels, [
        controlbutton1_spread_levels[0],
        controlbutton1_spread_levels[1],
        controlbutton1_spread_levels[2],
        dirty[0] & /*minZoomReached*/
        1024 && { disabled: (
          /*minZoomReached*/
          ctx2[10]
        ) },
        dirty[0] & /*buttonProps*/
        131072 && get_spread_object(
          /*buttonProps*/
          ctx2[17]
        )
      ]) : {};
      if (dirty[1] & /*$$scope*/
      32) {
        controlbutton1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      controlbutton1.$set(controlbutton1_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(controlbutton0.$$.fragment, local2);
      transition_in(controlbutton1.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(controlbutton0.$$.fragment, local2);
      transition_out(controlbutton1.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(controlbutton0, detaching);
      destroy_component(controlbutton1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(62:2) {#if showZoom}",
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  let plusicon;
  let current;
  plusicon = new Plus_default({ $$inline: true });
  const block = {
    c: function create2() {
      create_component(plusicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(plusicon, target, anchor);
      current = true;
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(plusicon.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(plusicon.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(plusicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: '(63:4) <ControlButton       on:click={onZoomInHandler}       class=\\"svelte-flow__controls-zoomin\\"       title=\\"zoom in\\"       aria-label=\\"zoom in\\"       disabled={maxZoomReached}       {...buttonProps}     >',
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let minusicon;
  let current;
  minusicon = new Minus_default({ $$inline: true });
  const block = {
    c: function create2() {
      create_component(minusicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(minusicon, target, anchor);
      current = true;
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(minusicon.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(minusicon.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(minusicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: '(73:4) <ControlButton       on:click={onZoomOutHandler}       class=\\"svelte-flow__controls-zoomout\\"       title=\\"zoom out\\"       aria-label=\\"zoom out\\"       disabled={minZoomReached}       {...buttonProps}     >',
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let controlbutton;
  let current;
  const controlbutton_spread_levels = [
    { class: "svelte-flow__controls-fitview" },
    { title: "fit view" },
    { "aria-label": "fit view" },
    /*buttonProps*/
    ctx[17]
  ];
  let controlbutton_props = {
    $$slots: { default: [create_default_slot_22] },
    $$scope: { ctx }
  };
  for (let i = 0; i < controlbutton_spread_levels.length; i += 1) {
    controlbutton_props = assign(controlbutton_props, controlbutton_spread_levels[i]);
  }
  controlbutton = new ControlButton_default({
    props: controlbutton_props,
    $$inline: true
  });
  controlbutton.$on(
    "click",
    /*onFitViewHandler*/
    ctx[20]
  );
  const block = {
    c: function create2() {
      create_component(controlbutton.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(controlbutton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const controlbutton_changes = dirty[0] & /*buttonProps*/
      131072 ? get_spread_update(controlbutton_spread_levels, [
        controlbutton_spread_levels[0],
        controlbutton_spread_levels[1],
        controlbutton_spread_levels[2],
        get_spread_object(
          /*buttonProps*/
          ctx2[17]
        )
      ]) : {};
      if (dirty[1] & /*$$scope*/
      32) {
        controlbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      controlbutton.$set(controlbutton_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(controlbutton.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(controlbutton.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(controlbutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(84:2) {#if showFitView}",
    ctx
  });
  return block;
}
function create_default_slot_22(ctx) {
  let fitviewicon;
  let current;
  fitviewicon = new Fit_default({ $$inline: true });
  const block = {
    c: function create2() {
      create_component(fitviewicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(fitviewicon, target, anchor);
      current = true;
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(fitviewicon.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(fitviewicon.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(fitviewicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_22.name,
    type: "slot",
    source: '(85:4) <ControlButton       class=\\"svelte-flow__controls-fitview\\"       on:click={onFitViewHandler}       title=\\"fit view\\"       aria-label=\\"fit view\\"       {...buttonProps}     >',
    ctx
  });
  return block;
}
function create_if_block10(ctx) {
  let controlbutton;
  let current;
  const controlbutton_spread_levels = [
    {
      class: "svelte-flow__controls-interactive"
    },
    { title: "toggle interactivity" },
    { "aria-label": "toggle interactivity" },
    /*buttonProps*/
    ctx[17]
  ];
  let controlbutton_props = {
    $$slots: { default: [create_default_slot_12] },
    $$scope: { ctx }
  };
  for (let i = 0; i < controlbutton_spread_levels.length; i += 1) {
    controlbutton_props = assign(controlbutton_props, controlbutton_spread_levels[i]);
  }
  controlbutton = new ControlButton_default({
    props: controlbutton_props,
    $$inline: true
  });
  controlbutton.$on(
    "click",
    /*onToggleInteractivity*/
    ctx[21]
  );
  const block = {
    c: function create2() {
      create_component(controlbutton.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(controlbutton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const controlbutton_changes = dirty[0] & /*buttonProps*/
      131072 ? get_spread_update(controlbutton_spread_levels, [
        controlbutton_spread_levels[0],
        controlbutton_spread_levels[1],
        controlbutton_spread_levels[2],
        get_spread_object(
          /*buttonProps*/
          ctx2[17]
        )
      ]) : {};
      if (dirty[0] & /*isInteractive*/
      256 | dirty[1] & /*$$scope*/
      32) {
        controlbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      controlbutton.$set(controlbutton_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(controlbutton.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(controlbutton.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(controlbutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(95:2) {#if showLock}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let lockicon;
  let current;
  lockicon = new Lock_default({ $$inline: true });
  const block = {
    c: function create2() {
      create_component(lockicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(lockicon, target, anchor);
      current = true;
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(lockicon.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(lockicon.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(lockicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(103:39) {:else}",
    ctx
  });
  return block;
}
function create_if_block_14(ctx) {
  let unlockicon;
  let current;
  unlockicon = new Unlock_default({ $$inline: true });
  const block = {
    c: function create2() {
      create_component(unlockicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(unlockicon, target, anchor);
      current = true;
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(unlockicon.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(unlockicon.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(unlockicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(103:6) {#if isInteractive}",
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_14, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*isInteractive*/
      ctx2[8]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create2() {
      if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: '(96:4) <ControlButton       class=\\"svelte-flow__controls-interactive\\"       on:click={onToggleInteractivity}       title=\\"toggle interactivity\\"       aria-label=\\"toggle interactivity\\"       {...buttonProps}     >',
    ctx
  });
  return block;
}
function create_default_slot5(ctx) {
  let t02;
  let t12;
  let t22;
  let t32;
  let t4;
  let current;
  const before_slot_template = (
    /*#slots*/
    ctx[35].before
  );
  const before_slot = create_slot(
    before_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    get_before_slot_context
  );
  let if_block0 = (
    /*showZoom*/
    ctx[1] && create_if_block_3(ctx)
  );
  let if_block1 = (
    /*showFitView*/
    ctx[2] && create_if_block_2(ctx)
  );
  let if_block2 = (
    /*showLock*/
    ctx[3] && create_if_block10(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[35].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    null
  );
  const after_slot_template = (
    /*#slots*/
    ctx[35].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    get_after_slot_context
  );
  const block = {
    c: function create2() {
      if (before_slot) before_slot.c();
      t02 = space();
      if (if_block0) if_block0.c();
      t12 = space();
      if (if_block1) if_block1.c();
      t22 = space();
      if (if_block2) if_block2.c();
      t32 = space();
      if (default_slot) default_slot.c();
      t4 = space();
      if (after_slot) after_slot.c();
    },
    m: function mount(target, anchor) {
      if (before_slot) {
        before_slot.m(target, anchor);
      }
      insert_dev(target, t02, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert_dev(target, t12, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_dev(target, t22, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert_dev(target, t32, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert_dev(target, t4, anchor);
      if (after_slot) {
        after_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (before_slot) {
        if (before_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            before_slot,
            before_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              before_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              get_before_slot_changes
            ),
            get_before_slot_context
          );
        }
      }
      if (
        /*showZoom*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*showZoom*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t12.parentNode, t12);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*showFitView*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*showFitView*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t22.parentNode, t22);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*showLock*/
        ctx2[3]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*showLock*/
          8) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block10(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t32.parentNode, t32);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              get_after_slot_changes
            ),
            get_after_slot_context
          );
        }
      }
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(before_slot, local2);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(default_slot, local2);
      transition_in(after_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(before_slot, local2);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(default_slot, local2);
      transition_out(after_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t02);
        detach_dev(t12);
        detach_dev(t22);
        detach_dev(t32);
        detach_dev(t4);
      }
      if (before_slot) before_slot.d(detaching);
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (if_block2) if_block2.d(detaching);
      if (default_slot) default_slot.d(detaching);
      if (after_slot) after_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: `(54:0) <Panel   class={cc(['svelte-flow__controls', orientationClass, className])}   {position}   data-testid=\\"svelte-flow__controls\\"   aria-label={ariaLabel ?? 'Svelte Flow controls'}   {style} >`,
    ctx
  });
  return block;
}
function create_fragment43(ctx) {
  let panel;
  let current;
  panel = new Panel_default({
    props: {
      class: cc([
        "svelte-flow__controls",
        /*orientationClass*/
        ctx[7],
        /*className*/
        ctx[6]
      ]),
      position: (
        /*position*/
        ctx[0]
      ),
      "data-testid": "svelte-flow__controls",
      "aria-label": (
        /*ariaLabel*/
        ctx[4] ?? "Svelte Flow controls"
      ),
      style: (
        /*style*/
        ctx[5]
      ),
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(panel.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(panel, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const panel_changes = {};
      if (dirty[0] & /*orientationClass, className*/
      192) panel_changes.class = cc([
        "svelte-flow__controls",
        /*orientationClass*/
        ctx2[7],
        /*className*/
        ctx2[6]
      ]);
      if (dirty[0] & /*position*/
      1) panel_changes.position = /*position*/
      ctx2[0];
      if (dirty[0] & /*ariaLabel*/
      16) panel_changes["aria-label"] = /*ariaLabel*/
      ctx2[4] ?? "Svelte Flow controls";
      if (dirty[0] & /*style*/
      32) panel_changes.style = /*style*/
      ctx2[5];
      if (dirty[0] & /*isInteractive, showLock, showFitView, minZoomReached, maxZoomReached, showZoom*/
      1806 | dirty[1] & /*$$scope*/
      32) {
        panel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel.$set(panel_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(panel.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(panel.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(panel, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment43.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance43($$self, $$props, $$invalidate) {
  let isInteractive;
  let minZoomReached;
  let maxZoomReached;
  let orientationClass;
  let $maxZoom;
  let $viewport;
  let $minZoom;
  let $elementsSelectable;
  let $nodesConnectable;
  let $nodesDraggable;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Controls", slots, ["before", "default", "after"]);
  let { position = "bottom-left" } = $$props;
  let { showZoom = true } = $$props;
  let { showFitView = true } = $$props;
  let { showLock = true } = $$props;
  let { buttonBgColor = void 0 } = $$props;
  let { buttonBgColorHover = void 0 } = $$props;
  let { buttonColor = void 0 } = $$props;
  let { buttonColorHover = void 0 } = $$props;
  let { buttonBorderColor = void 0 } = $$props;
  let { ariaLabel = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { orientation = "vertical" } = $$props;
  let { fitViewOptions = void 0 } = $$props;
  let { class: className = "" } = $$props;
  const { zoomIn, zoomOut, fitView: fitView2, viewport, minZoom, maxZoom, nodesDraggable, nodesConnectable, elementsSelectable } = useStore();
  validate_store(viewport, "viewport");
  component_subscribe($$self, viewport, (value) => $$invalidate(30, $viewport = value));
  validate_store(minZoom, "minZoom");
  component_subscribe($$self, minZoom, (value) => $$invalidate(31, $minZoom = value));
  validate_store(maxZoom, "maxZoom");
  component_subscribe($$self, maxZoom, (value) => $$invalidate(29, $maxZoom = value));
  validate_store(nodesDraggable, "nodesDraggable");
  component_subscribe($$self, nodesDraggable, (value) => $$invalidate(34, $nodesDraggable = value));
  validate_store(nodesConnectable, "nodesConnectable");
  component_subscribe($$self, nodesConnectable, (value) => $$invalidate(33, $nodesConnectable = value));
  validate_store(elementsSelectable, "elementsSelectable");
  component_subscribe($$self, elementsSelectable, (value) => $$invalidate(32, $elementsSelectable = value));
  const buttonProps = {
    bgColor: buttonBgColor,
    bgColorHover: buttonBgColorHover,
    color: buttonColor,
    colorHover: buttonColorHover,
    borderColor: buttonBorderColor
  };
  const onZoomInHandler = () => {
    zoomIn();
  };
  const onZoomOutHandler = () => {
    zoomOut();
  };
  const onFitViewHandler = () => {
    fitView2(fitViewOptions);
  };
  const onToggleInteractivity = () => {
    $$invalidate(8, isInteractive = !isInteractive);
    nodesDraggable.set(isInteractive);
    nodesConnectable.set(isInteractive);
    elementsSelectable.set(isInteractive);
  };
  const writable_props = [
    "position",
    "showZoom",
    "showFitView",
    "showLock",
    "buttonBgColor",
    "buttonBgColorHover",
    "buttonColor",
    "buttonColorHover",
    "buttonBorderColor",
    "ariaLabel",
    "style",
    "orientation",
    "fitViewOptions",
    "class"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Controls> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2) $$invalidate(0, position = $$props2.position);
    if ("showZoom" in $$props2) $$invalidate(1, showZoom = $$props2.showZoom);
    if ("showFitView" in $$props2) $$invalidate(2, showFitView = $$props2.showFitView);
    if ("showLock" in $$props2) $$invalidate(3, showLock = $$props2.showLock);
    if ("buttonBgColor" in $$props2) $$invalidate(22, buttonBgColor = $$props2.buttonBgColor);
    if ("buttonBgColorHover" in $$props2) $$invalidate(23, buttonBgColorHover = $$props2.buttonBgColorHover);
    if ("buttonColor" in $$props2) $$invalidate(24, buttonColor = $$props2.buttonColor);
    if ("buttonColorHover" in $$props2) $$invalidate(25, buttonColorHover = $$props2.buttonColorHover);
    if ("buttonBorderColor" in $$props2) $$invalidate(26, buttonBorderColor = $$props2.buttonBorderColor);
    if ("ariaLabel" in $$props2) $$invalidate(4, ariaLabel = $$props2.ariaLabel);
    if ("style" in $$props2) $$invalidate(5, style = $$props2.style);
    if ("orientation" in $$props2) $$invalidate(27, orientation = $$props2.orientation);
    if ("fitViewOptions" in $$props2) $$invalidate(28, fitViewOptions = $$props2.fitViewOptions);
    if ("class" in $$props2) $$invalidate(6, className = $$props2.class);
    if ("$$scope" in $$props2) $$invalidate(36, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    cc,
    Panel: Panel_default,
    useStore,
    ControlButton: ControlButton_default,
    PlusIcon: Plus_default,
    MinusIcon: Minus_default,
    FitViewIcon: Fit_default,
    LockIcon: Lock_default,
    UnlockIcon: Unlock_default,
    position,
    showZoom,
    showFitView,
    showLock,
    buttonBgColor,
    buttonBgColorHover,
    buttonColor,
    buttonColorHover,
    buttonBorderColor,
    ariaLabel,
    style,
    orientation,
    fitViewOptions,
    className,
    zoomIn,
    zoomOut,
    fitView: fitView2,
    viewport,
    minZoom,
    maxZoom,
    nodesDraggable,
    nodesConnectable,
    elementsSelectable,
    buttonProps,
    onZoomInHandler,
    onZoomOutHandler,
    onFitViewHandler,
    onToggleInteractivity,
    orientationClass,
    isInteractive,
    maxZoomReached,
    minZoomReached,
    $maxZoom,
    $viewport,
    $minZoom,
    $elementsSelectable,
    $nodesConnectable,
    $nodesDraggable
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2) $$invalidate(0, position = $$props2.position);
    if ("showZoom" in $$props2) $$invalidate(1, showZoom = $$props2.showZoom);
    if ("showFitView" in $$props2) $$invalidate(2, showFitView = $$props2.showFitView);
    if ("showLock" in $$props2) $$invalidate(3, showLock = $$props2.showLock);
    if ("buttonBgColor" in $$props2) $$invalidate(22, buttonBgColor = $$props2.buttonBgColor);
    if ("buttonBgColorHover" in $$props2) $$invalidate(23, buttonBgColorHover = $$props2.buttonBgColorHover);
    if ("buttonColor" in $$props2) $$invalidate(24, buttonColor = $$props2.buttonColor);
    if ("buttonColorHover" in $$props2) $$invalidate(25, buttonColorHover = $$props2.buttonColorHover);
    if ("buttonBorderColor" in $$props2) $$invalidate(26, buttonBorderColor = $$props2.buttonBorderColor);
    if ("ariaLabel" in $$props2) $$invalidate(4, ariaLabel = $$props2.ariaLabel);
    if ("style" in $$props2) $$invalidate(5, style = $$props2.style);
    if ("orientation" in $$props2) $$invalidate(27, orientation = $$props2.orientation);
    if ("fitViewOptions" in $$props2) $$invalidate(28, fitViewOptions = $$props2.fitViewOptions);
    if ("className" in $$props2) $$invalidate(6, className = $$props2.className);
    if ("orientationClass" in $$props2) $$invalidate(7, orientationClass = $$props2.orientationClass);
    if ("isInteractive" in $$props2) $$invalidate(8, isInteractive = $$props2.isInteractive);
    if ("maxZoomReached" in $$props2) $$invalidate(9, maxZoomReached = $$props2.maxZoomReached);
    if ("minZoomReached" in $$props2) $$invalidate(10, minZoomReached = $$props2.minZoomReached);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & /*$nodesDraggable, $nodesConnectable, $elementsSelectable*/
    14) {
      $: $$invalidate(8, isInteractive = $nodesDraggable || $nodesConnectable || $elementsSelectable);
    }
    if ($$self.$$.dirty[0] & /*$viewport*/
    1073741824 | $$self.$$.dirty[1] & /*$minZoom*/
    1) {
      $: $$invalidate(10, minZoomReached = $viewport.zoom <= $minZoom);
    }
    if ($$self.$$.dirty[0] & /*$viewport, $maxZoom*/
    1610612736) {
      $: $$invalidate(9, maxZoomReached = $viewport.zoom >= $maxZoom);
    }
    if ($$self.$$.dirty[0] & /*orientation*/
    134217728) {
      $: $$invalidate(7, orientationClass = orientation === "horizontal" ? "horizontal" : "vertical");
    }
  };
  return [
    position,
    showZoom,
    showFitView,
    showLock,
    ariaLabel,
    style,
    className,
    orientationClass,
    isInteractive,
    maxZoomReached,
    minZoomReached,
    viewport,
    minZoom,
    maxZoom,
    nodesDraggable,
    nodesConnectable,
    elementsSelectable,
    buttonProps,
    onZoomInHandler,
    onZoomOutHandler,
    onFitViewHandler,
    onToggleInteractivity,
    buttonBgColor,
    buttonBgColorHover,
    buttonColor,
    buttonColorHover,
    buttonBorderColor,
    orientation,
    fitViewOptions,
    $maxZoom,
    $viewport,
    $minZoom,
    $elementsSelectable,
    $nodesConnectable,
    $nodesDraggable,
    slots,
    $$scope
  ];
}
var Controls = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance43,
      create_fragment43,
      safe_not_equal,
      {
        position: 0,
        showZoom: 1,
        showFitView: 2,
        showLock: 3,
        buttonBgColor: 22,
        buttonBgColorHover: 23,
        buttonColor: 24,
        buttonColorHover: 25,
        buttonBorderColor: 26,
        ariaLabel: 4,
        style: 5,
        orientation: 27,
        fitViewOptions: 28,
        class: 6
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Controls",
      options,
      id: create_fragment43.name
    });
  }
  get position() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showZoom() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showZoom(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showFitView() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showFitView(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showLock() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showLock(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonBgColor() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonBgColor(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonBgColorHover() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonBgColorHover(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonColor() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonColor(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonColorHover() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonColorHover(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonBorderColor() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonBorderColor(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabel() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orientation() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orientation(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fitViewOptions() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fitViewOptions(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Controls_default = Controls;

// node_modules/@xyflow/svelte/dist/lib/plugins/Background/types.js
var BackgroundVariant;
(function(BackgroundVariant2) {
  BackgroundVariant2["Lines"] = "lines";
  BackgroundVariant2["Dots"] = "dots";
  BackgroundVariant2["Cross"] = "cross";
})(BackgroundVariant || (BackgroundVariant = {}));

// node_modules/@xyflow/svelte/dist/lib/plugins/Background/DotPattern.svelte
var file27 = "node_modules/@xyflow/svelte/dist/lib/plugins/Background/DotPattern.svelte";
function create_fragment44(ctx) {
  let circle;
  let circle_class_value;
  const block = {
    c: function create2() {
      circle = svg_element("circle");
      attr_dev(
        circle,
        "cx",
        /*radius*/
        ctx[0]
      );
      attr_dev(
        circle,
        "cy",
        /*radius*/
        ctx[0]
      );
      attr_dev(
        circle,
        "r",
        /*radius*/
        ctx[0]
      );
      attr_dev(circle, "class", circle_class_value = cc([
        "svelte-flow__background-pattern",
        "dots",
        /*className*/
        ctx[1]
      ]));
      add_location(circle, file27, 6, 0, 120);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, circle, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*radius*/
      1) {
        attr_dev(
          circle,
          "cx",
          /*radius*/
          ctx2[0]
        );
      }
      if (dirty & /*radius*/
      1) {
        attr_dev(
          circle,
          "cy",
          /*radius*/
          ctx2[0]
        );
      }
      if (dirty & /*radius*/
      1) {
        attr_dev(
          circle,
          "r",
          /*radius*/
          ctx2[0]
        );
      }
      if (dirty & /*className*/
      2 && circle_class_value !== (circle_class_value = cc([
        "svelte-flow__background-pattern",
        "dots",
        /*className*/
        ctx2[1]
      ]))) {
        attr_dev(circle, "class", circle_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(circle);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment44.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance44($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DotPattern", slots, []);
  let { radius = 5 } = $$props;
  let { class: className = "" } = $$props;
  const writable_props = ["radius", "class"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<DotPattern> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("radius" in $$props2) $$invalidate(0, radius = $$props2.radius);
    if ("class" in $$props2) $$invalidate(1, className = $$props2.class);
  };
  $$self.$capture_state = () => ({ cc, radius, className });
  $$self.$inject_state = ($$props2) => {
    if ("radius" in $$props2) $$invalidate(0, radius = $$props2.radius);
    if ("className" in $$props2) $$invalidate(1, className = $$props2.className);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [radius, className];
}
var DotPattern = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance44, create_fragment44, safe_not_equal, { radius: 0, class: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DotPattern",
      options,
      id: create_fragment44.name
    });
  }
  get radius() {
    throw new Error("<DotPattern>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<DotPattern>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<DotPattern>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DotPattern>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DotPattern_default = DotPattern;

// node_modules/@xyflow/svelte/dist/lib/plugins/Background/LinePattern.svelte
var file28 = "node_modules/@xyflow/svelte/dist/lib/plugins/Background/LinePattern.svelte";
function create_fragment45(ctx) {
  let path;
  let path_d_value;
  let path_class_value;
  const block = {
    c: function create2() {
      path = svg_element("path");
      attr_dev(
        path,
        "stroke-width",
        /*lineWidth*/
        ctx[0]
      );
      attr_dev(path, "d", path_d_value = `M${/*dimensions*/
      ctx[1][0] / 2} 0 V${/*dimensions*/
      ctx[1][1]} M0 ${/*dimensions*/
      ctx[1][1] / 2} H${/*dimensions*/
      ctx[1][0]}`);
      attr_dev(path, "class", path_class_value = cc([
        "svelte-flow__background-pattern",
        /*variant*/
        ctx[2],
        /*className*/
        ctx[3]
      ]));
      add_location(path, file28, 8, 0, 178);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, path, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*lineWidth*/
      1) {
        attr_dev(
          path,
          "stroke-width",
          /*lineWidth*/
          ctx2[0]
        );
      }
      if (dirty & /*dimensions*/
      2 && path_d_value !== (path_d_value = `M${/*dimensions*/
      ctx2[1][0] / 2} 0 V${/*dimensions*/
      ctx2[1][1]} M0 ${/*dimensions*/
      ctx2[1][1] / 2} H${/*dimensions*/
      ctx2[1][0]}`)) {
        attr_dev(path, "d", path_d_value);
      }
      if (dirty & /*variant, className*/
      12 && path_class_value !== (path_class_value = cc([
        "svelte-flow__background-pattern",
        /*variant*/
        ctx2[2],
        /*className*/
        ctx2[3]
      ]))) {
        attr_dev(path, "class", path_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment45.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance45($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LinePattern", slots, []);
  let { lineWidth = 1 } = $$props;
  let { dimensions } = $$props;
  let { variant = void 0 } = $$props;
  let { class: className = "" } = $$props;
  $$self.$$.on_mount.push(function() {
    if (dimensions === void 0 && !("dimensions" in $$props || $$self.$$.bound[$$self.$$.props["dimensions"]])) {
      console.warn("<LinePattern> was created without expected prop 'dimensions'");
    }
  });
  const writable_props = ["lineWidth", "dimensions", "variant", "class"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<LinePattern> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("lineWidth" in $$props2) $$invalidate(0, lineWidth = $$props2.lineWidth);
    if ("dimensions" in $$props2) $$invalidate(1, dimensions = $$props2.dimensions);
    if ("variant" in $$props2) $$invalidate(2, variant = $$props2.variant);
    if ("class" in $$props2) $$invalidate(3, className = $$props2.class);
  };
  $$self.$capture_state = () => ({
    cc,
    lineWidth,
    dimensions,
    variant,
    className
  });
  $$self.$inject_state = ($$props2) => {
    if ("lineWidth" in $$props2) $$invalidate(0, lineWidth = $$props2.lineWidth);
    if ("dimensions" in $$props2) $$invalidate(1, dimensions = $$props2.dimensions);
    if ("variant" in $$props2) $$invalidate(2, variant = $$props2.variant);
    if ("className" in $$props2) $$invalidate(3, className = $$props2.className);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [lineWidth, dimensions, variant, className];
}
var LinePattern = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance45, create_fragment45, safe_not_equal, {
      lineWidth: 0,
      dimensions: 1,
      variant: 2,
      class: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LinePattern",
      options,
      id: create_fragment45.name
    });
  }
  get lineWidth() {
    throw new Error("<LinePattern>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineWidth(value) {
    throw new Error("<LinePattern>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dimensions() {
    throw new Error("<LinePattern>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dimensions(value) {
    throw new Error("<LinePattern>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<LinePattern>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<LinePattern>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<LinePattern>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<LinePattern>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LinePattern_default = LinePattern;

// node_modules/@xyflow/svelte/dist/lib/plugins/Background/Background.svelte
var file29 = "node_modules/@xyflow/svelte/dist/lib/plugins/Background/Background.svelte";
function add_css8(target) {
  append_styles(target, "svelte-1r7pe8d", ".svelte-flow__background.svelte-1r7pe8d{position:absolute;width:100%;height:100%;top:0;left:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmFja2dyb3VuZC5zdmVsdGUiLCJzb3VyY2VzIjpbIkJhY2tncm91bmQuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQgbGFiZz1cInRzXCIgY29udGV4dD1cIm1vZHVsZVwiPlxuICBjb25zdCBkZWZhdWx0U2l6ZSA9IHtcbiAgICBbQmFja2dyb3VuZFZhcmlhbnQuRG90c106IDEsXG4gICAgW0JhY2tncm91bmRWYXJpYW50LkxpbmVzXTogMSxcbiAgICBbQmFja2dyb3VuZFZhcmlhbnQuQ3Jvc3NdOiA2XG4gIH07XG48L3NjcmlwdD5cblxuPHNjcmlwdD5pbXBvcnQgY2MgZnJvbSAnY2xhc3NjYXQnO1xuaW1wb3J0IERvdFBhdHRlcm4gZnJvbSAnLi9Eb3RQYXR0ZXJuLnN2ZWx0ZSc7XG5pbXBvcnQgTGluZVBhdHRlcm4gZnJvbSAnLi9MaW5lUGF0dGVybi5zdmVsdGUnO1xuaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICcuLi8uLi9zdG9yZSc7XG5pbXBvcnQgeyBCYWNrZ3JvdW5kVmFyaWFudCB9IGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0IGxldCBpZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgdmFyaWFudCA9IEJhY2tncm91bmRWYXJpYW50LkRvdHM7XG5leHBvcnQgbGV0IGdhcCA9IDIwO1xuZXhwb3J0IGxldCBzaXplID0gMTtcbmV4cG9ydCBsZXQgbGluZVdpZHRoID0gMTtcbmV4cG9ydCBsZXQgYmdDb2xvciA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgcGF0dGVybkNvbG9yID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBwYXR0ZXJuQ2xhc3MgPSB1bmRlZmluZWQ7XG5sZXQgY2xhc3NOYW1lID0gJyc7XG5leHBvcnQgeyBjbGFzc05hbWUgYXMgY2xhc3MgfTtcbmNvbnN0IHsgdmlld3BvcnQsIGZsb3dJZCB9ID0gdXNlU3RvcmUoKTtcbmNvbnN0IHBhdHRlcm5TaXplID0gc2l6ZSB8fCBkZWZhdWx0U2l6ZVt2YXJpYW50XTtcbmNvbnN0IGlzRG90cyA9IHZhcmlhbnQgPT09IEJhY2tncm91bmRWYXJpYW50LkRvdHM7XG5jb25zdCBpc0Nyb3NzID0gdmFyaWFudCA9PT0gQmFja2dyb3VuZFZhcmlhbnQuQ3Jvc3M7XG5jb25zdCBnYXBYWSA9IEFycmF5LmlzQXJyYXkoZ2FwKSA/IGdhcCA6IFtnYXAsIGdhcF07XG4kOiBwYXR0ZXJuSWQgPSBgYmFja2dyb3VuZC1wYXR0ZXJuLSR7JGZsb3dJZH0tJHtpZCA/IGlkIDogJyd9YDtcbiQ6IHNjYWxlZEdhcCA9IFtnYXBYWVswXSAqICR2aWV3cG9ydC56b29tIHx8IDEsIGdhcFhZWzFdICogJHZpZXdwb3J0Lnpvb20gfHwgMV07XG4kOiBzY2FsZWRTaXplID0gcGF0dGVyblNpemUgKiAkdmlld3BvcnQuem9vbTtcbiQ6IHBhdHRlcm5EaW1lbnNpb25zID0gKGlzQ3Jvc3MgPyBbc2NhbGVkU2l6ZSwgc2NhbGVkU2l6ZV0gOiBzY2FsZWRHYXApO1xuJDogcGF0dGVybk9mZnNldCA9IGlzRG90c1xuICAgID8gW3NjYWxlZFNpemUgLyAyLCBzY2FsZWRTaXplIC8gMl1cbiAgICA6IFtwYXR0ZXJuRGltZW5zaW9uc1swXSAvIDIsIHBhdHRlcm5EaW1lbnNpb25zWzFdIC8gMl07XG48L3NjcmlwdD5cblxuPHN2Z1xuICBjbGFzcz17Y2MoWydzdmVsdGUtZmxvd19fYmFja2dyb3VuZCcsIGNsYXNzTmFtZV0pfVxuICBkYXRhLXRlc3RpZD1cInN2ZWx0ZS1mbG93X19iYWNrZ3JvdW5kXCJcbiAgc3R5bGU6LS14eS1iYWNrZ3JvdW5kLWNvbG9yLXByb3BzPXtiZ0NvbG9yfVxuICBzdHlsZTotLXh5LWJhY2tncm91bmQtcGF0dGVybi1jb2xvci1wcm9wcz17cGF0dGVybkNvbG9yfVxuPlxuICA8cGF0dGVyblxuICAgIGlkPXtwYXR0ZXJuSWR9XG4gICAgeD17JHZpZXdwb3J0LnggJSBzY2FsZWRHYXBbMF19XG4gICAgeT17JHZpZXdwb3J0LnkgJSBzY2FsZWRHYXBbMV19XG4gICAgd2lkdGg9e3NjYWxlZEdhcFswXX1cbiAgICBoZWlnaHQ9e3NjYWxlZEdhcFsxXX1cbiAgICBwYXR0ZXJuVW5pdHM9XCJ1c2VyU3BhY2VPblVzZVwiXG4gICAgcGF0dGVyblRyYW5zZm9ybT17YHRyYW5zbGF0ZSgtJHtwYXR0ZXJuT2Zmc2V0WzBdfSwtJHtwYXR0ZXJuT2Zmc2V0WzFdfSlgfVxuICA+XG4gICAgeyNpZiBpc0RvdHN9XG4gICAgICA8RG90UGF0dGVybiByYWRpdXM9e3NjYWxlZFNpemUgLyAyfSBjbGFzcz17cGF0dGVybkNsYXNzfSAvPlxuICAgIHs6ZWxzZX1cbiAgICAgIDxMaW5lUGF0dGVybiBkaW1lbnNpb25zPXtwYXR0ZXJuRGltZW5zaW9uc30ge3ZhcmlhbnR9IHtsaW5lV2lkdGh9IGNsYXNzPXtwYXR0ZXJuQ2xhc3N9IC8+XG4gICAgey9pZn1cbiAgPC9wYXR0ZXJuPlxuICA8cmVjdCB4PVwiMFwiIHk9XCIwXCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiIGZpbGw9e2B1cmwoIyR7cGF0dGVybklkfSlgfSAvPlxuPC9zdmc+XG5cbjxzdHlsZT5cbiAgLnN2ZWx0ZS1mbG93X19iYWNrZ3JvdW5kIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIHRvcDogMDtcbiAgICBsZWZ0OiAwO1xuICB9XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQThERSx1Q0FBeUIsQ0FDdkIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLEdBQUcsQ0FBRSxDQUFDLENBQ04sSUFBSSxDQUFFLENBQ1IifQ== */");
}
function create_else_block2(ctx) {
  let linepattern;
  let current;
  linepattern = new LinePattern_default({
    props: {
      dimensions: (
        /*patternDimensions*/
        ctx[6]
      ),
      variant: (
        /*variant*/
        ctx[0]
      ),
      lineWidth: (
        /*lineWidth*/
        ctx[1]
      ),
      class: (
        /*patternClass*/
        ctx[4]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(linepattern.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(linepattern, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const linepattern_changes = {};
      if (dirty & /*patternDimensions*/
      64) linepattern_changes.dimensions = /*patternDimensions*/
      ctx2[6];
      if (dirty & /*variant*/
      1) linepattern_changes.variant = /*variant*/
      ctx2[0];
      if (dirty & /*lineWidth*/
      2) linepattern_changes.lineWidth = /*lineWidth*/
      ctx2[1];
      if (dirty & /*patternClass*/
      16) linepattern_changes.class = /*patternClass*/
      ctx2[4];
      linepattern.$set(linepattern_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(linepattern.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(linepattern.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(linepattern, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(55:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block11(ctx) {
  let dotpattern;
  let current;
  dotpattern = new DotPattern_default({
    props: {
      radius: (
        /*scaledSize*/
        ctx[7] / 2
      ),
      class: (
        /*patternClass*/
        ctx[4]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(dotpattern.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(dotpattern, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const dotpattern_changes = {};
      if (dirty & /*scaledSize*/
      128) dotpattern_changes.radius = /*scaledSize*/
      ctx2[7] / 2;
      if (dirty & /*patternClass*/
      16) dotpattern_changes.class = /*patternClass*/
      ctx2[4];
      dotpattern.$set(dotpattern_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(dotpattern.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(dotpattern.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(dotpattern, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block11.name,
    type: "if",
    source: "(53:4) {#if isDots}",
    ctx
  });
  return block;
}
function create_fragment46(ctx) {
  let svg;
  let pattern;
  let current_block_type_index;
  let if_block;
  let pattern_x_value;
  let pattern_y_value;
  let pattern_width_value;
  let pattern_height_value;
  let pattern_patternTransform_value;
  let rect;
  let rect_fill_value;
  let svg_class_value;
  let current;
  const if_block_creators = [create_if_block11, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*isDots*/
      ctx2[14]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create2() {
      svg = svg_element("svg");
      pattern = svg_element("pattern");
      if_block.c();
      rect = svg_element("rect");
      attr_dev(
        pattern,
        "id",
        /*patternId*/
        ctx[11]
      );
      attr_dev(pattern, "x", pattern_x_value = /*$viewport*/
      ctx[9].x % /*scaledGap*/
      ctx[8][0]);
      attr_dev(pattern, "y", pattern_y_value = /*$viewport*/
      ctx[9].y % /*scaledGap*/
      ctx[8][1]);
      attr_dev(pattern, "width", pattern_width_value = /*scaledGap*/
      ctx[8][0]);
      attr_dev(pattern, "height", pattern_height_value = /*scaledGap*/
      ctx[8][1]);
      attr_dev(pattern, "patternUnits", "userSpaceOnUse");
      attr_dev(pattern, "patternTransform", pattern_patternTransform_value = `translate(-${/*patternOffset*/
      ctx[10][0]},-${/*patternOffset*/
      ctx[10][1]})`);
      add_location(pattern, file29, 43, 2, 1542);
      attr_dev(rect, "x", "0");
      attr_dev(rect, "y", "0");
      attr_dev(rect, "width", "100%");
      attr_dev(rect, "height", "100%");
      attr_dev(rect, "fill", rect_fill_value = `url(#${/*patternId*/
      ctx[11]})`);
      add_location(rect, file29, 58, 2, 2023);
      attr_dev(svg, "class", svg_class_value = null_to_empty(cc([
        "svelte-flow__background",
        /*className*/
        ctx[5]
      ])) + " svelte-1r7pe8d");
      attr_dev(svg, "data-testid", "svelte-flow__background");
      set_style(
        svg,
        "--xy-background-color-props",
        /*bgColor*/
        ctx[2]
      );
      set_style(
        svg,
        "--xy-background-pattern-color-props",
        /*patternColor*/
        ctx[3]
      );
      add_location(svg, file29, 37, 0, 1335);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, pattern);
      if_blocks[current_block_type_index].m(pattern, null);
      append_dev(svg, rect);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if_block.p(ctx2, dirty);
      if (!current || dirty & /*patternId*/
      2048) {
        attr_dev(
          pattern,
          "id",
          /*patternId*/
          ctx2[11]
        );
      }
      if (!current || dirty & /*$viewport, scaledGap*/
      768 && pattern_x_value !== (pattern_x_value = /*$viewport*/
      ctx2[9].x % /*scaledGap*/
      ctx2[8][0])) {
        attr_dev(pattern, "x", pattern_x_value);
      }
      if (!current || dirty & /*$viewport, scaledGap*/
      768 && pattern_y_value !== (pattern_y_value = /*$viewport*/
      ctx2[9].y % /*scaledGap*/
      ctx2[8][1])) {
        attr_dev(pattern, "y", pattern_y_value);
      }
      if (!current || dirty & /*scaledGap*/
      256 && pattern_width_value !== (pattern_width_value = /*scaledGap*/
      ctx2[8][0])) {
        attr_dev(pattern, "width", pattern_width_value);
      }
      if (!current || dirty & /*scaledGap*/
      256 && pattern_height_value !== (pattern_height_value = /*scaledGap*/
      ctx2[8][1])) {
        attr_dev(pattern, "height", pattern_height_value);
      }
      if (!current || dirty & /*patternOffset*/
      1024 && pattern_patternTransform_value !== (pattern_patternTransform_value = `translate(-${/*patternOffset*/
      ctx2[10][0]},-${/*patternOffset*/
      ctx2[10][1]})`)) {
        attr_dev(pattern, "patternTransform", pattern_patternTransform_value);
      }
      if (!current || dirty & /*patternId*/
      2048 && rect_fill_value !== (rect_fill_value = `url(#${/*patternId*/
      ctx2[11]})`)) {
        attr_dev(rect, "fill", rect_fill_value);
      }
      if (!current || dirty & /*className*/
      32 && svg_class_value !== (svg_class_value = null_to_empty(cc([
        "svelte-flow__background",
        /*className*/
        ctx2[5]
      ])) + " svelte-1r7pe8d")) {
        attr_dev(svg, "class", svg_class_value);
      }
      if (dirty & /*bgColor*/
      4) {
        set_style(
          svg,
          "--xy-background-color-props",
          /*bgColor*/
          ctx2[2]
        );
      }
      if (dirty & /*patternColor*/
      8) {
        set_style(
          svg,
          "--xy-background-pattern-color-props",
          /*patternColor*/
          ctx2[3]
        );
      }
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment46.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var defaultSize = {
  [BackgroundVariant.Dots]: 1,
  [BackgroundVariant.Lines]: 1,
  [BackgroundVariant.Cross]: 6
};
function instance46($$self, $$props, $$invalidate) {
  let patternId;
  let scaledGap;
  let scaledSize;
  let patternDimensions;
  let patternOffset;
  let $viewport;
  let $flowId;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Background", slots, []);
  let { id: id2 = void 0 } = $$props;
  let { variant = BackgroundVariant.Dots } = $$props;
  let { gap = 20 } = $$props;
  let { size = 1 } = $$props;
  let { lineWidth = 1 } = $$props;
  let { bgColor = void 0 } = $$props;
  let { patternColor = void 0 } = $$props;
  let { patternClass = void 0 } = $$props;
  let { class: className = "" } = $$props;
  const { viewport, flowId } = useStore();
  validate_store(viewport, "viewport");
  component_subscribe($$self, viewport, (value) => $$invalidate(9, $viewport = value));
  validate_store(flowId, "flowId");
  component_subscribe($$self, flowId, (value) => $$invalidate(18, $flowId = value));
  const patternSize = size || defaultSize[variant];
  const isDots = variant === BackgroundVariant.Dots;
  const isCross = variant === BackgroundVariant.Cross;
  const gapXY = Array.isArray(gap) ? gap : [gap, gap];
  const writable_props = [
    "id",
    "variant",
    "gap",
    "size",
    "lineWidth",
    "bgColor",
    "patternColor",
    "patternClass",
    "class"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Background> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2) $$invalidate(15, id2 = $$props2.id);
    if ("variant" in $$props2) $$invalidate(0, variant = $$props2.variant);
    if ("gap" in $$props2) $$invalidate(16, gap = $$props2.gap);
    if ("size" in $$props2) $$invalidate(17, size = $$props2.size);
    if ("lineWidth" in $$props2) $$invalidate(1, lineWidth = $$props2.lineWidth);
    if ("bgColor" in $$props2) $$invalidate(2, bgColor = $$props2.bgColor);
    if ("patternColor" in $$props2) $$invalidate(3, patternColor = $$props2.patternColor);
    if ("patternClass" in $$props2) $$invalidate(4, patternClass = $$props2.patternClass);
    if ("class" in $$props2) $$invalidate(5, className = $$props2.class);
  };
  $$self.$capture_state = () => ({
    defaultSize,
    cc,
    DotPattern: DotPattern_default,
    LinePattern: LinePattern_default,
    useStore,
    BackgroundVariant,
    id: id2,
    variant,
    gap,
    size,
    lineWidth,
    bgColor,
    patternColor,
    patternClass,
    className,
    viewport,
    flowId,
    patternSize,
    isDots,
    isCross,
    gapXY,
    patternDimensions,
    scaledSize,
    patternOffset,
    scaledGap,
    patternId,
    $viewport,
    $flowId
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2) $$invalidate(15, id2 = $$props2.id);
    if ("variant" in $$props2) $$invalidate(0, variant = $$props2.variant);
    if ("gap" in $$props2) $$invalidate(16, gap = $$props2.gap);
    if ("size" in $$props2) $$invalidate(17, size = $$props2.size);
    if ("lineWidth" in $$props2) $$invalidate(1, lineWidth = $$props2.lineWidth);
    if ("bgColor" in $$props2) $$invalidate(2, bgColor = $$props2.bgColor);
    if ("patternColor" in $$props2) $$invalidate(3, patternColor = $$props2.patternColor);
    if ("patternClass" in $$props2) $$invalidate(4, patternClass = $$props2.patternClass);
    if ("className" in $$props2) $$invalidate(5, className = $$props2.className);
    if ("patternDimensions" in $$props2) $$invalidate(6, patternDimensions = $$props2.patternDimensions);
    if ("scaledSize" in $$props2) $$invalidate(7, scaledSize = $$props2.scaledSize);
    if ("patternOffset" in $$props2) $$invalidate(10, patternOffset = $$props2.patternOffset);
    if ("scaledGap" in $$props2) $$invalidate(8, scaledGap = $$props2.scaledGap);
    if ("patternId" in $$props2) $$invalidate(11, patternId = $$props2.patternId);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$flowId, id*/
    294912) {
      $: $$invalidate(11, patternId = `background-pattern-${$flowId}-${id2 ? id2 : ""}`);
    }
    if ($$self.$$.dirty & /*$viewport*/
    512) {
      $: $$invalidate(8, scaledGap = [gapXY[0] * $viewport.zoom || 1, gapXY[1] * $viewport.zoom || 1]);
    }
    if ($$self.$$.dirty & /*$viewport*/
    512) {
      $: $$invalidate(7, scaledSize = patternSize * $viewport.zoom);
    }
    if ($$self.$$.dirty & /*scaledSize, scaledGap*/
    384) {
      $: $$invalidate(6, patternDimensions = isCross ? [scaledSize, scaledSize] : scaledGap);
    }
    if ($$self.$$.dirty & /*scaledSize, patternDimensions*/
    192) {
      $: $$invalidate(10, patternOffset = isDots ? [scaledSize / 2, scaledSize / 2] : [patternDimensions[0] / 2, patternDimensions[1] / 2]);
    }
  };
  return [
    variant,
    lineWidth,
    bgColor,
    patternColor,
    patternClass,
    className,
    patternDimensions,
    scaledSize,
    scaledGap,
    $viewport,
    patternOffset,
    patternId,
    viewport,
    flowId,
    isDots,
    id2,
    gap,
    size,
    $flowId
  ];
}
var Background = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance46,
      create_fragment46,
      safe_not_equal,
      {
        id: 15,
        variant: 0,
        gap: 16,
        size: 17,
        lineWidth: 1,
        bgColor: 2,
        patternColor: 3,
        patternClass: 4,
        class: 5
      },
      add_css8
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Background",
      options,
      id: create_fragment46.name
    });
  }
  get id() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gap() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gap(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineWidth() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineWidth(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgColor() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get patternColor() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set patternColor(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get patternClass() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set patternClass(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Background>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Background>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Background_default = Background;

// node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/MinimapNode.svelte
var file30 = "node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/MinimapNode.svelte";
function create_fragment47(ctx) {
  let rect;
  let rect_class_value;
  let rect_style_value;
  const block = {
    c: function create2() {
      rect = svg_element("rect");
      attr_dev(rect, "class", rect_class_value = cc([
        "svelte-flow__minimap-node",
        /*className*/
        ctx[10]
      ]));
      attr_dev(
        rect,
        "x",
        /*x*/
        ctx[0]
      );
      attr_dev(
        rect,
        "y",
        /*y*/
        ctx[1]
      );
      attr_dev(
        rect,
        "rx",
        /*borderRadius*/
        ctx[4]
      );
      attr_dev(
        rect,
        "ry",
        /*borderRadius*/
        ctx[4]
      );
      attr_dev(
        rect,
        "width",
        /*width*/
        ctx[2]
      );
      attr_dev(
        rect,
        "height",
        /*height*/
        ctx[3]
      );
      attr_dev(rect, "style", rect_style_value = `${/*color*/
      ctx[5] ? `fill: ${/*color*/
      ctx[5]};` : ""}${/*strokeColor*/
      ctx[7] ? `stroke: ${/*strokeColor*/
      ctx[7]};` : ""}${/*strokeWidth*/
      ctx[8] ? `stroke-width: ${/*strokeWidth*/
      ctx[8]};` : ""}`);
      attr_dev(
        rect,
        "shape-rendering",
        /*shapeRendering*/
        ctx[6]
      );
      toggle_class(
        rect,
        "selected",
        /*selected*/
        ctx[9]
      );
      add_location(rect, file30, 15, 0, 349);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, rect, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*className*/
      1024 && rect_class_value !== (rect_class_value = cc([
        "svelte-flow__minimap-node",
        /*className*/
        ctx2[10]
      ]))) {
        attr_dev(rect, "class", rect_class_value);
      }
      if (dirty & /*x*/
      1) {
        attr_dev(
          rect,
          "x",
          /*x*/
          ctx2[0]
        );
      }
      if (dirty & /*y*/
      2) {
        attr_dev(
          rect,
          "y",
          /*y*/
          ctx2[1]
        );
      }
      if (dirty & /*borderRadius*/
      16) {
        attr_dev(
          rect,
          "rx",
          /*borderRadius*/
          ctx2[4]
        );
      }
      if (dirty & /*borderRadius*/
      16) {
        attr_dev(
          rect,
          "ry",
          /*borderRadius*/
          ctx2[4]
        );
      }
      if (dirty & /*width*/
      4) {
        attr_dev(
          rect,
          "width",
          /*width*/
          ctx2[2]
        );
      }
      if (dirty & /*height*/
      8) {
        attr_dev(
          rect,
          "height",
          /*height*/
          ctx2[3]
        );
      }
      if (dirty & /*color, strokeColor, strokeWidth*/
      416 && rect_style_value !== (rect_style_value = `${/*color*/
      ctx2[5] ? `fill: ${/*color*/
      ctx2[5]};` : ""}${/*strokeColor*/
      ctx2[7] ? `stroke: ${/*strokeColor*/
      ctx2[7]};` : ""}${/*strokeWidth*/
      ctx2[8] ? `stroke-width: ${/*strokeWidth*/
      ctx2[8]};` : ""}`)) {
        attr_dev(rect, "style", rect_style_value);
      }
      if (dirty & /*shapeRendering*/
      64) {
        attr_dev(
          rect,
          "shape-rendering",
          /*shapeRendering*/
          ctx2[6]
        );
      }
      if (dirty & /*className, selected*/
      1536) {
        toggle_class(
          rect,
          "selected",
          /*selected*/
          ctx2[9]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(rect);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment47.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance47($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MinimapNode", slots, []);
  let { x } = $$props;
  let { y } = $$props;
  let { width = 0 } = $$props;
  let { height = 0 } = $$props;
  let { borderRadius = 5 } = $$props;
  let { color: color2 = void 0 } = $$props;
  let { shapeRendering } = $$props;
  let { strokeColor = void 0 } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { selected = false } = $$props;
  let { class: className = "" } = $$props;
  $$self.$$.on_mount.push(function() {
    if (x === void 0 && !("x" in $$props || $$self.$$.bound[$$self.$$.props["x"]])) {
      console.warn("<MinimapNode> was created without expected prop 'x'");
    }
    if (y === void 0 && !("y" in $$props || $$self.$$.bound[$$self.$$.props["y"]])) {
      console.warn("<MinimapNode> was created without expected prop 'y'");
    }
    if (shapeRendering === void 0 && !("shapeRendering" in $$props || $$self.$$.bound[$$self.$$.props["shapeRendering"]])) {
      console.warn("<MinimapNode> was created without expected prop 'shapeRendering'");
    }
  });
  const writable_props = [
    "x",
    "y",
    "width",
    "height",
    "borderRadius",
    "color",
    "shapeRendering",
    "strokeColor",
    "strokeWidth",
    "selected",
    "class"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<MinimapNode> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x" in $$props2) $$invalidate(0, x = $$props2.x);
    if ("y" in $$props2) $$invalidate(1, y = $$props2.y);
    if ("width" in $$props2) $$invalidate(2, width = $$props2.width);
    if ("height" in $$props2) $$invalidate(3, height = $$props2.height);
    if ("borderRadius" in $$props2) $$invalidate(4, borderRadius = $$props2.borderRadius);
    if ("color" in $$props2) $$invalidate(5, color2 = $$props2.color);
    if ("shapeRendering" in $$props2) $$invalidate(6, shapeRendering = $$props2.shapeRendering);
    if ("strokeColor" in $$props2) $$invalidate(7, strokeColor = $$props2.strokeColor);
    if ("strokeWidth" in $$props2) $$invalidate(8, strokeWidth = $$props2.strokeWidth);
    if ("selected" in $$props2) $$invalidate(9, selected = $$props2.selected);
    if ("class" in $$props2) $$invalidate(10, className = $$props2.class);
  };
  $$self.$capture_state = () => ({
    cc,
    x,
    y,
    width,
    height,
    borderRadius,
    color: color2,
    shapeRendering,
    strokeColor,
    strokeWidth,
    selected,
    className
  });
  $$self.$inject_state = ($$props2) => {
    if ("x" in $$props2) $$invalidate(0, x = $$props2.x);
    if ("y" in $$props2) $$invalidate(1, y = $$props2.y);
    if ("width" in $$props2) $$invalidate(2, width = $$props2.width);
    if ("height" in $$props2) $$invalidate(3, height = $$props2.height);
    if ("borderRadius" in $$props2) $$invalidate(4, borderRadius = $$props2.borderRadius);
    if ("color" in $$props2) $$invalidate(5, color2 = $$props2.color);
    if ("shapeRendering" in $$props2) $$invalidate(6, shapeRendering = $$props2.shapeRendering);
    if ("strokeColor" in $$props2) $$invalidate(7, strokeColor = $$props2.strokeColor);
    if ("strokeWidth" in $$props2) $$invalidate(8, strokeWidth = $$props2.strokeWidth);
    if ("selected" in $$props2) $$invalidate(9, selected = $$props2.selected);
    if ("className" in $$props2) $$invalidate(10, className = $$props2.className);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    x,
    y,
    width,
    height,
    borderRadius,
    color2,
    shapeRendering,
    strokeColor,
    strokeWidth,
    selected,
    className
  ];
}
var MinimapNode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance47, create_fragment47, safe_not_equal, {
      x: 0,
      y: 1,
      width: 2,
      height: 3,
      borderRadius: 4,
      color: 5,
      shapeRendering: 6,
      strokeColor: 7,
      strokeWidth: 8,
      selected: 9,
      class: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MinimapNode",
      options,
      id: create_fragment47.name
    });
  }
  get x() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderRadius() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderRadius(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shapeRendering() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shapeRendering(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeColor() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeColor(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MinimapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MinimapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MinimapNode_default = MinimapNode;

// node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/interactive.js
function interactive(domNode, params) {
  const minimap = XYMinimap({
    domNode,
    panZoom: params.panZoom,
    getTransform: () => {
      const viewport = get_store_value(params.viewport);
      return [viewport.x, viewport.y, viewport.zoom];
    },
    getViewScale: params.getViewScale
  });
  function update(params2) {
    minimap.update({
      translateExtent: params2.translateExtent,
      width: params2.width,
      height: params2.height,
      inversePan: params2.inversePan,
      zoomStep: params2.zoomStep,
      pannable: params2.pannable,
      zoomable: params2.zoomable
    });
  }
  return {
    update,
    destroy() {
      minimap.destroy();
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/Minimap.svelte
var file31 = "node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/Minimap.svelte";
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[55] = list[i];
  const constants_0 = (
    /*$nodeLookup*/
    child_ctx[20].get(
      /*userNode*/
      child_ctx[55].id
    )
  );
  child_ctx[56] = constants_0;
  return child_ctx;
}
function get_if_ctx(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = getNodeDimensions(
    /*node*/
    child_ctx[56]
  );
  child_ctx[59] = constants_0;
  return child_ctx;
}
function create_if_block12(ctx) {
  let svg;
  let if_block_anchor;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let path;
  let path_d_value;
  let svg_viewBox_value;
  let interactive_action;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*ariaLabel*/
    ctx[1] && create_if_block_22(ctx)
  );
  let each_value = ensure_array_like_dev(
    /*$nodes*/
    ctx[19]
  );
  const get_key = (ctx2) => (
    /*userNode*/
    ctx2[55].id
  );
  validate_each_keys(ctx, each_value, get_each_context4, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context4(ctx, each_value, i);
    let key2 = get_key(child_ctx);
    each_1_lookup.set(key2, each_blocks[i] = create_each_block4(key2, child_ctx));
  }
  const block = {
    c: function create2() {
      svg = svg_element("svg");
      if (if_block) if_block.c();
      if_block_anchor = empty();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      path = svg_element("path");
      attr_dev(path, "class", "svelte-flow__minimap-mask");
      attr_dev(path, "d", path_d_value = "M" + /*x*/
      (ctx[26] - /*offset*/
      ctx[15]) + "," + /*y*/
      (ctx[25] - /*offset*/
      ctx[15]) + "h" + /*viewboxWidth*/
      (ctx[24] + /*offset*/
      ctx[15] * 2) + "v" + /*viewboxHeight*/
      (ctx[23] + /*offset*/
      ctx[15] * 2) + "h" + (-/*viewboxWidth*/
      ctx[24] - /*offset*/
      ctx[15] * 2) + "z\n      M" + /*viewBB*/
      ctx[18].x + "," + /*viewBB*/
      ctx[18].y + "h" + /*viewBB*/
      ctx[18].width + "v" + /*viewBB*/
      ctx[18].height + "h" + -/*viewBB*/
      ctx[18].width + "z");
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "pointer-events", "none");
      add_location(path, file31, 120, 6, 4490);
      attr_dev(
        svg,
        "width",
        /*elementWidth*/
        ctx[17]
      );
      attr_dev(
        svg,
        "height",
        /*elementHeight*/
        ctx[16]
      );
      attr_dev(svg, "viewBox", svg_viewBox_value = /*x*/
      ctx[26] + " " + /*y*/
      ctx[25] + " " + /*viewboxWidth*/
      ctx[24] + " " + /*viewboxHeight*/
      ctx[23]);
      attr_dev(svg, "class", "svelte-flow__minimap-svg");
      attr_dev(svg, "role", "img");
      attr_dev(
        svg,
        "aria-labelledby",
        /*labelledBy*/
        ctx[41]
      );
      set_style(
        svg,
        "--xy-minimap-mask-background-color-props",
        /*maskColor*/
        ctx[5]
      );
      set_style(
        svg,
        "--xy-minimap-mask-stroke-color-props",
        /*maskStrokeColor*/
        ctx[6]
      );
      set_style(
        svg,
        "--xy-minimap-mask-stroke-width-props",
        /*maskStrokeWidth*/
        ctx[7] ? (
          /*maskStrokeWidth*/
          ctx[7] * /*viewScale*/
          ctx[14]
        ) : void 0
      );
      add_location(svg, file31, 75, 4, 2975);
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block) if_block.m(svg, null);
      append_dev(svg, if_block_anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(svg, null);
        }
      }
      append_dev(svg, path);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(interactive_action = interactive.call(null, svg, {
          panZoom: (
            /*$panZoom*/
            ctx[27]
          ),
          viewport: (
            /*viewport*/
            ctx[31]
          ),
          getViewScale: (
            /*getViewScale*/
            ctx[42]
          ),
          translateExtent: (
            /*$translateExtent*/
            ctx[28]
          ),
          width: (
            /*$containerWidth*/
            ctx[22]
          ),
          height: (
            /*$containerHeight*/
            ctx[21]
          ),
          inversePan: (
            /*inversePan*/
            ctx[10]
          ),
          zoomStep: (
            /*zoomStep*/
            ctx[11]
          ),
          pannable: (
            /*pannable*/
            ctx[8]
          ),
          zoomable: (
            /*zoomable*/
            ctx[9]
          )
        }));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*ariaLabel*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_22(ctx2);
          if_block.c();
          if_block.m(svg, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*$nodeLookup, $nodes, nodeBorderRadius, nodeStrokeWidth*/
      1572876 | dirty[1] & /*nodeColorFunc, nodeStrokeColorFunc, shapeRendering, nodeClassFunc*/
      960) {
        each_value = ensure_array_like_dev(
          /*$nodes*/
          ctx2[19]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context4, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, svg, outro_and_destroy_block, create_each_block4, path, get_each_context4);
        check_outros();
      }
      if (!current || dirty[0] & /*x, offset, y, viewboxWidth, viewboxHeight, viewBB*/
      126124032 && path_d_value !== (path_d_value = "M" + /*x*/
      (ctx2[26] - /*offset*/
      ctx2[15]) + "," + /*y*/
      (ctx2[25] - /*offset*/
      ctx2[15]) + "h" + /*viewboxWidth*/
      (ctx2[24] + /*offset*/
      ctx2[15] * 2) + "v" + /*viewboxHeight*/
      (ctx2[23] + /*offset*/
      ctx2[15] * 2) + "h" + (-/*viewboxWidth*/
      ctx2[24] - /*offset*/
      ctx2[15] * 2) + "z\n      M" + /*viewBB*/
      ctx2[18].x + "," + /*viewBB*/
      ctx2[18].y + "h" + /*viewBB*/
      ctx2[18].width + "v" + /*viewBB*/
      ctx2[18].height + "h" + -/*viewBB*/
      ctx2[18].width + "z")) {
        attr_dev(path, "d", path_d_value);
      }
      if (!current || dirty[0] & /*elementWidth*/
      131072) {
        attr_dev(
          svg,
          "width",
          /*elementWidth*/
          ctx2[17]
        );
      }
      if (!current || dirty[0] & /*elementHeight*/
      65536) {
        attr_dev(
          svg,
          "height",
          /*elementHeight*/
          ctx2[16]
        );
      }
      if (!current || dirty[0] & /*x, y, viewboxWidth, viewboxHeight*/
      125829120 && svg_viewBox_value !== (svg_viewBox_value = /*x*/
      ctx2[26] + " " + /*y*/
      ctx2[25] + " " + /*viewboxWidth*/
      ctx2[24] + " " + /*viewboxHeight*/
      ctx2[23])) {
        attr_dev(svg, "viewBox", svg_viewBox_value);
      }
      if (interactive_action && is_function(interactive_action.update) && dirty[0] & /*$panZoom, $translateExtent, $containerWidth, $containerHeight, inversePan, zoomStep, pannable, zoomable*/
      408948480) interactive_action.update.call(null, {
        panZoom: (
          /*$panZoom*/
          ctx2[27]
        ),
        viewport: (
          /*viewport*/
          ctx2[31]
        ),
        getViewScale: (
          /*getViewScale*/
          ctx2[42]
        ),
        translateExtent: (
          /*$translateExtent*/
          ctx2[28]
        ),
        width: (
          /*$containerWidth*/
          ctx2[22]
        ),
        height: (
          /*$containerHeight*/
          ctx2[21]
        ),
        inversePan: (
          /*inversePan*/
          ctx2[10]
        ),
        zoomStep: (
          /*zoomStep*/
          ctx2[11]
        ),
        pannable: (
          /*pannable*/
          ctx2[8]
        ),
        zoomable: (
          /*zoomable*/
          ctx2[9]
        )
      });
      if (dirty[0] & /*maskColor*/
      32) {
        set_style(
          svg,
          "--xy-minimap-mask-background-color-props",
          /*maskColor*/
          ctx2[5]
        );
      }
      if (dirty[0] & /*maskStrokeColor*/
      64) {
        set_style(
          svg,
          "--xy-minimap-mask-stroke-color-props",
          /*maskStrokeColor*/
          ctx2[6]
        );
      }
      if (dirty[0] & /*maskStrokeWidth, viewScale*/
      16512) {
        set_style(
          svg,
          "--xy-minimap-mask-stroke-width-props",
          /*maskStrokeWidth*/
          ctx2[7] ? (
            /*maskStrokeWidth*/
            ctx2[7] * /*viewScale*/
            ctx2[14]
          ) : void 0
        );
      }
    },
    i: function intro(local2) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local2) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block) if_block.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block12.name,
    type: "if",
    source: "(75:2) {#if $panZoom}",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let title;
  let t;
  const block = {
    c: function create2() {
      title = svg_element("title");
      t = text(
        /*ariaLabel*/
        ctx[1]
      );
      attr_dev(
        title,
        "id",
        /*labelledBy*/
        ctx[41]
      );
      add_location(title, file31, 100, 21, 3749);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title, anchor);
      append_dev(title, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*ariaLabel*/
      2) set_data_dev(
        t,
        /*ariaLabel*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(101:6) {#if ariaLabel}",
    ctx
  });
  return block;
}
function create_if_block_15(ctx) {
  var _a;
  let minimapnode;
  let current;
  const minimapnode_spread_levels = [
    {
      x: (
        /*node*/
        ctx[56].internals.positionAbsolute.x
      )
    },
    {
      y: (
        /*node*/
        ctx[56].internals.positionAbsolute.y
      )
    },
    /*nodeDimesions*/
    ctx[59],
    { selected: (
      /*node*/
      ctx[56].selected
    ) },
    {
      color: (
        /*nodeColorFunc*/
        (_a = ctx[37]) == null ? void 0 : _a.call(
          ctx,
          /*node*/
          ctx[56]
        )
      )
    },
    {
      borderRadius: (
        /*nodeBorderRadius*/
        ctx[2]
      )
    },
    {
      strokeColor: (
        /*nodeStrokeColorFunc*/
        ctx[38](
          /*node*/
          ctx[56]
        )
      )
    },
    { strokeWidth: (
      /*nodeStrokeWidth*/
      ctx[3]
    ) },
    {
      shapeRendering: (
        /*shapeRendering*/
        ctx[40]
      )
    },
    {
      class: (
        /*nodeClassFunc*/
        ctx[39](
          /*node*/
          ctx[56]
        )
      )
    }
  ];
  let minimapnode_props = {};
  for (let i = 0; i < minimapnode_spread_levels.length; i += 1) {
    minimapnode_props = assign(minimapnode_props, minimapnode_spread_levels[i]);
  }
  minimapnode = new MinimapNode_default({ props: minimapnode_props, $$inline: true });
  const block = {
    c: function create2() {
      create_component(minimapnode.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(minimapnode, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2;
      const minimapnode_changes = dirty[0] & /*$nodeLookup, $nodes, nodeBorderRadius, nodeStrokeWidth*/
      1572876 | dirty[1] & /*nodeColorFunc, nodeStrokeColorFunc, shapeRendering, nodeClassFunc*/
      960 ? get_spread_update(minimapnode_spread_levels, [
        dirty[0] & /*$nodeLookup, $nodes*/
        1572864 && {
          x: (
            /*node*/
            ctx2[56].internals.positionAbsolute.x
          )
        },
        dirty[0] & /*$nodeLookup, $nodes*/
        1572864 && {
          y: (
            /*node*/
            ctx2[56].internals.positionAbsolute.y
          )
        },
        dirty[0] & /*$nodeLookup, $nodes*/
        1572864 && get_spread_object(
          /*nodeDimesions*/
          ctx2[59]
        ),
        dirty[0] & /*$nodeLookup, $nodes*/
        1572864 && { selected: (
          /*node*/
          ctx2[56].selected
        ) },
        dirty[0] & /*$nodeLookup, $nodes*/
        1572864 | dirty[1] & /*nodeColorFunc*/
        64 && {
          color: (
            /*nodeColorFunc*/
            (_a2 = ctx2[37]) == null ? void 0 : _a2.call(
              ctx2,
              /*node*/
              ctx2[56]
            )
          )
        },
        dirty[0] & /*nodeBorderRadius*/
        4 && {
          borderRadius: (
            /*nodeBorderRadius*/
            ctx2[2]
          )
        },
        dirty[0] & /*$nodeLookup, $nodes*/
        1572864 | dirty[1] & /*nodeStrokeColorFunc*/
        128 && {
          strokeColor: (
            /*nodeStrokeColorFunc*/
            ctx2[38](
              /*node*/
              ctx2[56]
            )
          )
        },
        dirty[0] & /*nodeStrokeWidth*/
        8 && { strokeWidth: (
          /*nodeStrokeWidth*/
          ctx2[3]
        ) },
        dirty[1] & /*shapeRendering*/
        512 && {
          shapeRendering: (
            /*shapeRendering*/
            ctx2[40]
          )
        },
        dirty[0] & /*$nodeLookup, $nodes*/
        1572864 | dirty[1] & /*nodeClassFunc*/
        256 && {
          class: (
            /*nodeClassFunc*/
            ctx2[39](
              /*node*/
              ctx2[56]
            )
          )
        }
      ]) : {};
      minimapnode.$set(minimapnode_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(minimapnode.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(minimapnode.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(minimapnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(105:8) {#if node && nodeHasDimensions(node)}",
    ctx
  });
  return block;
}
function create_each_block4(key_1, ctx) {
  let first;
  let show_if = (
    /*node*/
    ctx[56] && nodeHasDimensions(
      /*node*/
      ctx[56]
    )
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_15(get_if_ctx(ctx));
  const block = {
    key: key_1,
    first: null,
    c: function create2() {
      first = empty();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      if (if_block) if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*$nodeLookup, $nodes*/
      1572864) show_if = /*node*/
      ctx[56] && nodeHasDimensions(
        /*node*/
        ctx[56]
      );
      if (show_if) {
        if (if_block) {
          if_block.p(get_if_ctx(ctx), dirty);
          if (dirty[0] & /*$nodeLookup, $nodes*/
          1572864) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_15(get_if_ctx(ctx));
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(103:6) {#each $nodes as userNode (userNode.id)}",
    ctx
  });
  return block;
}
function create_default_slot6(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$panZoom*/
    ctx[27] && create_if_block12(ctx)
  );
  const block = {
    c: function create2() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$panZoom*/
        ctx2[27]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$panZoom*/
          134217728) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block12(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: "(69:0) <Panel   {position}   style={style + (bgColor ? `;--xy-minimap-background-color-props:${bgColor}` : '')}   class={cc(['svelte-flow__minimap', className])}   data-testid=\\\"svelte-flow__minimap\\\" >",
    ctx
  });
  return block;
}
function create_fragment48(ctx) {
  let panel;
  let current;
  panel = new Panel_default({
    props: {
      position: (
        /*position*/
        ctx[0]
      ),
      style: (
        /*style*/
        ctx[12] + /*bgColor*/
        (ctx[4] ? `;--xy-minimap-background-color-props:${/*bgColor*/
        ctx[4]}` : "")
      ),
      class: cc([
        "svelte-flow__minimap",
        /*className*/
        ctx[13]
      ]),
      "data-testid": "svelte-flow__minimap",
      $$slots: { default: [create_default_slot6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(panel.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(panel, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const panel_changes = {};
      if (dirty[0] & /*position*/
      1) panel_changes.position = /*position*/
      ctx2[0];
      if (dirty[0] & /*style, bgColor*/
      4112) panel_changes.style = /*style*/
      ctx2[12] + /*bgColor*/
      (ctx2[4] ? `;--xy-minimap-background-color-props:${/*bgColor*/
      ctx2[4]}` : "");
      if (dirty[0] & /*className*/
      8192) panel_changes.class = cc([
        "svelte-flow__minimap",
        /*className*/
        ctx2[13]
      ]);
      if (dirty[0] & /*elementWidth, elementHeight, x, y, viewboxWidth, viewboxHeight, $panZoom, $translateExtent, $containerWidth, $containerHeight, inversePan, zoomStep, pannable, zoomable, maskColor, maskStrokeColor, maskStrokeWidth, viewScale, offset, viewBB, $nodes, $nodeLookup, nodeBorderRadius, nodeStrokeWidth, ariaLabel*/
      536858606 | dirty[1] & /*$$scope*/
      536870912) {
        panel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel.$set(panel_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(panel.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(panel.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(panel, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment48.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var getAttrFunction = (func2) => func2 instanceof Function ? func2 : () => func2;
var defaultWidth = 200;
var defaultHeight = 150;
function instance48($$self, $$props, $$invalidate) {
  let viewBB;
  let elementWidth;
  let elementHeight;
  let scaledWidth;
  let scaledHeight;
  let viewScale;
  let viewWidth;
  let viewHeight;
  let offset;
  let x;
  let y;
  let viewboxWidth;
  let viewboxHeight;
  let $nodes;
  let $nodeLookup;
  let $viewport;
  let $containerHeight;
  let $containerWidth;
  let $flowId;
  let $panZoom;
  let $translateExtent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Minimap", slots, []);
  let { position = "bottom-right" } = $$props;
  let { ariaLabel = "Mini map" } = $$props;
  let { nodeStrokeColor = "transparent" } = $$props;
  let { nodeColor = void 0 } = $$props;
  let { nodeClass = "" } = $$props;
  let { nodeBorderRadius = 5 } = $$props;
  let { nodeStrokeWidth = 2 } = $$props;
  let { bgColor = void 0 } = $$props;
  let { maskColor = void 0 } = $$props;
  let { maskStrokeColor = void 0 } = $$props;
  let { maskStrokeWidth = void 0 } = $$props;
  let { width = void 0 } = $$props;
  let { height = void 0 } = $$props;
  let { pannable = true } = $$props;
  let { zoomable = true } = $$props;
  let { inversePan = void 0 } = $$props;
  let { zoomStep = void 0 } = $$props;
  let { style = "" } = $$props;
  let { class: className = "" } = $$props;
  const { nodes, nodeLookup, viewport, width: containerWidth, height: containerHeight, flowId, panZoom, translateExtent } = useStore();
  validate_store(nodes, "nodes");
  component_subscribe($$self, nodes, (value) => $$invalidate(19, $nodes = value));
  validate_store(nodeLookup, "nodeLookup");
  component_subscribe($$self, nodeLookup, (value) => $$invalidate(20, $nodeLookup = value));
  validate_store(viewport, "viewport");
  component_subscribe($$self, viewport, (value) => $$invalidate(53, $viewport = value));
  validate_store(containerWidth, "containerWidth");
  component_subscribe($$self, containerWidth, (value) => $$invalidate(22, $containerWidth = value));
  validate_store(containerHeight, "containerHeight");
  component_subscribe($$self, containerHeight, (value) => $$invalidate(21, $containerHeight = value));
  validate_store(flowId, "flowId");
  component_subscribe($$self, flowId, (value) => $$invalidate(54, $flowId = value));
  validate_store(panZoom, "panZoom");
  component_subscribe($$self, panZoom, (value) => $$invalidate(27, $panZoom = value));
  validate_store(translateExtent, "translateExtent");
  component_subscribe($$self, translateExtent, (value) => $$invalidate(28, $translateExtent = value));
  const nodeColorFunc = nodeColor === void 0 ? void 0 : getAttrFunction(nodeColor);
  const nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);
  const nodeClassFunc = getAttrFunction(nodeClass);
  const shapeRendering = (
    // @ts-expect-error - TS doesn't know about chrome
    typeof window === "undefined" || !!window.chrome ? "crispEdges" : "geometricPrecision"
  );
  const labelledBy = `svelte-flow__minimap-desc-${$flowId}`;
  let boundingRect = viewBB;
  const getViewScale = () => viewScale;
  const writable_props = [
    "position",
    "ariaLabel",
    "nodeStrokeColor",
    "nodeColor",
    "nodeClass",
    "nodeBorderRadius",
    "nodeStrokeWidth",
    "bgColor",
    "maskColor",
    "maskStrokeColor",
    "maskStrokeWidth",
    "width",
    "height",
    "pannable",
    "zoomable",
    "inversePan",
    "zoomStep",
    "style",
    "class"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Minimap> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2) $$invalidate(0, position = $$props2.position);
    if ("ariaLabel" in $$props2) $$invalidate(1, ariaLabel = $$props2.ariaLabel);
    if ("nodeStrokeColor" in $$props2) $$invalidate(43, nodeStrokeColor = $$props2.nodeStrokeColor);
    if ("nodeColor" in $$props2) $$invalidate(44, nodeColor = $$props2.nodeColor);
    if ("nodeClass" in $$props2) $$invalidate(45, nodeClass = $$props2.nodeClass);
    if ("nodeBorderRadius" in $$props2) $$invalidate(2, nodeBorderRadius = $$props2.nodeBorderRadius);
    if ("nodeStrokeWidth" in $$props2) $$invalidate(3, nodeStrokeWidth = $$props2.nodeStrokeWidth);
    if ("bgColor" in $$props2) $$invalidate(4, bgColor = $$props2.bgColor);
    if ("maskColor" in $$props2) $$invalidate(5, maskColor = $$props2.maskColor);
    if ("maskStrokeColor" in $$props2) $$invalidate(6, maskStrokeColor = $$props2.maskStrokeColor);
    if ("maskStrokeWidth" in $$props2) $$invalidate(7, maskStrokeWidth = $$props2.maskStrokeWidth);
    if ("width" in $$props2) $$invalidate(46, width = $$props2.width);
    if ("height" in $$props2) $$invalidate(47, height = $$props2.height);
    if ("pannable" in $$props2) $$invalidate(8, pannable = $$props2.pannable);
    if ("zoomable" in $$props2) $$invalidate(9, zoomable = $$props2.zoomable);
    if ("inversePan" in $$props2) $$invalidate(10, inversePan = $$props2.inversePan);
    if ("zoomStep" in $$props2) $$invalidate(11, zoomStep = $$props2.zoomStep);
    if ("style" in $$props2) $$invalidate(12, style = $$props2.style);
    if ("class" in $$props2) $$invalidate(13, className = $$props2.class);
  };
  $$self.$capture_state = () => ({
    getAttrFunction,
    cc,
    getBoundsOfRects,
    getInternalNodesBounds,
    getNodeDimensions,
    nodeHasDimensions,
    useStore,
    Panel: Panel_default,
    MinimapNode: MinimapNode_default,
    interactive,
    position,
    ariaLabel,
    nodeStrokeColor,
    nodeColor,
    nodeClass,
    nodeBorderRadius,
    nodeStrokeWidth,
    bgColor,
    maskColor,
    maskStrokeColor,
    maskStrokeWidth,
    width,
    height,
    pannable,
    zoomable,
    inversePan,
    zoomStep,
    style,
    className,
    defaultWidth,
    defaultHeight,
    nodes,
    nodeLookup,
    viewport,
    containerWidth,
    containerHeight,
    flowId,
    panZoom,
    translateExtent,
    nodeColorFunc,
    nodeStrokeColorFunc,
    nodeClassFunc,
    shapeRendering,
    labelledBy,
    boundingRect,
    getViewScale,
    viewScale,
    offset,
    viewHeight,
    viewboxHeight,
    viewWidth,
    viewboxWidth,
    y,
    x,
    elementHeight,
    elementWidth,
    scaledHeight,
    scaledWidth,
    viewBB,
    $nodes,
    $nodeLookup,
    $viewport,
    $containerHeight,
    $containerWidth,
    $flowId,
    $panZoom,
    $translateExtent
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2) $$invalidate(0, position = $$props2.position);
    if ("ariaLabel" in $$props2) $$invalidate(1, ariaLabel = $$props2.ariaLabel);
    if ("nodeStrokeColor" in $$props2) $$invalidate(43, nodeStrokeColor = $$props2.nodeStrokeColor);
    if ("nodeColor" in $$props2) $$invalidate(44, nodeColor = $$props2.nodeColor);
    if ("nodeClass" in $$props2) $$invalidate(45, nodeClass = $$props2.nodeClass);
    if ("nodeBorderRadius" in $$props2) $$invalidate(2, nodeBorderRadius = $$props2.nodeBorderRadius);
    if ("nodeStrokeWidth" in $$props2) $$invalidate(3, nodeStrokeWidth = $$props2.nodeStrokeWidth);
    if ("bgColor" in $$props2) $$invalidate(4, bgColor = $$props2.bgColor);
    if ("maskColor" in $$props2) $$invalidate(5, maskColor = $$props2.maskColor);
    if ("maskStrokeColor" in $$props2) $$invalidate(6, maskStrokeColor = $$props2.maskStrokeColor);
    if ("maskStrokeWidth" in $$props2) $$invalidate(7, maskStrokeWidth = $$props2.maskStrokeWidth);
    if ("width" in $$props2) $$invalidate(46, width = $$props2.width);
    if ("height" in $$props2) $$invalidate(47, height = $$props2.height);
    if ("pannable" in $$props2) $$invalidate(8, pannable = $$props2.pannable);
    if ("zoomable" in $$props2) $$invalidate(9, zoomable = $$props2.zoomable);
    if ("inversePan" in $$props2) $$invalidate(10, inversePan = $$props2.inversePan);
    if ("zoomStep" in $$props2) $$invalidate(11, zoomStep = $$props2.zoomStep);
    if ("style" in $$props2) $$invalidate(12, style = $$props2.style);
    if ("className" in $$props2) $$invalidate(13, className = $$props2.className);
    if ("boundingRect" in $$props2) $$invalidate(48, boundingRect = $$props2.boundingRect);
    if ("viewScale" in $$props2) $$invalidate(14, viewScale = $$props2.viewScale);
    if ("offset" in $$props2) $$invalidate(15, offset = $$props2.offset);
    if ("viewHeight" in $$props2) $$invalidate(49, viewHeight = $$props2.viewHeight);
    if ("viewboxHeight" in $$props2) $$invalidate(23, viewboxHeight = $$props2.viewboxHeight);
    if ("viewWidth" in $$props2) $$invalidate(50, viewWidth = $$props2.viewWidth);
    if ("viewboxWidth" in $$props2) $$invalidate(24, viewboxWidth = $$props2.viewboxWidth);
    if ("y" in $$props2) $$invalidate(25, y = $$props2.y);
    if ("x" in $$props2) $$invalidate(26, x = $$props2.x);
    if ("elementHeight" in $$props2) $$invalidate(16, elementHeight = $$props2.elementHeight);
    if ("elementWidth" in $$props2) $$invalidate(17, elementWidth = $$props2.elementWidth);
    if ("scaledHeight" in $$props2) $$invalidate(51, scaledHeight = $$props2.scaledHeight);
    if ("scaledWidth" in $$props2) $$invalidate(52, scaledWidth = $$props2.scaledWidth);
    if ("viewBB" in $$props2) $$invalidate(18, viewBB = $$props2.viewBB);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$containerWidth, $containerHeight*/
    6291456 | $$self.$$.dirty[1] & /*$viewport*/
    4194304) {
      $: $$invalidate(18, viewBB = {
        x: -$viewport.x / $viewport.zoom,
        y: -$viewport.y / $viewport.zoom,
        width: $containerWidth / $viewport.zoom,
        height: $containerHeight / $viewport.zoom
      });
    }
    if ($$self.$$.dirty[0] & /*$nodeLookup, viewBB, $nodes*/
    1835008) {
      $: {
        $$invalidate(48, boundingRect = $nodeLookup.size > 0 ? getBoundsOfRects(getInternalNodesBounds($nodeLookup), viewBB) : viewBB);
        $nodes;
      }
    }
    if ($$self.$$.dirty[1] & /*width*/
    32768) {
      $: $$invalidate(17, elementWidth = width ?? defaultWidth);
    }
    if ($$self.$$.dirty[1] & /*height*/
    65536) {
      $: $$invalidate(16, elementHeight = height ?? defaultHeight);
    }
    if ($$self.$$.dirty[0] & /*elementWidth*/
    131072 | $$self.$$.dirty[1] & /*boundingRect*/
    131072) {
      $: $$invalidate(52, scaledWidth = boundingRect.width / elementWidth);
    }
    if ($$self.$$.dirty[0] & /*elementHeight*/
    65536 | $$self.$$.dirty[1] & /*boundingRect*/
    131072) {
      $: $$invalidate(51, scaledHeight = boundingRect.height / elementHeight);
    }
    if ($$self.$$.dirty[1] & /*scaledWidth, scaledHeight*/
    3145728) {
      $: $$invalidate(14, viewScale = Math.max(scaledWidth, scaledHeight));
    }
    if ($$self.$$.dirty[0] & /*viewScale, elementWidth*/
    147456) {
      $: $$invalidate(50, viewWidth = viewScale * elementWidth);
    }
    if ($$self.$$.dirty[0] & /*viewScale, elementHeight*/
    81920) {
      $: $$invalidate(49, viewHeight = viewScale * elementHeight);
    }
    if ($$self.$$.dirty[0] & /*viewScale*/
    16384) {
      $: $$invalidate(15, offset = 5 * viewScale);
    }
    if ($$self.$$.dirty[0] & /*offset*/
    32768 | $$self.$$.dirty[1] & /*boundingRect, viewWidth*/
    655360) {
      $: $$invalidate(26, x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset);
    }
    if ($$self.$$.dirty[0] & /*offset*/
    32768 | $$self.$$.dirty[1] & /*boundingRect, viewHeight*/
    393216) {
      $: $$invalidate(25, y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset);
    }
    if ($$self.$$.dirty[0] & /*offset*/
    32768 | $$self.$$.dirty[1] & /*viewWidth*/
    524288) {
      $: $$invalidate(24, viewboxWidth = viewWidth + offset * 2);
    }
    if ($$self.$$.dirty[0] & /*offset*/
    32768 | $$self.$$.dirty[1] & /*viewHeight*/
    262144) {
      $: $$invalidate(23, viewboxHeight = viewHeight + offset * 2);
    }
  };
  return [
    position,
    ariaLabel,
    nodeBorderRadius,
    nodeStrokeWidth,
    bgColor,
    maskColor,
    maskStrokeColor,
    maskStrokeWidth,
    pannable,
    zoomable,
    inversePan,
    zoomStep,
    style,
    className,
    viewScale,
    offset,
    elementHeight,
    elementWidth,
    viewBB,
    $nodes,
    $nodeLookup,
    $containerHeight,
    $containerWidth,
    viewboxHeight,
    viewboxWidth,
    y,
    x,
    $panZoom,
    $translateExtent,
    nodes,
    nodeLookup,
    viewport,
    containerWidth,
    containerHeight,
    flowId,
    panZoom,
    translateExtent,
    nodeColorFunc,
    nodeStrokeColorFunc,
    nodeClassFunc,
    shapeRendering,
    labelledBy,
    getViewScale,
    nodeStrokeColor,
    nodeColor,
    nodeClass,
    width,
    height,
    boundingRect,
    viewHeight,
    viewWidth,
    scaledHeight,
    scaledWidth,
    $viewport
  ];
}
var Minimap = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance48,
      create_fragment48,
      safe_not_equal,
      {
        position: 0,
        ariaLabel: 1,
        nodeStrokeColor: 43,
        nodeColor: 44,
        nodeClass: 45,
        nodeBorderRadius: 2,
        nodeStrokeWidth: 3,
        bgColor: 4,
        maskColor: 5,
        maskStrokeColor: 6,
        maskStrokeWidth: 7,
        width: 46,
        height: 47,
        pannable: 8,
        zoomable: 9,
        inversePan: 10,
        zoomStep: 11,
        style: 12,
        class: 13
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Minimap",
      options,
      id: create_fragment48.name
    });
  }
  get position() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabel() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeStrokeColor() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeStrokeColor(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeColor() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeColor(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeClass() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeClass(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeBorderRadius() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeBorderRadius(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeStrokeWidth() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeStrokeWidth(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgColor() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maskColor() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maskColor(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maskStrokeColor() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maskStrokeColor(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maskStrokeWidth() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maskStrokeWidth(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pannable() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pannable(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomable() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomable(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inversePan() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inversePan(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomStep() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomStep(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Minimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Minimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Minimap_default = Minimap;

// node_modules/@xyflow/svelte/dist/lib/plugins/NodeToolbar/NodeToolbar.svelte
var file32 = "node_modules/@xyflow/svelte/dist/lib/plugins/NodeToolbar/NodeToolbar.svelte";
function create_if_block13(ctx) {
  let div;
  let div_data_id_value;
  let portal_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    null
  );
  const block = {
    c: function create2() {
      div = element("div");
      if (default_slot) default_slot.c();
      attr_dev(div, "data-id", div_data_id_value = /*toolbarNodes*/
      ctx[0].reduce(func, "").trim());
      attr_dev(div, "class", "svelte-flow__node-toolbar");
      set_style(div, "position", `absolute`);
      set_style(
        div,
        "transform",
        /*transform*/
        ctx[1]
      );
      set_style(
        div,
        "z-index",
        /*zIndex*/
        ctx[3]
      );
      add_location(div, file32, 48, 2, 1875);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(portal_action = portal_default.call(null, div, { domNode: (
          /*$domNode*/
          ctx[4]
        ) }));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*toolbarNodes*/
      1 && div_data_id_value !== (div_data_id_value = /*toolbarNodes*/
      ctx2[0].reduce(func, "").trim())) {
        attr_dev(div, "data-id", div_data_id_value);
      }
      if (portal_action && is_function(portal_action.update) && dirty & /*$domNode*/
      16) portal_action.update.call(null, { domNode: (
        /*$domNode*/
        ctx2[4]
      ) });
      if (dirty & /*transform*/
      2) {
        set_style(
          div,
          "transform",
          /*transform*/
          ctx2[1]
        );
      }
      if (dirty & /*zIndex*/
      8) {
        set_style(
          div,
          "z-index",
          /*zIndex*/
          ctx2[3]
        );
      }
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(default_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(default_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block13.name,
    type: "if",
    source: "(48:0) {#if $domNode && isActive && toolbarNodes}",
    ctx
  });
  return block;
}
function create_fragment49(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$domNode*/
    ctx[4] && /*isActive*/
    ctx[2] && /*toolbarNodes*/
    ctx[0] && create_if_block13(ctx)
  );
  const block = {
    c: function create2() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$domNode*/
        ctx2[4] && /*isActive*/
        ctx2[2] && /*toolbarNodes*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$domNode, isActive, toolbarNodes*/
          21) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block13(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment49.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func = (acc, node) => `${acc}${node.id} `;
function instance49($$self, $$props, $$invalidate) {
  let zIndex;
  let selectedNodesCount;
  let isActive;
  let $nodes;
  let $viewport;
  let $nodeOrigin;
  let $nodeLookup;
  let $domNode;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NodeToolbar", slots, ["default"]);
  let { nodeId = void 0 } = $$props;
  let { position = void 0 } = $$props;
  let { align = void 0 } = $$props;
  let { offset = void 0 } = $$props;
  let { isVisible = void 0 } = $$props;
  const { domNode, viewport, nodeLookup, nodes, nodeOrigin } = useStore();
  validate_store(domNode, "domNode");
  component_subscribe($$self, domNode, (value) => $$invalidate(4, $domNode = value));
  validate_store(viewport, "viewport");
  component_subscribe($$self, viewport, (value) => $$invalidate(17, $viewport = value));
  validate_store(nodeLookup, "nodeLookup");
  component_subscribe($$self, nodeLookup, (value) => $$invalidate(19, $nodeLookup = value));
  validate_store(nodes, "nodes");
  component_subscribe($$self, nodes, (value) => $$invalidate(16, $nodes = value));
  validate_store(nodeOrigin, "nodeOrigin");
  component_subscribe($$self, nodeOrigin, (value) => $$invalidate(18, $nodeOrigin = value));
  const contextNodeId = getContext("svelteflow__node_id");
  let transform2;
  let toolbarNodes = [];
  let _offset = offset !== void 0 ? offset : 10;
  let _position = position !== void 0 ? position : Position.Top;
  let _align = align !== void 0 ? align : "center";
  const writable_props = ["nodeId", "position", "align", "offset", "isVisible"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<NodeToolbar> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2) $$invalidate(10, nodeId = $$props2.nodeId);
    if ("position" in $$props2) $$invalidate(11, position = $$props2.position);
    if ("align" in $$props2) $$invalidate(12, align = $$props2.align);
    if ("offset" in $$props2) $$invalidate(13, offset = $$props2.offset);
    if ("isVisible" in $$props2) $$invalidate(14, isVisible = $$props2.isVisible);
    if ("$$scope" in $$props2) $$invalidate(20, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    getNodesBounds,
    Position,
    getNodeToolbarTransform,
    portal: portal_default,
    useStore,
    nodeId,
    position,
    align,
    offset,
    isVisible,
    domNode,
    viewport,
    nodeLookup,
    nodes,
    nodeOrigin,
    contextNodeId,
    transform: transform2,
    toolbarNodes,
    _offset,
    _position,
    _align,
    selectedNodesCount,
    isActive,
    zIndex,
    $nodes,
    $viewport,
    $nodeOrigin,
    $nodeLookup,
    $domNode
  });
  $$self.$inject_state = ($$props2) => {
    if ("nodeId" in $$props2) $$invalidate(10, nodeId = $$props2.nodeId);
    if ("position" in $$props2) $$invalidate(11, position = $$props2.position);
    if ("align" in $$props2) $$invalidate(12, align = $$props2.align);
    if ("offset" in $$props2) $$invalidate(13, offset = $$props2.offset);
    if ("isVisible" in $$props2) $$invalidate(14, isVisible = $$props2.isVisible);
    if ("transform" in $$props2) $$invalidate(1, transform2 = $$props2.transform);
    if ("toolbarNodes" in $$props2) $$invalidate(0, toolbarNodes = $$props2.toolbarNodes);
    if ("_offset" in $$props2) $$invalidate(23, _offset = $$props2._offset);
    if ("_position" in $$props2) $$invalidate(24, _position = $$props2._position);
    if ("_align" in $$props2) $$invalidate(25, _align = $$props2._align);
    if ("selectedNodesCount" in $$props2) $$invalidate(15, selectedNodesCount = $$props2.selectedNodesCount);
    if ("isActive" in $$props2) $$invalidate(2, isActive = $$props2.isActive);
    if ("zIndex" in $$props2) $$invalidate(3, zIndex = $$props2.zIndex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$nodes, nodeId, $nodeLookup*/
    590848) {
      $: {
        $nodes;
        const nodeIds = Array.isArray(nodeId) ? nodeId : [nodeId || contextNodeId];
        $$invalidate(0, toolbarNodes = nodeIds.reduce(
          (res, nodeId2) => {
            const node = $nodeLookup.get(nodeId2);
            if (node) {
              res.push(node);
            }
            return res;
          },
          []
        ));
      }
    }
    if ($$self.$$.dirty & /*toolbarNodes, $nodeOrigin, $viewport*/
    393217) {
      $: {
        const nodeRect = getNodesBounds(toolbarNodes, { nodeOrigin: $nodeOrigin });
        if (nodeRect) {
          $$invalidate(1, transform2 = getNodeToolbarTransform(nodeRect, $viewport, _position, _offset, _align));
        }
      }
    }
    if ($$self.$$.dirty & /*toolbarNodes*/
    1) {
      $: $$invalidate(3, zIndex = toolbarNodes.length === 0 ? 1 : Math.max(...toolbarNodes.map((node) => (node.internals.z || 5) + 1)));
    }
    if ($$self.$$.dirty & /*$nodes*/
    65536) {
      $: $$invalidate(15, selectedNodesCount = $nodes.filter((node) => node.selected).length);
    }
    if ($$self.$$.dirty & /*isVisible, toolbarNodes, selectedNodesCount*/
    49153) {
      $: $$invalidate(2, isActive = typeof isVisible === "boolean" ? isVisible : toolbarNodes.length === 1 && toolbarNodes[0].selected && selectedNodesCount === 1);
    }
  };
  return [
    toolbarNodes,
    transform2,
    isActive,
    zIndex,
    $domNode,
    domNode,
    viewport,
    nodeLookup,
    nodes,
    nodeOrigin,
    nodeId,
    position,
    align,
    offset,
    isVisible,
    selectedNodesCount,
    $nodes,
    $viewport,
    $nodeOrigin,
    $nodeLookup,
    $$scope,
    slots
  ];
}
var NodeToolbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance49, create_fragment49, safe_not_equal, {
      nodeId: 10,
      position: 11,
      align: 12,
      offset: 13,
      isVisible: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NodeToolbar",
      options,
      id: create_fragment49.name
    });
  }
  get nodeId() {
    throw new Error("<NodeToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeId(value) {
    throw new Error("<NodeToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<NodeToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<NodeToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<NodeToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<NodeToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get offset() {
    throw new Error("<NodeToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set offset(value) {
    throw new Error("<NodeToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isVisible() {
    throw new Error("<NodeToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isVisible(value) {
    throw new Error("<NodeToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NodeToolbar_default = NodeToolbar;

// node_modules/@xyflow/svelte/dist/lib/plugins/NodeResizer/ResizeControl.svelte
var file33 = "node_modules/@xyflow/svelte/dist/lib/plugins/NodeResizer/ResizeControl.svelte";
function create_fragment50(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[33].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[32],
    null
  );
  const block = {
    c: function create2() {
      div = element("div");
      if (default_slot) default_slot.c();
      attr_dev(div, "class", div_class_value = cc([
        "svelte-flow__resize-control",
        "nodrag",
        .../*positionClassNames*/
        ctx[4],
        /*variant*/
        ctx[0],
        /*className*/
        ctx[1]
      ]));
      attr_dev(
        div,
        "style",
        /*controlStyle*/
        ctx[3]
      );
      add_location(div, file33, 93, 0, 3323);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[34](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[32],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[32]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[32],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*positionClassNames, variant, className*/
      19 && div_class_value !== (div_class_value = cc([
        "svelte-flow__resize-control",
        "nodrag",
        .../*positionClassNames*/
        ctx2[4],
        /*variant*/
        ctx2[0],
        /*className*/
        ctx2[1]
      ]))) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*controlStyle*/
      8) {
        attr_dev(
          div,
          "style",
          /*controlStyle*/
          ctx2[3]
        );
      }
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(default_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(default_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[34](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment50.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance50($$self, $$props, $$invalidate) {
  let _minWidth;
  let _minHeight;
  let _maxWidth;
  let _maxHeight;
  let id2;
  let defaultPosition;
  let controlPosition;
  let positionClassNames;
  let colorStyleProp;
  let _style;
  let controlStyle;
  let $nodes;
  let $nodeLookup;
  let $nodeOrigin;
  let $snapGrid;
  let $viewport;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ResizeControl", slots, ["default"]);
  let { nodeId = void 0 } = $$props;
  let { position = void 0 } = $$props;
  let { variant = ResizeControlVariant.Handle } = $$props;
  let { color: color2 = void 0 } = $$props;
  let { minWidth = 10 } = $$props;
  let { minHeight = 10 } = $$props;
  let { maxWidth = Number.MAX_VALUE } = $$props;
  let { maxHeight = Number.MAX_VALUE } = $$props;
  let { keepAspectRatio = false } = $$props;
  let { shouldResize = void 0 } = $$props;
  let { onResizeStart = void 0 } = $$props;
  let { onResize = void 0 } = $$props;
  let { onResizeEnd = void 0 } = $$props;
  let { style = "" } = $$props;
  let { class: className = "" } = $$props;
  const { nodeLookup, snapGrid, viewport, nodes, nodeOrigin } = useStore();
  validate_store(nodeLookup, "nodeLookup");
  component_subscribe($$self, nodeLookup, (value) => $$invalidate(37, $nodeLookup = value));
  validate_store(snapGrid, "snapGrid");
  component_subscribe($$self, snapGrid, (value) => $$invalidate(39, $snapGrid = value));
  validate_store(viewport, "viewport");
  component_subscribe($$self, viewport, (value) => $$invalidate(40, $viewport = value));
  validate_store(nodes, "nodes");
  component_subscribe($$self, nodes, (value) => $$invalidate(36, $nodes = value));
  validate_store(nodeOrigin, "nodeOrigin");
  component_subscribe($$self, nodeOrigin, (value) => $$invalidate(38, $nodeOrigin = value));
  const contextNodeId = getContext("svelteflow__node_id");
  let resizeControlRef;
  let resizer = null;
  onMount(() => {
    if (resizeControlRef) {
      $$invalidate(23, resizer = XYResizer({
        domNode: resizeControlRef,
        nodeId: id2,
        getStoreItems: () => {
          return {
            nodeLookup: $nodeLookup,
            transform: [$viewport.x, $viewport.y, $viewport.zoom],
            snapGrid: $snapGrid ?? void 0,
            snapToGrid: !!$snapGrid,
            nodeOrigin: $nodeOrigin
          };
        },
        onChange: (change, childChanges) => {
          var _a, _b;
          const node = (_a = $nodeLookup.get(id2)) == null ? void 0 : _a.internals.userNode;
          if (!node) {
            return;
          }
          if (change.x !== void 0 && change.y !== void 0) {
            node.position = { x: change.x, y: change.y };
          }
          if (change.width !== void 0 && change.height !== void 0) {
            node.width = change.width;
            node.height = change.height;
          }
          for (const childChange of childChanges) {
            const childNode = (_b = $nodeLookup.get(childChange.id)) == null ? void 0 : _b.internals.userNode;
            if (childNode) {
              childNode.position = childChange.position;
            }
          }
          nodes.set($nodes);
        }
      }));
    }
    return () => {
      resizer == null ? void 0 : resizer.destroy();
    };
  });
  const writable_props = [
    "nodeId",
    "position",
    "variant",
    "color",
    "minWidth",
    "minHeight",
    "maxWidth",
    "maxHeight",
    "keepAspectRatio",
    "shouldResize",
    "onResizeStart",
    "onResize",
    "onResizeEnd",
    "style",
    "class"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<ResizeControl> was created with unknown prop '${key2}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      resizeControlRef = $$value;
      $$invalidate(2, resizeControlRef);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2) $$invalidate(10, nodeId = $$props2.nodeId);
    if ("position" in $$props2) $$invalidate(11, position = $$props2.position);
    if ("variant" in $$props2) $$invalidate(0, variant = $$props2.variant);
    if ("color" in $$props2) $$invalidate(12, color2 = $$props2.color);
    if ("minWidth" in $$props2) $$invalidate(13, minWidth = $$props2.minWidth);
    if ("minHeight" in $$props2) $$invalidate(14, minHeight = $$props2.minHeight);
    if ("maxWidth" in $$props2) $$invalidate(15, maxWidth = $$props2.maxWidth);
    if ("maxHeight" in $$props2) $$invalidate(16, maxHeight = $$props2.maxHeight);
    if ("keepAspectRatio" in $$props2) $$invalidate(17, keepAspectRatio = $$props2.keepAspectRatio);
    if ("shouldResize" in $$props2) $$invalidate(18, shouldResize = $$props2.shouldResize);
    if ("onResizeStart" in $$props2) $$invalidate(19, onResizeStart = $$props2.onResizeStart);
    if ("onResize" in $$props2) $$invalidate(20, onResize = $$props2.onResize);
    if ("onResizeEnd" in $$props2) $$invalidate(21, onResizeEnd = $$props2.onResizeEnd);
    if ("style" in $$props2) $$invalidate(22, style = $$props2.style);
    if ("class" in $$props2) $$invalidate(1, className = $$props2.class);
    if ("$$scope" in $$props2) $$invalidate(32, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    onMount,
    cc,
    useStore,
    XYResizer,
    ResizeControlVariant,
    nodeId,
    position,
    variant,
    color: color2,
    minWidth,
    minHeight,
    maxWidth,
    maxHeight,
    keepAspectRatio,
    shouldResize,
    onResizeStart,
    onResize,
    onResizeEnd,
    style,
    className,
    nodeLookup,
    snapGrid,
    viewport,
    nodes,
    nodeOrigin,
    contextNodeId,
    resizeControlRef,
    resizer,
    _maxHeight,
    _maxWidth,
    _minHeight,
    _minWidth,
    controlPosition,
    id: id2,
    _style,
    colorStyleProp,
    controlStyle,
    positionClassNames,
    defaultPosition,
    $nodes,
    $nodeLookup,
    $nodeOrigin,
    $snapGrid,
    $viewport
  });
  $$self.$inject_state = ($$props2) => {
    if ("nodeId" in $$props2) $$invalidate(10, nodeId = $$props2.nodeId);
    if ("position" in $$props2) $$invalidate(11, position = $$props2.position);
    if ("variant" in $$props2) $$invalidate(0, variant = $$props2.variant);
    if ("color" in $$props2) $$invalidate(12, color2 = $$props2.color);
    if ("minWidth" in $$props2) $$invalidate(13, minWidth = $$props2.minWidth);
    if ("minHeight" in $$props2) $$invalidate(14, minHeight = $$props2.minHeight);
    if ("maxWidth" in $$props2) $$invalidate(15, maxWidth = $$props2.maxWidth);
    if ("maxHeight" in $$props2) $$invalidate(16, maxHeight = $$props2.maxHeight);
    if ("keepAspectRatio" in $$props2) $$invalidate(17, keepAspectRatio = $$props2.keepAspectRatio);
    if ("shouldResize" in $$props2) $$invalidate(18, shouldResize = $$props2.shouldResize);
    if ("onResizeStart" in $$props2) $$invalidate(19, onResizeStart = $$props2.onResizeStart);
    if ("onResize" in $$props2) $$invalidate(20, onResize = $$props2.onResize);
    if ("onResizeEnd" in $$props2) $$invalidate(21, onResizeEnd = $$props2.onResizeEnd);
    if ("style" in $$props2) $$invalidate(22, style = $$props2.style);
    if ("className" in $$props2) $$invalidate(1, className = $$props2.className);
    if ("resizeControlRef" in $$props2) $$invalidate(2, resizeControlRef = $$props2.resizeControlRef);
    if ("resizer" in $$props2) $$invalidate(23, resizer = $$props2.resizer);
    if ("_maxHeight" in $$props2) $$invalidate(24, _maxHeight = $$props2._maxHeight);
    if ("_maxWidth" in $$props2) $$invalidate(25, _maxWidth = $$props2._maxWidth);
    if ("_minHeight" in $$props2) $$invalidate(26, _minHeight = $$props2._minHeight);
    if ("_minWidth" in $$props2) $$invalidate(27, _minWidth = $$props2._minWidth);
    if ("controlPosition" in $$props2) $$invalidate(28, controlPosition = $$props2.controlPosition);
    if ("id" in $$props2) id2 = $$props2.id;
    if ("_style" in $$props2) $$invalidate(29, _style = $$props2._style);
    if ("colorStyleProp" in $$props2) $$invalidate(30, colorStyleProp = $$props2.colorStyleProp);
    if ("controlStyle" in $$props2) $$invalidate(3, controlStyle = $$props2.controlStyle);
    if ("positionClassNames" in $$props2) $$invalidate(4, positionClassNames = $$props2.positionClassNames);
    if ("defaultPosition" in $$props2) $$invalidate(31, defaultPosition = $$props2.defaultPosition);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*minWidth*/
    8192) {
      $: $$invalidate(27, _minWidth = minWidth ?? 10);
    }
    if ($$self.$$.dirty[0] & /*minHeight*/
    16384) {
      $: $$invalidate(26, _minHeight = minHeight ?? 10);
    }
    if ($$self.$$.dirty[0] & /*maxWidth*/
    32768) {
      $: $$invalidate(25, _maxWidth = maxWidth ?? Number.MAX_VALUE);
    }
    if ($$self.$$.dirty[0] & /*maxHeight*/
    65536) {
      $: $$invalidate(24, _maxHeight = maxHeight ?? Number.MAX_VALUE);
    }
    if ($$self.$$.dirty[0] & /*nodeId*/
    1024) {
      $: id2 = typeof nodeId === "string" ? nodeId : contextNodeId;
    }
    if ($$self.$$.dirty[0] & /*variant*/
    1) {
      $: $$invalidate(31, defaultPosition = variant === ResizeControlVariant.Line ? "right" : "bottom-right");
    }
    if ($$self.$$.dirty[0] & /*position*/
    2048 | $$self.$$.dirty[1] & /*defaultPosition*/
    1) {
      $: $$invalidate(28, controlPosition = position ?? defaultPosition);
    }
    if ($$self.$$.dirty[0] & /*controlPosition*/
    268435456) {
      $: $$invalidate(4, positionClassNames = controlPosition.split("-"));
    }
    if ($$self.$$.dirty[0] & /*variant*/
    1) {
      $: $$invalidate(30, colorStyleProp = variant === ResizeControlVariant.Line ? "border-color" : "background-color");
    }
    if ($$self.$$.dirty[0] & /*style*/
    4194304) {
      $: $$invalidate(29, _style = style ?? "");
    }
    if ($$self.$$.dirty[0] & /*color, _style, colorStyleProp*/
    1610616832) {
      $: $$invalidate(3, controlStyle = color2 ? `${_style} ${colorStyleProp}: ${color2};` : _style);
    }
    if ($$self.$$.dirty[0] & /*resizer, controlPosition, _minWidth, _minHeight, _maxWidth, _maxHeight, keepAspectRatio, onResizeStart, onResize, onResizeEnd, shouldResize*/
    532545536) {
      $: {
        resizer == null ? void 0 : resizer.update({
          controlPosition,
          boundaries: {
            minWidth: _minWidth,
            minHeight: _minHeight,
            maxWidth: _maxWidth,
            maxHeight: _maxHeight
          },
          keepAspectRatio: !!keepAspectRatio,
          onResizeStart,
          onResize,
          onResizeEnd,
          shouldResize
        });
      }
    }
  };
  return [
    variant,
    className,
    resizeControlRef,
    controlStyle,
    positionClassNames,
    nodeLookup,
    snapGrid,
    viewport,
    nodes,
    nodeOrigin,
    nodeId,
    position,
    color2,
    minWidth,
    minHeight,
    maxWidth,
    maxHeight,
    keepAspectRatio,
    shouldResize,
    onResizeStart,
    onResize,
    onResizeEnd,
    style,
    resizer,
    _maxHeight,
    _maxWidth,
    _minHeight,
    _minWidth,
    controlPosition,
    _style,
    colorStyleProp,
    defaultPosition,
    $$scope,
    slots,
    div_binding
  ];
}
var ResizeControl = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance50,
      create_fragment50,
      safe_not_equal,
      {
        nodeId: 10,
        position: 11,
        variant: 0,
        color: 12,
        minWidth: 13,
        minHeight: 14,
        maxWidth: 15,
        maxHeight: 16,
        keepAspectRatio: 17,
        shouldResize: 18,
        onResizeStart: 19,
        onResize: 20,
        onResizeEnd: 21,
        style: 22,
        class: 1
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ResizeControl",
      options,
      id: create_fragment50.name
    });
  }
  get nodeId() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeId(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minWidth() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minWidth(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minHeight() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minHeight(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxWidth() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxWidth(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxHeight() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxHeight(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keepAspectRatio() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keepAspectRatio(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shouldResize() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shouldResize(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onResizeStart() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onResizeStart(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onResize() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onResize(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onResizeEnd() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onResizeEnd(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ResizeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ResizeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ResizeControl_default = ResizeControl;

// node_modules/@xyflow/svelte/dist/lib/plugins/NodeResizer/NodeResizer.svelte
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i];
  return child_ctx;
}
function create_if_block14(ctx) {
  let each_blocks_1 = [];
  let each0_lookup = /* @__PURE__ */ new Map();
  let t;
  let each_blocks = [];
  let each1_lookup = /* @__PURE__ */ new Map();
  let each1_anchor;
  let current;
  let each_value_1 = ensure_array_like_dev(XY_RESIZER_LINE_POSITIONS);
  const get_key = (ctx2) => (
    /*position*/
    ctx2[20]
  );
  validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key2 = get_key(child_ctx);
    each0_lookup.set(key2, each_blocks_1[i] = create_each_block_1(key2, child_ctx));
  }
  let each_value = ensure_array_like_dev(XY_RESIZER_HANDLE_POSITIONS);
  const get_key_1 = (ctx2) => (
    /*position*/
    ctx2[20]
  );
  validate_each_keys(ctx, each_value, get_each_context5, get_key_1);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context5(ctx, each_value, i);
    let key2 = get_key_1(child_ctx);
    each1_lookup.set(key2, each_blocks[i] = create_each_block5(key2, child_ctx));
  }
  const block = {
    c: function create2() {
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(target, anchor);
        }
      }
      insert_dev(target, t, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_dev(target, each1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*lineClass, lineStyle, nodeId, color, _minWidth, _minHeight, _maxWidth, _maxHeight, onResizeStart, keepAspectRatio, shouldResize, onResize, onResizeEnd*/
      65521) {
        each_value_1 = ensure_array_like_dev(XY_RESIZER_LINE_POSITIONS);
        group_outros();
        validate_each_keys(ctx2, each_value_1, get_each_context_1, get_key);
        each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx2, each_value_1, each0_lookup, t.parentNode, outro_and_destroy_block, create_each_block_1, t, get_each_context_1);
        check_outros();
      }
      if (dirty & /*handleClass, handleStyle, nodeId, color, _minWidth, _minHeight, _maxWidth, _maxHeight, onResizeStart, keepAspectRatio, shouldResize, onResize, onResizeEnd*/
      65485) {
        each_value = ensure_array_like_dev(XY_RESIZER_HANDLE_POSITIONS);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context5, get_key_1);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx2, each_value, each1_lookup, each1_anchor.parentNode, outro_and_destroy_block, create_each_block5, each1_anchor, get_each_context5);
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current) return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local2) {
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(each1_anchor);
      }
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].d(detaching);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block14.name,
    type: "if",
    source: "(25:0) {#if isVisible}",
    ctx
  });
  return block;
}
function create_each_block_1(key_1, ctx) {
  let first;
  let resizecontrol;
  let current;
  resizecontrol = new ResizeControl_default({
    props: {
      class: (
        /*lineClass*/
        ctx[4]
      ),
      style: (
        /*lineStyle*/
        ctx[5]
      ),
      nodeId: (
        /*nodeId*/
        ctx[0]
      ),
      position: (
        /*position*/
        ctx[20]
      ),
      variant: ResizeControlVariant.Line,
      color: (
        /*color*/
        ctx[6]
      ),
      minWidth: (
        /*_minWidth*/
        ctx[12]
      ),
      minHeight: (
        /*_minHeight*/
        ctx[13]
      ),
      maxWidth: (
        /*_maxWidth*/
        ctx[14]
      ),
      maxHeight: (
        /*_maxHeight*/
        ctx[15]
      ),
      onResizeStart: (
        /*onResizeStart*/
        ctx[9]
      ),
      keepAspectRatio: (
        /*keepAspectRatio*/
        ctx[7]
      ),
      shouldResize: (
        /*shouldResize*/
        ctx[8]
      ),
      onResize: (
        /*onResize*/
        ctx[10]
      ),
      onResizeEnd: (
        /*onResizeEnd*/
        ctx[11]
      )
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create2() {
      first = empty();
      create_component(resizecontrol.$$.fragment);
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      mount_component(resizecontrol, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const resizecontrol_changes = {};
      if (dirty & /*lineClass*/
      16) resizecontrol_changes.class = /*lineClass*/
      ctx[4];
      if (dirty & /*lineStyle*/
      32) resizecontrol_changes.style = /*lineStyle*/
      ctx[5];
      if (dirty & /*nodeId*/
      1) resizecontrol_changes.nodeId = /*nodeId*/
      ctx[0];
      if (dirty & /*color*/
      64) resizecontrol_changes.color = /*color*/
      ctx[6];
      if (dirty & /*onResizeStart*/
      512) resizecontrol_changes.onResizeStart = /*onResizeStart*/
      ctx[9];
      if (dirty & /*keepAspectRatio*/
      128) resizecontrol_changes.keepAspectRatio = /*keepAspectRatio*/
      ctx[7];
      if (dirty & /*shouldResize*/
      256) resizecontrol_changes.shouldResize = /*shouldResize*/
      ctx[8];
      if (dirty & /*onResize*/
      1024) resizecontrol_changes.onResize = /*onResize*/
      ctx[10];
      if (dirty & /*onResizeEnd*/
      2048) resizecontrol_changes.onResizeEnd = /*onResizeEnd*/
      ctx[11];
      resizecontrol.$set(resizecontrol_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(resizecontrol.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(resizecontrol.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(resizecontrol, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(26:2) {#each XY_RESIZER_LINE_POSITIONS as position (position)}",
    ctx
  });
  return block;
}
function create_each_block5(key_1, ctx) {
  let first;
  let resizecontrol;
  let current;
  resizecontrol = new ResizeControl_default({
    props: {
      class: (
        /*handleClass*/
        ctx[2]
      ),
      style: (
        /*handleStyle*/
        ctx[3]
      ),
      nodeId: (
        /*nodeId*/
        ctx[0]
      ),
      position: (
        /*position*/
        ctx[20]
      ),
      color: (
        /*color*/
        ctx[6]
      ),
      minWidth: (
        /*_minWidth*/
        ctx[12]
      ),
      minHeight: (
        /*_minHeight*/
        ctx[13]
      ),
      maxWidth: (
        /*_maxWidth*/
        ctx[14]
      ),
      maxHeight: (
        /*_maxHeight*/
        ctx[15]
      ),
      onResizeStart: (
        /*onResizeStart*/
        ctx[9]
      ),
      keepAspectRatio: (
        /*keepAspectRatio*/
        ctx[7]
      ),
      shouldResize: (
        /*shouldResize*/
        ctx[8]
      ),
      onResize: (
        /*onResize*/
        ctx[10]
      ),
      onResizeEnd: (
        /*onResizeEnd*/
        ctx[11]
      )
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create2() {
      first = empty();
      create_component(resizecontrol.$$.fragment);
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      mount_component(resizecontrol, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const resizecontrol_changes = {};
      if (dirty & /*handleClass*/
      4) resizecontrol_changes.class = /*handleClass*/
      ctx[2];
      if (dirty & /*handleStyle*/
      8) resizecontrol_changes.style = /*handleStyle*/
      ctx[3];
      if (dirty & /*nodeId*/
      1) resizecontrol_changes.nodeId = /*nodeId*/
      ctx[0];
      if (dirty & /*color*/
      64) resizecontrol_changes.color = /*color*/
      ctx[6];
      if (dirty & /*onResizeStart*/
      512) resizecontrol_changes.onResizeStart = /*onResizeStart*/
      ctx[9];
      if (dirty & /*keepAspectRatio*/
      128) resizecontrol_changes.keepAspectRatio = /*keepAspectRatio*/
      ctx[7];
      if (dirty & /*shouldResize*/
      256) resizecontrol_changes.shouldResize = /*shouldResize*/
      ctx[8];
      if (dirty & /*onResize*/
      1024) resizecontrol_changes.onResize = /*onResize*/
      ctx[10];
      if (dirty & /*onResizeEnd*/
      2048) resizecontrol_changes.onResizeEnd = /*onResizeEnd*/
      ctx[11];
      resizecontrol.$set(resizecontrol_changes);
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(resizecontrol.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(resizecontrol.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(resizecontrol, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block5.name,
    type: "each",
    source: "(45:2) {#each XY_RESIZER_HANDLE_POSITIONS as position (position)}",
    ctx
  });
  return block;
}
function create_fragment51(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*isVisible*/
    ctx[1] && create_if_block14(ctx)
  );
  const block = {
    c: function create2() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isVisible*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isVisible*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block14(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment51.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance51($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NodeResizer", slots, []);
  let { nodeId = void 0 } = $$props;
  let { isVisible = true } = $$props;
  let { handleClass = void 0 } = $$props;
  let { handleStyle = void 0 } = $$props;
  let { lineClass = void 0 } = $$props;
  let { lineStyle = void 0 } = $$props;
  let { color: color2 = void 0 } = $$props;
  let { minWidth = 10 } = $$props;
  let { minHeight = 10 } = $$props;
  let { maxWidth = Number.MAX_VALUE } = $$props;
  let { maxHeight = Number.MAX_VALUE } = $$props;
  let { keepAspectRatio = false } = $$props;
  let { shouldResize = void 0 } = $$props;
  let { onResizeStart = void 0 } = $$props;
  let { onResize = void 0 } = $$props;
  let { onResizeEnd = void 0 } = $$props;
  let _minWidth = minWidth || 10;
  let _minHeight = minHeight || 10;
  let _maxWidth = maxWidth || Number.MAX_VALUE;
  let _maxHeight = maxHeight || Number.MAX_VALUE;
  const writable_props = [
    "nodeId",
    "isVisible",
    "handleClass",
    "handleStyle",
    "lineClass",
    "lineStyle",
    "color",
    "minWidth",
    "minHeight",
    "maxWidth",
    "maxHeight",
    "keepAspectRatio",
    "shouldResize",
    "onResizeStart",
    "onResize",
    "onResizeEnd"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<NodeResizer> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2) $$invalidate(0, nodeId = $$props2.nodeId);
    if ("isVisible" in $$props2) $$invalidate(1, isVisible = $$props2.isVisible);
    if ("handleClass" in $$props2) $$invalidate(2, handleClass = $$props2.handleClass);
    if ("handleStyle" in $$props2) $$invalidate(3, handleStyle = $$props2.handleStyle);
    if ("lineClass" in $$props2) $$invalidate(4, lineClass = $$props2.lineClass);
    if ("lineStyle" in $$props2) $$invalidate(5, lineStyle = $$props2.lineStyle);
    if ("color" in $$props2) $$invalidate(6, color2 = $$props2.color);
    if ("minWidth" in $$props2) $$invalidate(16, minWidth = $$props2.minWidth);
    if ("minHeight" in $$props2) $$invalidate(17, minHeight = $$props2.minHeight);
    if ("maxWidth" in $$props2) $$invalidate(18, maxWidth = $$props2.maxWidth);
    if ("maxHeight" in $$props2) $$invalidate(19, maxHeight = $$props2.maxHeight);
    if ("keepAspectRatio" in $$props2) $$invalidate(7, keepAspectRatio = $$props2.keepAspectRatio);
    if ("shouldResize" in $$props2) $$invalidate(8, shouldResize = $$props2.shouldResize);
    if ("onResizeStart" in $$props2) $$invalidate(9, onResizeStart = $$props2.onResizeStart);
    if ("onResize" in $$props2) $$invalidate(10, onResize = $$props2.onResize);
    if ("onResizeEnd" in $$props2) $$invalidate(11, onResizeEnd = $$props2.onResizeEnd);
  };
  $$self.$capture_state = () => ({
    ResizeControl: ResizeControl_default,
    ResizeControlVariant,
    XY_RESIZER_HANDLE_POSITIONS,
    XY_RESIZER_LINE_POSITIONS,
    nodeId,
    isVisible,
    handleClass,
    handleStyle,
    lineClass,
    lineStyle,
    color: color2,
    minWidth,
    minHeight,
    maxWidth,
    maxHeight,
    keepAspectRatio,
    shouldResize,
    onResizeStart,
    onResize,
    onResizeEnd,
    _minWidth,
    _minHeight,
    _maxWidth,
    _maxHeight
  });
  $$self.$inject_state = ($$props2) => {
    if ("nodeId" in $$props2) $$invalidate(0, nodeId = $$props2.nodeId);
    if ("isVisible" in $$props2) $$invalidate(1, isVisible = $$props2.isVisible);
    if ("handleClass" in $$props2) $$invalidate(2, handleClass = $$props2.handleClass);
    if ("handleStyle" in $$props2) $$invalidate(3, handleStyle = $$props2.handleStyle);
    if ("lineClass" in $$props2) $$invalidate(4, lineClass = $$props2.lineClass);
    if ("lineStyle" in $$props2) $$invalidate(5, lineStyle = $$props2.lineStyle);
    if ("color" in $$props2) $$invalidate(6, color2 = $$props2.color);
    if ("minWidth" in $$props2) $$invalidate(16, minWidth = $$props2.minWidth);
    if ("minHeight" in $$props2) $$invalidate(17, minHeight = $$props2.minHeight);
    if ("maxWidth" in $$props2) $$invalidate(18, maxWidth = $$props2.maxWidth);
    if ("maxHeight" in $$props2) $$invalidate(19, maxHeight = $$props2.maxHeight);
    if ("keepAspectRatio" in $$props2) $$invalidate(7, keepAspectRatio = $$props2.keepAspectRatio);
    if ("shouldResize" in $$props2) $$invalidate(8, shouldResize = $$props2.shouldResize);
    if ("onResizeStart" in $$props2) $$invalidate(9, onResizeStart = $$props2.onResizeStart);
    if ("onResize" in $$props2) $$invalidate(10, onResize = $$props2.onResize);
    if ("onResizeEnd" in $$props2) $$invalidate(11, onResizeEnd = $$props2.onResizeEnd);
    if ("_minWidth" in $$props2) $$invalidate(12, _minWidth = $$props2._minWidth);
    if ("_minHeight" in $$props2) $$invalidate(13, _minHeight = $$props2._minHeight);
    if ("_maxWidth" in $$props2) $$invalidate(14, _maxWidth = $$props2._maxWidth);
    if ("_maxHeight" in $$props2) $$invalidate(15, _maxHeight = $$props2._maxHeight);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    nodeId,
    isVisible,
    handleClass,
    handleStyle,
    lineClass,
    lineStyle,
    color2,
    keepAspectRatio,
    shouldResize,
    onResizeStart,
    onResize,
    onResizeEnd,
    _minWidth,
    _minHeight,
    _maxWidth,
    _maxHeight,
    minWidth,
    minHeight,
    maxWidth,
    maxHeight
  ];
}
var NodeResizer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance51, create_fragment51, safe_not_equal, {
      nodeId: 0,
      isVisible: 1,
      handleClass: 2,
      handleStyle: 3,
      lineClass: 4,
      lineStyle: 5,
      color: 6,
      minWidth: 16,
      minHeight: 17,
      maxWidth: 18,
      maxHeight: 19,
      keepAspectRatio: 7,
      shouldResize: 8,
      onResizeStart: 9,
      onResize: 10,
      onResizeEnd: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NodeResizer",
      options,
      id: create_fragment51.name
    });
  }
  get nodeId() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeId(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isVisible() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isVisible(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handleClass() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handleClass(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handleStyle() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handleStyle(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineClass() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineClass(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineStyle() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineStyle(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minWidth() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minWidth(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minHeight() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minHeight(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxWidth() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxWidth(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxHeight() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxHeight(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keepAspectRatio() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keepAspectRatio(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shouldResize() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shouldResize(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onResizeStart() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onResizeStart(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onResize() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onResize(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onResizeEnd() {
    throw new Error("<NodeResizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onResizeEnd(value) {
    throw new Error("<NodeResizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NodeResizer_default = NodeResizer;

// node_modules/@xyflow/svelte/dist/lib/utils/index.js
var isNode = (element2) => isNodeBase(element2);
var isEdge = (element2) => isEdgeBase(element2);

// node_modules/@xyflow/svelte/dist/lib/hooks/useSvelteFlow.js
function useSvelteFlow() {
  const { zoomIn, zoomOut, fitView: fitView2, onbeforedelete, snapGrid, viewport, width, height, minZoom, maxZoom, panZoom, nodes, edges, domNode, nodeLookup, edgeLookup } = useStore();
  const getNodeRect = (nodeOrRect) => {
    const node = isNode(nodeOrRect) && nodeHasDimensions(nodeOrRect) ? nodeOrRect : get_store_value(nodeLookup).get(nodeOrRect.id);
    return node ? nodeToRect(node) : null;
  };
  const updateNode = (id2, nodeUpdate, options = { replace: false }) => {
    var _a;
    const node = (_a = get_store_value(nodeLookup).get(id2)) == null ? void 0 : _a.internals.userNode;
    if (!node) {
      return;
    }
    const nextNode = typeof nodeUpdate === "function" ? nodeUpdate(node) : nodeUpdate;
    if (options.replace) {
      nodes.update((nds) => nds.map((node2) => {
        if (node2.id === id2) {
          return isNode(nextNode) ? nextNode : { ...node2, ...nextNode };
        }
        return node2;
      }));
    } else {
      Object.assign(node, nextNode);
      nodes.update((nds) => nds);
    }
  };
  const getInternalNode = (id2) => get_store_value(nodeLookup).get(id2);
  return {
    zoomIn,
    zoomOut,
    getInternalNode,
    getNode: (id2) => {
      var _a;
      return (_a = getInternalNode(id2)) == null ? void 0 : _a.internals.userNode;
    },
    getNodes: (ids) => ids === void 0 ? get_store_value(nodes) : getElements(get_store_value(nodeLookup), ids),
    getEdge: (id2) => get_store_value(edgeLookup).get(id2),
    getEdges: (ids) => ids === void 0 ? get_store_value(edges) : getElements(get_store_value(edgeLookup), ids),
    setZoom: (zoomLevel, options) => {
      const currentPanZoom = get_store_value(panZoom);
      return currentPanZoom ? currentPanZoom.scaleTo(zoomLevel, { duration: options == null ? void 0 : options.duration }) : Promise.resolve(false);
    },
    getZoom: () => get_store_value(viewport).zoom,
    setViewport: async (nextViewport, options) => {
      const currentViewport = get_store_value(viewport);
      const currentPanZoom = get_store_value(panZoom);
      if (!currentPanZoom) {
        return Promise.resolve(false);
      }
      await currentPanZoom.setViewport({
        x: nextViewport.x ?? currentViewport.x,
        y: nextViewport.y ?? currentViewport.y,
        zoom: nextViewport.zoom ?? currentViewport.zoom
      }, { duration: options == null ? void 0 : options.duration });
      return Promise.resolve(true);
    },
    getViewport: () => get_store_value(viewport),
    setCenter: async (x, y, options) => {
      const nextZoom = typeof (options == null ? void 0 : options.zoom) !== "undefined" ? options.zoom : get_store_value(maxZoom);
      const currentPanZoom = get_store_value(panZoom);
      if (!currentPanZoom) {
        return Promise.resolve(false);
      }
      await currentPanZoom.setViewport({
        x: get_store_value(width) / 2 - x * nextZoom,
        y: get_store_value(height) / 2 - y * nextZoom,
        zoom: nextZoom
      }, { duration: options == null ? void 0 : options.duration });
      return Promise.resolve(true);
    },
    fitView: fitView2,
    fitBounds: async (bounds, options) => {
      const currentPanZoom = get_store_value(panZoom);
      if (!currentPanZoom) {
        return Promise.resolve(false);
      }
      const viewport2 = getViewportForBounds(bounds, get_store_value(width), get_store_value(height), get_store_value(minZoom), get_store_value(maxZoom), (options == null ? void 0 : options.padding) ?? 0.1);
      await currentPanZoom.setViewport(viewport2, { duration: options == null ? void 0 : options.duration });
      return Promise.resolve(true);
    },
    getIntersectingNodes: (nodeOrRect, partially = true, nodesToIntersect) => {
      const isRect = isRectObject(nodeOrRect);
      const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);
      if (!nodeRect) {
        return [];
      }
      return (nodesToIntersect || get_store_value(nodes)).filter((n) => {
        const internalNode = get_store_value(nodeLookup).get(n.id);
        if (!internalNode || !isRect && n.id === nodeOrRect.id) {
          return false;
        }
        const currNodeRect = nodeToRect(internalNode);
        const overlappingArea = getOverlappingArea(currNodeRect, nodeRect);
        const partiallyVisible = partially && overlappingArea > 0;
        return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;
      });
    },
    isNodeIntersecting: (nodeOrRect, area, partially = true) => {
      const isRect = isRectObject(nodeOrRect);
      const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);
      if (!nodeRect) {
        return false;
      }
      const overlappingArea = getOverlappingArea(nodeRect, area);
      const partiallyVisible = partially && overlappingArea > 0;
      return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;
    },
    deleteElements: async ({ nodes: nodesToRemove = [], edges: edgesToRemove = [] }) => {
      const { nodes: matchingNodes, edges: matchingEdges } = await getElementsToRemove({
        nodesToRemove,
        edgesToRemove,
        nodes: get_store_value(nodes),
        edges: get_store_value(edges),
        onBeforeDelete: get_store_value(onbeforedelete)
      });
      if (matchingNodes) {
        nodes.update((nds) => nds.filter((node) => !matchingNodes.some(({ id: id2 }) => id2 === node.id)));
      }
      if (matchingEdges) {
        edges.update((eds) => eds.filter((edge) => !matchingEdges.some(({ id: id2 }) => id2 === edge.id)));
      }
      return {
        deletedNodes: matchingNodes,
        deletedEdges: matchingEdges
      };
    },
    screenToFlowPosition: (position, options = { snapToGrid: true }) => {
      const _domNode = get_store_value(domNode);
      if (!_domNode) {
        return position;
      }
      const _snapGrid = options.snapToGrid ? get_store_value(snapGrid) : false;
      const { x, y, zoom: zoom2 } = get_store_value(viewport);
      const { x: domX, y: domY } = _domNode.getBoundingClientRect();
      const correctedPosition = {
        x: position.x - domX,
        y: position.y - domY
      };
      return pointToRendererPoint(correctedPosition, [x, y, zoom2], _snapGrid !== null, _snapGrid || [1, 1]);
    },
    /**
     *
     * @param position
     * @returns
     */
    flowToScreenPosition: (position) => {
      const _domNode = get_store_value(domNode);
      if (!_domNode) {
        return position;
      }
      const { x, y, zoom: zoom2 } = get_store_value(viewport);
      const { x: domX, y: domY } = _domNode.getBoundingClientRect();
      const rendererPosition = rendererPointToPoint(position, [x, y, zoom2]);
      return {
        x: rendererPosition.x + domX,
        y: rendererPosition.y + domY
      };
    },
    toObject: () => {
      return {
        nodes: get_store_value(nodes).map((node) => ({
          ...node,
          // we want to make sure that changes to the nodes object that gets returned by toObject
          // do not affect the nodes object
          position: { ...node.position },
          data: { ...node.data }
        })),
        edges: get_store_value(edges).map((edge) => ({ ...edge })),
        viewport: { ...get_store_value(viewport) }
      };
    },
    updateNode,
    updateNodeData: (id2, dataUpdate, options) => {
      var _a;
      const node = (_a = get_store_value(nodeLookup).get(id2)) == null ? void 0 : _a.internals.userNode;
      if (!node) {
        return;
      }
      const nextData = typeof dataUpdate === "function" ? dataUpdate(node) : dataUpdate;
      node.data = (options == null ? void 0 : options.replace) ? nextData : { ...node.data, ...nextData };
      nodes.update((nds) => nds);
    },
    viewport
  };
}
function getElements(lookup, ids) {
  var _a;
  const result = [];
  for (const id2 of ids) {
    const item = lookup.get(id2);
    if (item) {
      const element2 = "internals" in item ? (_a = item.internals) == null ? void 0 : _a.userNode : item;
      result.push(element2);
    }
  }
  return result;
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useUpdateNodeInternals.js
function useUpdateNodeInternals() {
  const { domNode, updateNodeInternals: updateNodeInternals2 } = useStore();
  const updateInternals = (id2) => {
    const updateIds = Array.isArray(id2) ? id2 : [id2];
    const updates = /* @__PURE__ */ new Map();
    updateIds.forEach((updateId) => {
      var _a;
      const nodeElement = (_a = get_store_value(domNode)) == null ? void 0 : _a.querySelector(`.svelte-flow__node[data-id="${updateId}"]`);
      if (nodeElement) {
        updates.set(updateId, { id: updateId, nodeElement, force: true });
      }
    });
    requestAnimationFrame(() => updateNodeInternals2(updates));
  };
  return updateInternals;
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useConnection.js
function useConnection() {
  const { connection } = useStore();
  return connection;
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useNodesEdges.js
function useNodes() {
  const { nodes } = useStore();
  return nodes;
}
function useEdges() {
  const { edges } = useStore();
  return edges;
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useHandleConnections.js
var initialConnections = [];
function useHandleConnections({ type, nodeId, id: id2 = null }) {
  const { edges, connectionLookup } = useStore();
  const _nodeId = getContext("svelteflow__node_id");
  const currentNodeId = nodeId ?? _nodeId;
  let prevConnections = void 0;
  return derived([edges, connectionLookup], ([, connectionLookup2], set3) => {
    const nextConnections = connectionLookup2.get(`${currentNodeId}-${type}-${id2 || null}`);
    if (!areConnectionMapsEqual(nextConnections, prevConnections)) {
      prevConnections = nextConnections;
      set3(Array.from((prevConnections == null ? void 0 : prevConnections.values()) || []));
    }
  }, initialConnections);
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useNodesData.js
function useNodesData(nodeIds) {
  const { nodes, nodeLookup } = useStore();
  let prevNodesData = [];
  return derived([nodes, nodeLookup], ([, nodeLookup2], set3) => {
    var _a;
    const nextNodesData = [];
    const isArrayOfIds = Array.isArray(nodeIds);
    const _nodeIds = isArrayOfIds ? nodeIds : [nodeIds];
    for (const nodeId of _nodeIds) {
      const node = (_a = nodeLookup2.get(nodeId)) == null ? void 0 : _a.internals.userNode;
      if (node) {
        nextNodesData.push({
          id: node.id,
          type: node.type,
          data: node.data
        });
      }
    }
    if (!shallowNodeData(nextNodesData, prevNodesData)) {
      prevNodesData = nextNodesData;
      set3(isArrayOfIds ? nextNodesData : nextNodesData[0] ?? null);
    }
  });
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useInternalNode.js
function useInternalNode(id2) {
  const { nodeLookup, nodes } = useStore();
  return derived([nodeLookup, nodes], ([nodeLookup2]) => nodeLookup2.get(id2));
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useInitialized.js
function useNodesInitialized() {
  const { nodesInitialized } = useStore();
  return {
    subscribe: nodesInitialized.subscribe
  };
}
function useInitialized() {
  const { initialized } = useStore();
  return {
    subscribe: initialized.subscribe
  };
}
export {
  Background_default as Background,
  BackgroundVariant,
  BaseEdge_default as BaseEdge,
  BezierEdge_default as BezierEdge,
  ConnectionLineType,
  ConnectionMode,
  ControlButton_default as ControlButton,
  Controls_default as Controls,
  EdgeLabel_default as EdgeLabel,
  EdgeLabelRenderer_default as EdgeLabelRenderer,
  Handle_default as Handle,
  MarkerType,
  Minimap_default as MiniMap,
  ResizeControl_default as NodeResizeControl,
  NodeResizer_default as NodeResizer,
  NodeToolbar_default as NodeToolbar,
  PanOnScrollMode,
  Panel_default as Panel,
  Position,
  SelectionMode,
  SmoothStepEdge_default as SmoothStepEdge,
  StepEdge_default as StepEdge,
  StraightEdge_default as StraightEdge,
  SvelteFlow_default as SvelteFlow,
  SvelteFlowProvider_default as SvelteFlowProvider,
  ViewportPortal_default as ViewportPortal,
  addEdge,
  getBezierEdgeCenter,
  getBezierPath,
  getConnectedEdges,
  getEdgeCenter,
  getIncomers,
  getNodesBounds,
  getOutgoers,
  getSmoothStepPath,
  getStraightPath,
  getViewportForBounds,
  isEdge,
  isNode,
  useConnection,
  useEdges,
  useHandleConnections,
  useInitialized,
  useInternalNode,
  useNodes,
  useNodesData,
  useNodesInitialized,
  useStore,
  useSvelteFlow,
  useUpdateNodeInternals
};
//# sourceMappingURL=@xyflow_svelte.js.map
